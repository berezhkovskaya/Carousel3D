/**
 * \file ExpReg_Core1.cpp
 * \brief Autogenerated via LinderScript Database Compiler 0.9.24
 * \version 0.6.06
 * \date 16/01/2012
 * \author Sergey Kosarevsky, 2005-2011
 * \author Viktor Latypov, 2007-2011
 * \author support@linderdaum.com http://www.linderdaum.com
 */

#include "Generated/MethodBind.h"

#include "Core/Linker.h"
#include "Core/RTTI/iStaticClass.h"
#include "Core/RTTI/FieldBinding.h"
#include "Core/RTTI/PropertyMacros.h"

#include "Core/VFS/ML.h"

// Custom include file
#include "Generated/CoreExport_Includes.h"

#define REG_CLS_MTD(ClsName, MtdName) \
StaticClass->RegisterMethod( BindNativeMethod( & ClsName :: MtdName, #MtdName ) );

#include "Linderdaum/Physics/BoxScene.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: Box2DBody
// SCALAR_PROPERTY_LOAD__SETTER
// Friction
// ""
// Box2DBody
// SetFriction
// LStr::ToFloat

bool LoadScalarField_Box2DBody_Friction_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<Box2DBody*>(Obj))->SetFriction(LStr::ToFloat( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Friction
// ""
// Box2DBody
// GetFriction
// LStr::ToStrEpsilon

bool SaveScalarField_Box2DBody_Friction_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<Box2DBody*>(Obj)->GetFriction() ); 
   *Result = new mlNode("Friction" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// Mass
// ""
// Box2DBody
// SetMass
// LStr::ToFloat

bool LoadScalarField_Box2DBody_Mass_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<Box2DBody*>(Obj))->SetMass(LStr::ToFloat( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Mass
// ""
// Box2DBody
// GetMass
// LStr::ToStrEpsilon

bool SaveScalarField_Box2DBody_Mass_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<Box2DBody*>(Obj)->GetMass() ); 
   *Result = new mlNode("Mass" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// Size
// ""
// Box2DBody
// SetSize
// LStr::StrToVec2

bool LoadScalarField_Box2DBody_Size_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<Box2DBody*>(Obj))->SetSize(LStr::StrToVec2( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Size
// ""
// Box2DBody
// GetSize
// LStr::Vec2ToStr

bool SaveScalarField_Box2DBody_Size_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::Vec2ToStr(dynamic_cast<Box2DBody*>(Obj)->GetSize() ); 
   *Result = new mlNode("Size" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// Angle
// ""
// Box2DBody
// SetAngle
// LStr::ToFloat

bool LoadScalarField_Box2DBody_Angle_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<Box2DBody*>(Obj))->SetAngle(LStr::ToFloat( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Angle
// ""
// Box2DBody
// GetAngle
// LStr::ToStrEpsilon

bool SaveScalarField_Box2DBody_Angle_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<Box2DBody*>(Obj)->GetAngle() ); 
   *Result = new mlNode("Angle" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// Position
// ""
// Box2DBody
// SetPosition
// LStr::StrToVec2

bool LoadScalarField_Box2DBody_Position_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<Box2DBody*>(Obj))->SetPosition(LStr::StrToVec2( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Position
// ""
// Box2DBody
// GetPosition
// LStr::Vec2ToStr

bool SaveScalarField_Box2DBody_Position_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::Vec2ToStr(dynamic_cast<Box2DBody*>(Obj)->GetPosition() ); 
   *Result = new mlNode("Position" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// AngVelocity
// ""
// Box2DBody
// SetAngVelocity
// LStr::ToFloat

bool LoadScalarField_Box2DBody_AngVelocity_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<Box2DBody*>(Obj))->SetAngVelocity(LStr::ToFloat( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// AngVelocity
// ""
// Box2DBody
// GetAngVelocity
// LStr::ToStrEpsilon

bool SaveScalarField_Box2DBody_AngVelocity_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<Box2DBody*>(Obj)->GetAngVelocity() ); 
   *Result = new mlNode("AngVelocity" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// Velocity
// ""
// Box2DBody
// SetVelocity
// LStr::StrToVec2

bool LoadScalarField_Box2DBody_Velocity_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<Box2DBody*>(Obj))->SetVelocity(LStr::StrToVec2( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Velocity
// ""
// Box2DBody
// GetVelocity
// LStr::Vec2ToStr

bool SaveScalarField_Box2DBody_Velocity_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::Vec2ToStr(dynamic_cast<Box2DBody*>(Obj)->GetVelocity() ); 
   *Result = new mlNode("Velocity" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// Torque
// ""
// Box2DBody
// SetTorque
// LStr::ToFloat

bool LoadScalarField_Box2DBody_Torque_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<Box2DBody*>(Obj))->SetTorque(LStr::ToFloat( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Torque
// ""
// Box2DBody
// GetTorque
// LStr::ToStrEpsilon

bool SaveScalarField_Box2DBody_Torque_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<Box2DBody*>(Obj)->GetTorque() ); 
   *Result = new mlNode("Torque" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// Force
// ""
// Box2DBody
// SetForce
// LStr::StrToVec2

bool LoadScalarField_Box2DBody_Force_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<Box2DBody*>(Obj))->SetForce(LStr::StrToVec2( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Force
// ""
// Box2DBody
// GetForce
// LStr::Vec2ToStr

bool SaveScalarField_Box2DBody_Force_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::Vec2ToStr(dynamic_cast<Box2DBody*>(Obj)->GetForce() ); 
   *Result = new mlNode("Force" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// Color
// FColor
// Box2DBody
// FColor
// LStr::StrToVec4

bool LoadScalarField_Box2DBody_FColor_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<Box2DBody*>(Obj))->FColor=LStr::StrToVec4( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// Color
// FColor
// Box2DBody
// FColor
// LStr::Vec4ToStr

bool SaveScalarField_Box2DBody_FColor_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::Vec4ToStr(dynamic_cast<Box2DBody*>(Obj)->FColor); 
   *Result = new mlNode("Color" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}




void RegisterPackageLinderdaumCoreClass0(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<Box2DBody>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(Box2DBody,Mtd)
   _RM__(GetBody)
   _RM__(SetPosition)
   _RM__(GetPosition)
   _RM__(SetAngle)
   _RM__(GetAngle)
   _RM__(SetVelocity)
   _RM__(GetVelocity)
   _RM__(SetAngVelocity)
   _RM__(GetAngVelocity)
   _RM__(SetForce)
   _RM__(GetForce)
   _RM__(SetTorque)
   _RM__(GetTorque)
   _RM__(GetFriction)
   _RM__(SetFriction)
   _RM__(GetMass)
   _RM__(SetMass)
   _RM__(GetSize)
   _RM__(SetSize)
   _RM__(GetI)
   #undef _RM__
#endif // _DISABLE_METHODS_
   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Friction, Box2DBody, Friction)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Mass, Box2DBody, Mass)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Size, Box2DBody, Size)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Angle, Box2DBody, Angle)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Position, Box2DBody, Position)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(AngVelocity, Box2DBody, AngVelocity)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Velocity, Box2DBody, Velocity)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Torque, Box2DBody, Torque)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Force, Box2DBody, Force)

   REGISTER_PROPERTY__SCALAR_FIELD(FColor, Box2DBody, Color)

   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: Box2DJoint
// SCALAR_PROPERTY_LOAD__SETTER
// Body1
// ""
// Box2DJoint
// SetBody1Name
// EMPTY_CONVERTER

bool LoadScalarField_Box2DJoint_Body1_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<Box2DJoint*>(Obj))->SetBody1Name(EMPTY_CONVERTER( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Body1
// ""
// Box2DJoint
// GetBody1Name
// EMPTY_CONVERTER

bool SaveScalarField_Box2DJoint_Body1_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =EMPTY_CONVERTER(dynamic_cast<Box2DJoint*>(Obj)->GetBody1Name() ); 
   *Result = new mlNode("Body1" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// Body2
// ""
// Box2DJoint
// SetBody2Name
// EMPTY_CONVERTER

bool LoadScalarField_Box2DJoint_Body2_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<Box2DJoint*>(Obj))->SetBody2Name(EMPTY_CONVERTER( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Body2
// ""
// Box2DJoint
// GetBody2Name
// EMPTY_CONVERTER

bool SaveScalarField_Box2DJoint_Body2_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =EMPTY_CONVERTER(dynamic_cast<Box2DJoint*>(Obj)->GetBody2Name() ); 
   *Result = new mlNode("Body2" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// Bias
// ""
// Box2DJoint
// SetBias
// LStr::ToFloat

bool LoadScalarField_Box2DJoint_Bias_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<Box2DJoint*>(Obj))->SetBias(LStr::ToFloat( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Bias
// ""
// Box2DJoint
// GetBias
// LStr::ToStrEpsilon

bool SaveScalarField_Box2DJoint_Bias_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<Box2DJoint*>(Obj)->GetBias() ); 
   *Result = new mlNode("Bias" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// Softness
// ""
// Box2DJoint
// SetSoftness
// LStr::ToFloat

bool LoadScalarField_Box2DJoint_Softness_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<Box2DJoint*>(Obj))->SetSoftness(LStr::ToFloat( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Softness
// ""
// Box2DJoint
// GetSoftness
// LStr::ToStrEpsilon

bool SaveScalarField_Box2DJoint_Softness_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<Box2DJoint*>(Obj)->GetSoftness() ); 
   *Result = new mlNode("Softness" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// Anchor
// ""
// Box2DJoint
// SetAnchor
// LStr::StrToVec2

bool LoadScalarField_Box2DJoint_Anchor_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<Box2DJoint*>(Obj))->SetAnchor(LStr::StrToVec2( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Anchor
// ""
// Box2DJoint
// GetAnchor
// LStr::Vec2ToStr

bool SaveScalarField_Box2DJoint_Anchor_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::Vec2ToStr(dynamic_cast<Box2DJoint*>(Obj)->GetAnchor() ); 
   *Result = new mlNode("Anchor" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// Color
// FColor
// Box2DJoint
// FColor
// LStr::StrToVec4

bool LoadScalarField_Box2DJoint_FColor_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<Box2DJoint*>(Obj))->FColor=LStr::StrToVec4( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// Color
// FColor
// Box2DJoint
// FColor
// LStr::Vec4ToStr

bool SaveScalarField_Box2DJoint_FColor_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::Vec4ToStr(dynamic_cast<Box2DJoint*>(Obj)->FColor); 
   *Result = new mlNode("Color" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}




void RegisterPackageLinderdaumCoreClass1(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<Box2DJoint>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(Box2DJoint,Mtd)
   _RM__(SetScene)
   _RM__(AfterConstruction)
   _RM__(EndLoad)
   _RM__(SetBody1)
   _RM__(SetBody2)
   _RM__(GetBody1)
   _RM__(GetBody2)
   _RM__(GetAnchor1)
   _RM__(GetAnchor2)
   _RM__(GetAnchor)
   _RM__(SetAnchor)
   _RM__(SetBias)
   _RM__(GetBias)
   _RM__(SetSoftness)
   _RM__(GetSoftness)
   _RM__(SetBody1Name)
   _RM__(SetBody2Name)
   _RM__(GetBody1Name)
   _RM__(GetBody2Name)
   #undef _RM__
#endif // _DISABLE_METHODS_
   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Body1, Box2DJoint, Body1)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Body2, Box2DJoint, Body2)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Bias, Box2DJoint, Bias)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Softness, Box2DJoint, Softness)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Anchor, Box2DJoint, Anchor)

   REGISTER_PROPERTY__SCALAR_FIELD(FColor, Box2DJoint, Color)

   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: Box2DScene
// SCALAR_PROPERTY_LOAD__SETTER
// Pause
// ""
// Box2DScene
// SetPause
// LStr::ToBool

bool LoadScalarField_Box2DScene_Pause_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<Box2DScene*>(Obj))->SetPause(LStr::ToBool( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Pause
// ""
// Box2DScene
// IsPaused
// LStr::ToStr_Bool

bool SaveScalarField_Box2DScene_Pause_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::ToStr_Bool(dynamic_cast<Box2DScene*>(Obj)->IsPaused() ); 
   *Result = new mlNode("Pause" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// TimeStep
// ""
// Box2DScene
// SetTimeStep
// LStr::ToFloat

bool LoadScalarField_Box2DScene_TimeStep_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<Box2DScene*>(Obj))->SetTimeStep(LStr::ToFloat( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// TimeStep
// ""
// Box2DScene
// GetTimeStep
// LStr::ToStrEpsilon

bool SaveScalarField_Box2DScene_TimeStep_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<Box2DScene*>(Obj)->GetTimeStep() ); 
   *Result = new mlNode("TimeStep" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// Gravity
// ""
// Box2DScene
// SetGravity
// LStr::StrToVec2

bool LoadScalarField_Box2DScene_Gravity_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<Box2DScene*>(Obj))->SetGravity(LStr::StrToVec2( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Gravity
// ""
// Box2DScene
// GetGravity
// LStr::Vec2ToStr

bool SaveScalarField_Box2DScene_Gravity_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::Vec2ToStr(dynamic_cast<Box2DScene*>(Obj)->GetGravity() ); 
   *Result = new mlNode("Gravity" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// OBJECT_ARRAY_PROPERTY_LOAD__FIELD
// Bodies
// FBodies
// Box2DScene
// Box2DBody

bool LoadObjectItem_Box2DScene_FBodies_FIELD(mlNode* Node, iObject* Obj, int i) 
{
   FIX_PARSER_DEFECT(RealNode, Node->children[i]) 
  Box2DBody* Ptr = NULL; 
   bool Res = Obj->Env->Linker->LoadObject(RealNode, reinterpret_cast<iObject**>(&Ptr)); 
  Box2DScene* CastedObj = dynamic_cast<Box2DScene*>(Obj); 
   if ( Res ) CastedObj->FBodies[i] = Ptr; 
   return Res; 
}

// OBJECT_ARRAY_PROPERTY_SAVE__FIELD
// Bodies
// FBodies
// Box2DScene

bool SaveObjectItem_Box2DScene_FBodies_FIELD(iObject* Obj, int i, mlNode** Result) 
{
   return (dynamic_cast<Box2DScene*>(Obj)->FBodies[i])->Save(Result);
}


// ARRAY_PROPERTY_FUNCTIONS__FIELD
// FBodies
// Box2DScene

   ARRAY_PROPERTY_RESIZE_FUNCTION__FIELD(FBodies,Box2DScene) 
   ARRAY_PROPERTY_SIZE_FUNCTION__FIELD(FBodies,Box2DScene) 
   ARRAY_PROPERTY_CLEAR_FUNCTION__FIELD(FBodies,Box2DScene)


// ARRAY_PROPERTY_DELETE_FUNCTION__FIELD
// FBodies
// Box2DScene

void DeleteFunction_Box2DScene_FBodies_FIELD(iObject* Obj, int Resize) 
{ 
   int Size = SizeFunction_Box2DScene_FBodies_FIELD(Obj); 
   for (int i = 0 ; i < Size ; i++) 
   { 
      dynamic_cast<Box2DScene*>(Obj)->FBodies[i] ->DisposeObject(); 
   }
   dynamic_cast<Box2DScene*>(Obj)->FBodies.clear(); 
}



// OBJECT_ARRAY_PROPERTY_LOAD__FIELD
// Joints
// FJoints
// Box2DScene
// Box2DJoint

bool LoadObjectItem_Box2DScene_FJoints_FIELD(mlNode* Node, iObject* Obj, int i) 
{
   FIX_PARSER_DEFECT(RealNode, Node->children[i]) 
  Box2DJoint* Ptr = NULL; 
   bool Res = Obj->Env->Linker->LoadObject(RealNode, reinterpret_cast<iObject**>(&Ptr)); 
  Box2DScene* CastedObj = dynamic_cast<Box2DScene*>(Obj); 
   if ( Res ) CastedObj->FJoints[i] = Ptr; 
   return Res; 
}

// OBJECT_ARRAY_PROPERTY_SAVE__FIELD
// Joints
// FJoints
// Box2DScene

bool SaveObjectItem_Box2DScene_FJoints_FIELD(iObject* Obj, int i, mlNode** Result) 
{
   return (dynamic_cast<Box2DScene*>(Obj)->FJoints[i])->Save(Result);
}


// ARRAY_PROPERTY_FUNCTIONS__FIELD
// FJoints
// Box2DScene

   ARRAY_PROPERTY_RESIZE_FUNCTION__FIELD(FJoints,Box2DScene) 
   ARRAY_PROPERTY_SIZE_FUNCTION__FIELD(FJoints,Box2DScene) 
   ARRAY_PROPERTY_CLEAR_FUNCTION__FIELD(FJoints,Box2DScene)


// ARRAY_PROPERTY_DELETE_FUNCTION__FIELD
// FJoints
// Box2DScene

void DeleteFunction_Box2DScene_FJoints_FIELD(iObject* Obj, int Resize) 
{ 
   int Size = SizeFunction_Box2DScene_FJoints_FIELD(Obj); 
   for (int i = 0 ; i < Size ; i++) 
   { 
      dynamic_cast<Box2DScene*>(Obj)->FJoints[i] ->DisposeObject(); 
   }
   dynamic_cast<Box2DScene*>(Obj)->FJoints.clear(); 
}



// SCALAR_PROPERTY_LOAD__SETTER
// Iterations
// ""
// Box2DScene
// SetIterations
// LStr::ToInt

bool LoadScalarField_Box2DScene_Iterations_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<Box2DScene*>(Obj))->SetIterations(LStr::ToInt( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Iterations
// ""
// Box2DScene
// GetIterations
// LStr::ToStr

bool SaveScalarField_Box2DScene_Iterations_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::ToStr(dynamic_cast<Box2DScene*>(Obj)->GetIterations() ); 
   *Result = new mlNode("Iterations" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// AccumulateImpulses
// ""
// Box2DScene
// SetAccumulateImpulses
// LStr::ToBool

bool LoadScalarField_Box2DScene_AccumulateImpulses_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<Box2DScene*>(Obj))->SetAccumulateImpulses(LStr::ToBool( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// AccumulateImpulses
// ""
// Box2DScene
// GetAccumulateImpulses
// LStr::ToStr_Bool

bool SaveScalarField_Box2DScene_AccumulateImpulses_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::ToStr_Bool(dynamic_cast<Box2DScene*>(Obj)->GetAccumulateImpulses() ); 
   *Result = new mlNode("AccumulateImpulses" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// PositionCorrection
// ""
// Box2DScene
// SetPositionCorrection
// LStr::ToBool

bool LoadScalarField_Box2DScene_PositionCorrection_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<Box2DScene*>(Obj))->SetPositionCorrection(LStr::ToBool( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// PositionCorrection
// ""
// Box2DScene
// GetPositionCorrection
// LStr::ToStr_Bool

bool SaveScalarField_Box2DScene_PositionCorrection_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::ToStr_Bool(dynamic_cast<Box2DScene*>(Obj)->GetPositionCorrection() ); 
   *Result = new mlNode("PositionCorrection" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// WarmStarting
// ""
// Box2DScene
// SetWarmStarting
// LStr::ToBool

bool LoadScalarField_Box2DScene_WarmStarting_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<Box2DScene*>(Obj))->SetWarmStarting(LStr::ToBool( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// WarmStarting
// ""
// Box2DScene
// GetWarmStarting
// LStr::ToStr_Bool

bool SaveScalarField_Box2DScene_WarmStarting_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::ToStr_Bool(dynamic_cast<Box2DScene*>(Obj)->GetWarmStarting() ); 
   *Result = new mlNode("WarmStarting" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}




void RegisterPackageLinderdaumCoreClass2(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<Box2DScene>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(Box2DScene,Mtd)
   _RM__(AfterConstruction)
   _RM__(IsPaused)
   _RM__(SetPause)
   _RM__(Update)
   _RM__(SetTimeStep)
   _RM__(GetTimeStep)
   _RM__(SetIterations)
   _RM__(GetIterations)
   _RM__(SetGravity)
   _RM__(GetGravity)
   _RM__(GetWarmStarting)
   _RM__(GetAccumulateImpulses)
   _RM__(GetPositionCorrection)
   _RM__(SetAccumulateImpulses)
   _RM__(SetPositionCorrection)
   _RM__(SetWarmStarting)
   _RM__(CreateBody)
   _RM__(CreateNamedBody)
   _RM__(CreateBodyPos)
   _RM__(CreateNamedBodyPos)
   _RM__(CreateJoint)
   _RM__(CreateNamedJoint)
   _RM__(ClearBodies)
   _RM__(ClearJoints)
   _RM__(GetBody)
   _RM__(SetBody)
   _RM__(GetJoint)
   _RM__(SetJoint)
   _RM__(GetNumBodies)
   _RM__(GetNumJoints)
   _RM__(AddBody)
   _RM__(AddJoint)
   _RM__(RemoveBody)
   _RM__(RemoveBodyIdx)
   _RM__(RemoveJointIdx)
   _RM__(GetJointIndex)
   _RM__(GetBodyIndex)
   _RM__(GetJointByName)
   _RM__(GetBodyByName)
   _RM__(GetJointAtPoint)
   _RM__(GetBodyAtPoint)
   _RM__(HasJointsForBody)
   _RM__(EndLoad)
   _RM__(AddGround)
   _RM__(MakeSuspensionBridge)
   _RM__(RenderDebug)
   #undef _RM__
#endif // _DISABLE_METHODS_
   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Pause, Box2DScene, Pause)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(TimeStep, Box2DScene, TimeStep)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Gravity, Box2DScene, Gravity)

   REGISTER_PROPERTY__OBJECT_ARRAY_FIELD(FBodies, Box2DScene, Bodies)

   REGISTER_PROPERTY__OBJECT_ARRAY_FIELD(FJoints, Box2DScene, Joints)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Iterations, Box2DScene, Iterations)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(AccumulateImpulses, Box2DScene, AccumulateImpulses)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(PositionCorrection, Box2DScene, PositionCorrection)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(WarmStarting, Box2DScene, WarmStarting)

   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/Physics/CollisionIntervals.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: LAxisList
// SCALAR_PROPERTY_LOAD__FIELD
// Axis
// FAxis
// LAxisList
// FAxis
// LStr::StrToVec3

bool LoadScalarField_LAxisList_FAxis_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<LAxisList*>(Obj))->FAxis=LStr::StrToVec3( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// Axis
// FAxis
// LAxisList
// FAxis
// LStr::Vec3ToStr

bool SaveScalarField_LAxisList_FAxis_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::Vec3ToStr(dynamic_cast<LAxisList*>(Obj)->FAxis); 
   *Result = new mlNode("Axis" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// OBJECT_ARRAY_PROPERTY_LOAD__FIELD
// Intervals
// FIntervals
// LAxisList
// LInterval

bool LoadObjectItem_LAxisList_FIntervals_FIELD(mlNode* Node, iObject* Obj, int i) 
{
   FIX_PARSER_DEFECT(RealNode, Node->children[i]) 
  LInterval* Ptr = NULL; 
   bool Res = Obj->Env->Linker->LoadObject(RealNode, reinterpret_cast<iObject**>(&Ptr)); 
  LAxisList* CastedObj = dynamic_cast<LAxisList*>(Obj); 
   if ( Res ) CastedObj->FIntervals[i] = Ptr; 
   return Res; 
}

// OBJECT_ARRAY_PROPERTY_SAVE__FIELD
// Intervals
// FIntervals
// LAxisList

bool SaveObjectItem_LAxisList_FIntervals_FIELD(iObject* Obj, int i, mlNode** Result) 
{
   return (dynamic_cast<LAxisList*>(Obj)->FIntervals[i])->Save(Result);
}


// ARRAY_PROPERTY_FUNCTIONS__FIELD
// FIntervals
// LAxisList

   ARRAY_PROPERTY_RESIZE_FUNCTION__FIELD(FIntervals,LAxisList) 
   ARRAY_PROPERTY_SIZE_FUNCTION__FIELD(FIntervals,LAxisList) 
   ARRAY_PROPERTY_CLEAR_FUNCTION__FIELD(FIntervals,LAxisList)


// ARRAY_PROPERTY_DELETE_FUNCTION__FIELD
// FIntervals
// LAxisList

void DeleteFunction_LAxisList_FIntervals_FIELD(iObject* Obj, int Resize) 
{ 
   int Size = SizeFunction_LAxisList_FIntervals_FIELD(Obj); 
   for (int i = 0 ; i < Size ; i++) 
   { 
      dynamic_cast<LAxisList*>(Obj)->FIntervals[i] ->DisposeObject(); 
   }
   dynamic_cast<LAxisList*>(Obj)->FIntervals.clear(); 
}





void RegisterPackageLinderdaumCoreClass3(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<LAxisList>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   REG_CLS_MTD( LAxisList,GetInterval )
   REG_CLS_MTD( LAxisList,SetInterval )
#endif // _DISABLE_METHODS_
   REGISTER_PROPERTY__SCALAR_FIELD(FAxis, LAxisList, Axis)

   REGISTER_PROPERTY__OBJECT_ARRAY_FIELD(FIntervals, LAxisList, Intervals)

   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/Physics/Collider.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: LCollider
// OBJECT_ARRAY_PROPERTY_LOAD__FIELD
// AxisLists
// FIntervalList
// LCollider
// LAxisList

bool LoadObjectItem_LCollider_FIntervalList_FIELD(mlNode* Node, iObject* Obj, int i) 
{
   FIX_PARSER_DEFECT(RealNode, Node->children[i]) 
  LAxisList* Ptr = NULL; 
   bool Res = Obj->Env->Linker->LoadObject(RealNode, reinterpret_cast<iObject**>(&Ptr)); 
  LCollider* CastedObj = dynamic_cast<LCollider*>(Obj); 
   if ( Res ) CastedObj->FIntervalList[i] = Ptr; 
   return Res; 
}

// OBJECT_ARRAY_PROPERTY_SAVE__FIELD
// AxisLists
// FIntervalList
// LCollider

bool SaveObjectItem_LCollider_FIntervalList_FIELD(iObject* Obj, int i, mlNode** Result) 
{
   return (dynamic_cast<LCollider*>(Obj)->FIntervalList[i])->Save(Result);
}


// ARRAY_PROPERTY_FUNCTIONS__FIELD
// FIntervalList
// LCollider

   ARRAY_PROPERTY_RESIZE_FUNCTION__FIELD(FIntervalList,LCollider) 
   ARRAY_PROPERTY_SIZE_FUNCTION__FIELD(FIntervalList,LCollider) 
   ARRAY_PROPERTY_CLEAR_FUNCTION__FIELD(FIntervalList,LCollider)


// ARRAY_PROPERTY_DELETE_FUNCTION__FIELD
// FIntervalList
// LCollider

void DeleteFunction_LCollider_FIntervalList_FIELD(iObject* Obj, int Resize) 
{ 
   int Size = SizeFunction_LCollider_FIntervalList_FIELD(Obj); 
   for (int i = 0 ; i < Size ; i++) 
   { 
      dynamic_cast<LCollider*>(Obj)->FIntervalList[i] ->DisposeObject(); 
   }
   dynamic_cast<LCollider*>(Obj)->FIntervalList.clear(); 
}



// OBJECT_ARRAY_PROPERTY_LOAD__FIELD
// Shapes
// FShapes
// LCollider
// LCollisionShape

bool LoadObjectItem_LCollider_FShapes_FIELD(mlNode* Node, iObject* Obj, int i) 
{
   FIX_PARSER_DEFECT(RealNode, Node->children[i]) 
  LCollisionShape* Ptr = NULL; 
   bool Res = Obj->Env->Linker->LoadObject(RealNode, reinterpret_cast<iObject**>(&Ptr)); 
  LCollider* CastedObj = dynamic_cast<LCollider*>(Obj); 
   if ( Res ) CastedObj->FShapes[i] = Ptr; 
   return Res; 
}

// OBJECT_ARRAY_PROPERTY_SAVE__FIELD
// Shapes
// FShapes
// LCollider

bool SaveObjectItem_LCollider_FShapes_FIELD(iObject* Obj, int i, mlNode** Result) 
{
   return (dynamic_cast<LCollider*>(Obj)->FShapes[i])->Save(Result);
}


// ARRAY_PROPERTY_FUNCTIONS__FIELD
// FShapes
// LCollider

   ARRAY_PROPERTY_RESIZE_FUNCTION__FIELD(FShapes,LCollider) 
   ARRAY_PROPERTY_SIZE_FUNCTION__FIELD(FShapes,LCollider) 
   ARRAY_PROPERTY_CLEAR_FUNCTION__FIELD(FShapes,LCollider)


// ARRAY_PROPERTY_DELETE_FUNCTION__FIELD
// FShapes
// LCollider

void DeleteFunction_LCollider_FShapes_FIELD(iObject* Obj, int Resize) 
{ 
   int Size = SizeFunction_LCollider_FShapes_FIELD(Obj); 
   for (int i = 0 ; i < Size ; i++) 
   { 
      dynamic_cast<LCollider*>(Obj)->FShapes[i] ->DisposeObject(); 
   }
   dynamic_cast<LCollider*>(Obj)->FShapes.clear(); 
}





void RegisterPackageLinderdaumCoreClass4(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<LCollider>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(LCollider,Mtd)
   _RM__(AddObject)
   _RM__(RemoveObject)
   _RM__(DetectBroadPhaseCollisions)
   _RM__(BruteForceIntersect)
   _RM__(ClearCallbacks)
   _RM__(SetDualCollisionCallback)
   _RM__(SetSingleCollisionCallback)
   _RM__(CreateCollisionSphere)
   _RM__(CreateCollisionBox)
   _RM__(CreateCollisionPlane)
   _RM__(SetAxisList)
   _RM__(GetAxisList)
   _RM__(SetShape)
   _RM__(GetShape)
   #undef _RM__
#endif // _DISABLE_METHODS_
   REGISTER_PROPERTY__OBJECT_ARRAY_FIELD(FIntervalList, LCollider, AxisLists)

   REGISTER_PROPERTY__OBJECT_ARRAY_FIELD(FShapes, LCollider, Shapes)

   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/Physics/CollisionShape.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: LCollisionShape
            // Adding abstract: CalculateExtents
      // Abstract method: CalculateExtents
// SCALAR_PROPERTY_LOAD__SETTER
// OwnerID
// ""
// LCollisionShape
// SetOwnerID
// EMPTY_CONVERTER

bool LoadScalarField_LCollisionShape_OwnerID_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<LCollisionShape*>(Obj))->SetOwnerID(EMPTY_CONVERTER( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// OwnerID
// ""
// LCollisionShape
// GetOwnerID
// EMPTY_CONVERTER

bool SaveScalarField_LCollisionShape_OwnerID_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =EMPTY_CONVERTER(dynamic_cast<LCollisionShape*>(Obj)->GetOwnerID() ); 
   *Result = new mlNode("OwnerID" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}




void RegisterPackageLinderdaumCoreClass5(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeAbstractStaticClass<LCollisionShape>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(LCollisionShape,Mtd)
   _RM__(CalculateExtents)
   _RM__(IsInfinite)
   _RM__(GetBodyParameters)
   _RM__(SetOwnerID)
   _RM__(GetOwnerID)
   _RM__(GetOwner)
   _RM__(SetOwner)
   #undef _RM__
#endif // _DISABLE_METHODS_
   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(OwnerID, LCollisionShape, OwnerID)

   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: LCollisionShape
            // Adding abstract: CalculateExtents
         // Class: LCollisionShape_Box
            // Overriding abstract: CalculateExtents

void RegisterPackageLinderdaumCoreClass6(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<LCollisionShape_Box>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   REG_CLS_MTD( LCollisionShape_Box,CalculateExtents )
   REG_CLS_MTD( LCollisionShape_Box,GetBodyParameters )
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "LCollisionShape" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: LCollisionShape
            // Adding abstract: CalculateExtents
         // Class: LCollisionShape_Plane
            // Overriding abstract: CalculateExtents
// SCALAR_PROPERTY_LOAD__FIELD
// Equation
// FEquation
// LCollisionShape_Plane
// FEquation
// LStr::StrToVec4

bool LoadScalarField_LCollisionShape_Plane_FEquation_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<LCollisionShape_Plane*>(Obj))->FEquation=LStr::StrToVec4( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// Equation
// FEquation
// LCollisionShape_Plane
// FEquation
// LStr::Vec4ToStr

bool SaveScalarField_LCollisionShape_Plane_FEquation_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::Vec4ToStr(dynamic_cast<LCollisionShape_Plane*>(Obj)->FEquation); 
   *Result = new mlNode("Equation" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}




void RegisterPackageLinderdaumCoreClass7(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<LCollisionShape_Plane>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   REG_CLS_MTD( LCollisionShape_Plane,IsInfinite )
   REG_CLS_MTD( LCollisionShape_Plane,CalculateExtents )
#endif // _DISABLE_METHODS_
   REGISTER_PROPERTY__SCALAR_FIELD(FEquation, LCollisionShape_Plane, Equation)

   StaticClass->SetSuperClassName( "LCollisionShape" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: LCollisionShape
            // Adding abstract: CalculateExtents
         // Class: LCollisionShape_Sphere
            // Overriding abstract: CalculateExtents
// SCALAR_PROPERTY_LOAD__FIELD
// Position
// FPosition
// LCollisionShape_Sphere
// FPosition
// LStr::StrToVec3

bool LoadScalarField_LCollisionShape_Sphere_FPosition_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<LCollisionShape_Sphere*>(Obj))->FPosition=LStr::StrToVec3( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// Position
// FPosition
// LCollisionShape_Sphere
// FPosition
// LStr::Vec3ToStr

bool SaveScalarField_LCollisionShape_Sphere_FPosition_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::Vec3ToStr(dynamic_cast<LCollisionShape_Sphere*>(Obj)->FPosition); 
   *Result = new mlNode("Position" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// Radius
// FRadius
// LCollisionShape_Sphere
// FRadius
// LStr::ToFloat

bool LoadScalarField_LCollisionShape_Sphere_FRadius_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<LCollisionShape_Sphere*>(Obj))->FRadius=LStr::ToFloat( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// Radius
// FRadius
// LCollisionShape_Sphere
// FRadius
// LStr::ToStrEpsilon

bool SaveScalarField_LCollisionShape_Sphere_FRadius_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<LCollisionShape_Sphere*>(Obj)->FRadius); 
   *Result = new mlNode("Radius" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}




void RegisterPackageLinderdaumCoreClass8(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<LCollisionShape_Sphere>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   REG_CLS_MTD( LCollisionShape_Sphere,CalculateExtents )
   REG_CLS_MTD( LCollisionShape_Sphere,GetBodyParameters )
#endif // _DISABLE_METHODS_
   REGISTER_PROPERTY__SCALAR_FIELD(FPosition, LCollisionShape_Sphere, Position)

   REGISTER_PROPERTY__SCALAR_FIELD(FRadius, LCollisionShape_Sphere, Radius)

   StaticClass->SetSuperClassName( "LCollisionShape" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/Physics/Control.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: LFeedbackLoop
            // Adding abstract: Update
      // Abstract method: Update
// SCALAR_PROPERTY_LOAD__FIELD
// StepSize
// FStepSize
// LFeedbackLoop
// FStepSize
// LStr::ToFloat

bool LoadScalarField_LFeedbackLoop_FStepSize_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<LFeedbackLoop*>(Obj))->FStepSize=LStr::ToFloat( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// StepSize
// FStepSize
// LFeedbackLoop
// FStepSize
// LStr::ToStrEpsilon

bool SaveScalarField_LFeedbackLoop_FStepSize_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<LFeedbackLoop*>(Obj)->FStepSize); 
   *Result = new mlNode("StepSize" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// MaxStepSize
// FMaxStepSize
// LFeedbackLoop
// FMaxStepSize
// LStr::ToFloat

bool LoadScalarField_LFeedbackLoop_FMaxStepSize_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<LFeedbackLoop*>(Obj))->FMaxStepSize=LStr::ToFloat( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// MaxStepSize
// FMaxStepSize
// LFeedbackLoop
// FMaxStepSize
// LStr::ToStrEpsilon

bool SaveScalarField_LFeedbackLoop_FMaxStepSize_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<LFeedbackLoop*>(Obj)->FMaxStepSize); 
   *Result = new mlNode("MaxStepSize" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}




void RegisterPackageLinderdaumCoreClass9(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeAbstractStaticClass<LFeedbackLoop>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   REG_CLS_MTD( LFeedbackLoop,GoalReached )
   REG_CLS_MTD( LFeedbackLoop,Update )
#endif // _DISABLE_METHODS_
   REGISTER_PROPERTY__SCALAR_FIELD(FStepSize, LFeedbackLoop, StepSize)

   REGISTER_PROPERTY__SCALAR_FIELD(FMaxStepSize, LFeedbackLoop, MaxStepSize)

   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: LInterval
// SCALAR_PROPERTY_LOAD__FIELD
// ShapeID
// FShape
// LInterval
// FShape
// LStr::ToInt

bool LoadScalarField_LInterval_FShape_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<LInterval*>(Obj))->FShape=LStr::ToInt( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// ShapeID
// FShape
// LInterval
// FShape
// LStr::ToStr

bool SaveScalarField_LInterval_FShape_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStr(dynamic_cast<LInterval*>(Obj)->FShape); 
   *Result = new mlNode("ShapeID" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// Min
// FMin
// LInterval
// FMin
// LStr::ToFloat

bool LoadScalarField_LInterval_FMin_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<LInterval*>(Obj))->FMin=LStr::ToFloat( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// Min
// FMin
// LInterval
// FMin
// LStr::ToStrEpsilon

bool SaveScalarField_LInterval_FMin_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<LInterval*>(Obj)->FMin); 
   *Result = new mlNode("Min" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// Max
// FMax
// LInterval
// FMax
// LStr::ToFloat

bool LoadScalarField_LInterval_FMax_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<LInterval*>(Obj))->FMax=LStr::ToFloat( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// Max
// FMax
// LInterval
// FMax
// LStr::ToStrEpsilon

bool SaveScalarField_LInterval_FMax_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<LInterval*>(Obj)->FMax); 
   *Result = new mlNode("Max" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}




void RegisterPackageLinderdaumCoreClass10(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<LInterval>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
#endif // _DISABLE_METHODS_
   REGISTER_PROPERTY__SCALAR_FIELD(FShape, LInterval, ShapeID)

   REGISTER_PROPERTY__SCALAR_FIELD(FMin, LInterval, Min)

   REGISTER_PROPERTY__SCALAR_FIELD(FMax, LInterval, Max)

   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: LFeedbackLoop
            // Adding abstract: Update
         // Class: LProportionalFeedbackLoop
            // Overriding abstract: Update
// SCALAR_ARRAY_PROPERTY_LOAD__FIELD
// Goal
// FGoal
// LProportionalFeedbackLoop
// LStr::ToFloat

bool LoadScalarItem_LProportionalFeedbackLoop_FGoal_FIELD(mlNode* Node, iObject* Obj, int i)
{ 
   FIX_PARSER_DEFECT(RealNode, Node->children[i]) 
/* dynamic_cast<LProportionalFeedbackLoop*>(Obj)-> TheArrayName [i] = (LStr::ToFloat( RealNode->getValue() ) );*/
   LString LocalValue = RealNode->getValue();
   LString RealValue;
   if ( LocalValue.empty() )
   {
      RealValue = RealNode->getID(); 
   }
   else
   {
      RealValue = RealNode->getID() + LString(" ") + LocalValue; 
   }
   dynamic_cast<LProportionalFeedbackLoop*>(Obj)->FGoal[i] = (LStr::ToFloat( RealValue ) );
   return true; 
}

// SCALAR_ARRAY_PROPERTY_SAVE__FIELD
// Goal
// FGoal
// LProportionalFeedbackLoop
// LStr::ToStrEpsilon

bool SaveScalarItem_LProportionalFeedbackLoop_FGoal_FIELD(iObject* Obj, int i, mlNode** Result) 
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<LProportionalFeedbackLoop*>(Obj)->FGoal[i]);   
/* mlNode* Res = new mlNode(#TheArrayName , Value); */ 
   *Result = new mlNode("", Value); 
   return true; 
}


// ARRAY_PROPERTY_FUNCTIONS__FIELD
// FGoal
// LProportionalFeedbackLoop

   ARRAY_PROPERTY_RESIZE_FUNCTION__FIELD(FGoal,LProportionalFeedbackLoop) 
   ARRAY_PROPERTY_SIZE_FUNCTION__FIELD(FGoal,LProportionalFeedbackLoop) 
   ARRAY_PROPERTY_CLEAR_FUNCTION__FIELD(FGoal,LProportionalFeedbackLoop)



// SCALAR_ARRAY_PROPERTY_LOAD__FIELD
// Gain
// FGain
// LProportionalFeedbackLoop
// LStr::ToFloat

bool LoadScalarItem_LProportionalFeedbackLoop_FGain_FIELD(mlNode* Node, iObject* Obj, int i)
{ 
   FIX_PARSER_DEFECT(RealNode, Node->children[i]) 
/* dynamic_cast<LProportionalFeedbackLoop*>(Obj)-> TheArrayName [i] = (LStr::ToFloat( RealNode->getValue() ) );*/
   LString LocalValue = RealNode->getValue();
   LString RealValue;
   if ( LocalValue.empty() )
   {
      RealValue = RealNode->getID(); 
   }
   else
   {
      RealValue = RealNode->getID() + LString(" ") + LocalValue; 
   }
   dynamic_cast<LProportionalFeedbackLoop*>(Obj)->FGain[i] = (LStr::ToFloat( RealValue ) );
   return true; 
}

// SCALAR_ARRAY_PROPERTY_SAVE__FIELD
// Gain
// FGain
// LProportionalFeedbackLoop
// LStr::ToStrEpsilon

bool SaveScalarItem_LProportionalFeedbackLoop_FGain_FIELD(iObject* Obj, int i, mlNode** Result) 
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<LProportionalFeedbackLoop*>(Obj)->FGain[i]);   
/* mlNode* Res = new mlNode(#TheArrayName , Value); */ 
   *Result = new mlNode("", Value); 
   return true; 
}


// ARRAY_PROPERTY_FUNCTIONS__FIELD
// FGain
// LProportionalFeedbackLoop

   ARRAY_PROPERTY_RESIZE_FUNCTION__FIELD(FGain,LProportionalFeedbackLoop) 
   ARRAY_PROPERTY_SIZE_FUNCTION__FIELD(FGain,LProportionalFeedbackLoop) 
   ARRAY_PROPERTY_CLEAR_FUNCTION__FIELD(FGain,LProportionalFeedbackLoop)



// SCALAR_ARRAY_PROPERTY_LOAD__FIELD
// State
// FState
// LProportionalFeedbackLoop
// LStr::ToFloat

bool LoadScalarItem_LProportionalFeedbackLoop_FState_FIELD(mlNode* Node, iObject* Obj, int i)
{ 
   FIX_PARSER_DEFECT(RealNode, Node->children[i]) 
/* dynamic_cast<LProportionalFeedbackLoop*>(Obj)-> TheArrayName [i] = (LStr::ToFloat( RealNode->getValue() ) );*/
   LString LocalValue = RealNode->getValue();
   LString RealValue;
   if ( LocalValue.empty() )
   {
      RealValue = RealNode->getID(); 
   }
   else
   {
      RealValue = RealNode->getID() + LString(" ") + LocalValue; 
   }
   dynamic_cast<LProportionalFeedbackLoop*>(Obj)->FState[i] = (LStr::ToFloat( RealValue ) );
   return true; 
}

// SCALAR_ARRAY_PROPERTY_SAVE__FIELD
// State
// FState
// LProportionalFeedbackLoop
// LStr::ToStrEpsilon

bool SaveScalarItem_LProportionalFeedbackLoop_FState_FIELD(iObject* Obj, int i, mlNode** Result) 
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<LProportionalFeedbackLoop*>(Obj)->FState[i]);   
/* mlNode* Res = new mlNode(#TheArrayName , Value); */ 
   *Result = new mlNode("", Value); 
   return true; 
}


// ARRAY_PROPERTY_FUNCTIONS__FIELD
// FState
// LProportionalFeedbackLoop

   ARRAY_PROPERTY_RESIZE_FUNCTION__FIELD(FState,LProportionalFeedbackLoop) 
   ARRAY_PROPERTY_SIZE_FUNCTION__FIELD(FState,LProportionalFeedbackLoop) 
   ARRAY_PROPERTY_CLEAR_FUNCTION__FIELD(FState,LProportionalFeedbackLoop)



// SCALAR_ARRAY_PROPERTY_LOAD__FIELD
// Angle
// FAngle
// LProportionalFeedbackLoop
// LStr::ToBool

bool LoadScalarItem_LProportionalFeedbackLoop_FAngle_FIELD(mlNode* Node, iObject* Obj, int i)
{ 
   FIX_PARSER_DEFECT(RealNode, Node->children[i]) 
/* dynamic_cast<LProportionalFeedbackLoop*>(Obj)-> TheArrayName [i] = (LStr::ToBool( RealNode->getValue() ) );*/
   LString LocalValue = RealNode->getValue();
   LString RealValue;
   if ( LocalValue.empty() )
   {
      RealValue = RealNode->getID(); 
   }
   else
   {
      RealValue = RealNode->getID() + LString(" ") + LocalValue; 
   }
   dynamic_cast<LProportionalFeedbackLoop*>(Obj)->FAngle[i] = (LStr::ToBool( RealValue ) );
   return true; 
}

// SCALAR_ARRAY_PROPERTY_SAVE__FIELD
// Angle
// FAngle
// LProportionalFeedbackLoop
// LStr::ToStr_Bool

bool SaveScalarItem_LProportionalFeedbackLoop_FAngle_FIELD(iObject* Obj, int i, mlNode** Result) 
{  
   LString Value =LStr::ToStr_Bool(dynamic_cast<LProportionalFeedbackLoop*>(Obj)->FAngle[i]);   
/* mlNode* Res = new mlNode(#TheArrayName , Value); */ 
   *Result = new mlNode("", Value); 
   return true; 
}


// ARRAY_PROPERTY_FUNCTIONS__FIELD
// FAngle
// LProportionalFeedbackLoop

   ARRAY_PROPERTY_RESIZE_FUNCTION__FIELD(FAngle,LProportionalFeedbackLoop) 
   ARRAY_PROPERTY_SIZE_FUNCTION__FIELD(FAngle,LProportionalFeedbackLoop) 
   ARRAY_PROPERTY_CLEAR_FUNCTION__FIELD(FAngle,LProportionalFeedbackLoop)





void RegisterPackageLinderdaumCoreClass11(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<LProportionalFeedbackLoop>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(LProportionalFeedbackLoop,Mtd)
   _RM__(GetNumGoals)
   _RM__(SetGain)
   _RM__(GetGain)
   _RM__(SetGoal)
   _RM__(GetGoal)
   _RM__(SetState)
   _RM__(GetState)
   _RM__(SetAngle)
   _RM__(GetAngle)
   _RM__(Update)
   #undef _RM__
#endif // _DISABLE_METHODS_
   REGISTER_PROPERTY__SCALAR_ARRAY_FIELD(FGoal, LProportionalFeedbackLoop, Goal)

   REGISTER_PROPERTY__SCALAR_ARRAY_FIELD(FGain, LProportionalFeedbackLoop, Gain)

   REGISTER_PROPERTY__SCALAR_ARRAY_FIELD(FState, LProportionalFeedbackLoop, State)

   REGISTER_PROPERTY__SCALAR_ARRAY_FIELD(FAngle, LProportionalFeedbackLoop, Angle)

   StaticClass->SetSuperClassName( "LFeedbackLoop" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: LFeedbackLoop
            // Adding abstract: Update
         // Class: LQuaternionFeedbackLoop
            // Overriding abstract: Update
// SCALAR_PROPERTY_LOAD__FIELD
// Goal
// FGoal
// LQuaternionFeedbackLoop
// FGoal
// LStr::StrToQuat

bool LoadScalarField_LQuaternionFeedbackLoop_FGoal_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<LQuaternionFeedbackLoop*>(Obj))->FGoal=LStr::StrToQuat( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// Goal
// FGoal
// LQuaternionFeedbackLoop
// FGoal
// LStr::QuatToStr

bool SaveScalarField_LQuaternionFeedbackLoop_FGoal_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::QuatToStr(dynamic_cast<LQuaternionFeedbackLoop*>(Obj)->FGoal); 
   *Result = new mlNode("Goal" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// Gain
// FGain
// LQuaternionFeedbackLoop
// FGain
// LStr::ToFloat

bool LoadScalarField_LQuaternionFeedbackLoop_FGain_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<LQuaternionFeedbackLoop*>(Obj))->FGain=LStr::ToFloat( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// Gain
// FGain
// LQuaternionFeedbackLoop
// FGain
// LStr::ToStrEpsilon

bool SaveScalarField_LQuaternionFeedbackLoop_FGain_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<LQuaternionFeedbackLoop*>(Obj)->FGain); 
   *Result = new mlNode("Gain" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// State
// FState
// LQuaternionFeedbackLoop
// FState
// LStr::StrToQuat

bool LoadScalarField_LQuaternionFeedbackLoop_FState_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<LQuaternionFeedbackLoop*>(Obj))->FState=LStr::StrToQuat( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// State
// FState
// LQuaternionFeedbackLoop
// FState
// LStr::QuatToStr

bool SaveScalarField_LQuaternionFeedbackLoop_FState_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::QuatToStr(dynamic_cast<LQuaternionFeedbackLoop*>(Obj)->FState); 
   *Result = new mlNode("State" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}




void RegisterPackageLinderdaumCoreClass12(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<LQuaternionFeedbackLoop>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(LQuaternionFeedbackLoop,Mtd)
   _RM__(Update)
   _RM__(SetGoal)
   _RM__(GetGoal)
   _RM__(SetGain)
   _RM__(GetGain)
   _RM__(SetState)
   _RM__(GetState)
   #undef _RM__
#endif // _DISABLE_METHODS_
   REGISTER_PROPERTY__SCALAR_FIELD(FGoal, LQuaternionFeedbackLoop, Goal)

   REGISTER_PROPERTY__SCALAR_FIELD(FGain, LQuaternionFeedbackLoop, Gain)

   REGISTER_PROPERTY__SCALAR_FIELD(FState, LQuaternionFeedbackLoop, State)

   StaticClass->SetSuperClassName( "LFeedbackLoop" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/Network/Network.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: LSocket
            // Adding abstract: GetIPProtocol
            // Adding abstract: GetSockType
      // Abstract method: GetIPProtocol
      // Abstract method: GetSockType

void RegisterPackageLinderdaumCoreClass13(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeAbstractStaticClass<LSocket>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(LSocket,Mtd)
   _RM__(Open)
   _RM__(Close)
   _RM__(CheckData)
   _RM__(Bind)
   _RM__(SendLine)
   _RM__(SendBytes)
   _RM__(WriteBytes)
   _RM__(ReadBytes)
   _RM__(Write)
   _RM__(Read)
   _RM__(WriteTo)
   _RM__(ReadFrom)
   _RM__(GetAddress)
   _RM__(GetPort)
   _RM__(IsError)
   _RM__(GetError)
   _RM__(IsOpened)
   _RM__(SetNonBlocking)
   _RM__(IsWouldBlock)
   #undef _RM__
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: LSocket
            // Adding abstract: GetIPProtocol
            // Adding abstract: GetSockType
         // Class: LTCPSocket
            // Overriding abstract: GetIPProtocol
            // Overriding abstract: GetSockType

void RegisterPackageLinderdaumCoreClass14(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<LTCPSocket>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(LTCPSocket,Mtd)
   _RM__(Accept)
   _RM__(Listen)
   _RM__(Connect)
   #undef _RM__
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "LSocket" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: LFeedbackLoop
            // Adding abstract: Update
         // Class: LTransformFeedbackLoop
            // Overriding abstract: Update

void RegisterPackageLinderdaumCoreClass15(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<LTransformFeedbackLoop>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(LTransformFeedbackLoop,Mtd)
   _RM__(Update)
   _RM__(SetGoal)
   _RM__(GetGoal)
   _RM__(SetState)
   _RM__(GetState)
   _RM__(SetOrientationGain)
   _RM__(SetPositionGain)
   _RM__(GetOrientationGain)
   _RM__(GetPositionGain)
   #undef _RM__
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "LFeedbackLoop" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: LSocket
            // Adding abstract: GetIPProtocol
            // Adding abstract: GetSockType
         // Class: LUDPSocket
            // Overriding abstract: GetIPProtocol
            // Overriding abstract: GetSockType

void RegisterPackageLinderdaumCoreClass16(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<LUDPSocket>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "LSocket" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: LSocket
            // Adding abstract: GetIPProtocol
            // Adding abstract: GetSockType
         // Class: LUDPSocket
            // Overriding abstract: GetIPProtocol
            // Overriding abstract: GetSockType
         // Class: LUDPSocket_Virtual

void RegisterPackageLinderdaumCoreClass17(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<LUDPSocket_Virtual>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(LUDPSocket_Virtual,Mtd)
   _RM__(Open)
   _RM__(Close)
   _RM__(Bind)
   _RM__(Write)
   _RM__(Read)
   _RM__(WriteTo)
   _RM__(ReadFrom)
   _RM__(IsOpened)
   _RM__(SetNonBlocking)
   _RM__(IsWouldBlock)
   _RM__(IsError)
   #undef _RM__
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "LUDPSocket" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/Input/OSInput.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: iInputDeviceList
            // Adding abstract: ReenumerateDevices
         // Class: LWinDeviceList
            // Overriding abstract: ReenumerateDevices

void RegisterPackageLinderdaumCoreClass18(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<LWinDeviceList>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   REG_CLS_MTD( LWinDeviceList,AfterConstruction )
   REG_CLS_MTD( LWinDeviceList,ReenumerateDevices )
   REG_CLS_MTD( LWinDeviceList,SetWindowHandle )
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iInputDeviceList" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/Input/NetDevices.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: iInputDevice
            // Adding abstract: GetName
            // Adding abstract: Poll
            // Adding abstract: Start
            // Adding abstract: IsStarted
            // Adding abstract: Stop
            // Adding abstract: GetNumAxes
            // Adding abstract: SetAxisRange
            // Adding abstract: SetAxisDeadZone
            // Adding abstract: SetAxisSaturation
            // Adding abstract: GetAxisValue
            // Adding abstract: GetAxisName
            // Adding abstract: SetAxisValue
            // Adding abstract: GetKeyName
            // Adding abstract: IsPressed
            // Adding abstract: GetNumKeys
            // Adding abstract: SetKeyState
         // Class: NetDeviceClient
            // Overriding abstract: GetNumAxes
            // Overriding abstract: SetAxisRange
            // Overriding abstract: SetAxisDeadZone
            // Overriding abstract: SetAxisSaturation
            // Overriding abstract: GetAxisValue
            // Overriding abstract: GetAxisName
            // Overriding abstract: SetAxisValue
            // Overriding abstract: GetKeyName
            // Overriding abstract: IsPressed
            // Overriding abstract: GetNumKeys
            // Overriding abstract: SetKeyState
            // Overriding abstract: Start
            // Overriding abstract: IsStarted
            // Overriding abstract: Stop
            // Overriding abstract: GetName
            // Overriding abstract: Poll

void RegisterPackageLinderdaumCoreClass19(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<NetDeviceClient>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(NetDeviceClient,Mtd)
   _RM__(ConnectTo)
   _RM__(Disconnect)
   _RM__(ProcessDeviceInfoPacket)
   _RM__(PollSockets)
   _RM__(GetNumAxes)
   _RM__(SetAxisRange)
   _RM__(SetAxisDeadZone)
   _RM__(SetAxisSaturation)
   _RM__(GetAxisValue)
   _RM__(GetAxisName)
   _RM__(SetAxisValue)
   _RM__(GetKeyName)
   _RM__(IsPressed)
   _RM__(GetNumKeys)
   _RM__(SetKeyState)
   _RM__(Start)
   _RM__(IsStarted)
   _RM__(Stop)
   _RM__(RunSystemSetup)
   _RM__(SystemSetupAvailable)
   _RM__(GetName)
   _RM__(Poll)
   #undef _RM__
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iInputDevice" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: NetDeviceServer

void RegisterPackageLinderdaumCoreClass20(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<NetDeviceServer>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(NetDeviceServer,Mtd)
   _RM__(ProcessClients)
   _RM__(SetDevice)
   _RM__(Stop)
   _RM__(Start)
   _RM__(PollSockets)
   #undef _RM__
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/Scene/Particles/GPUParticles.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: Particles
// SCALAR_PROPERTY_LOAD__FIELD
// Gravity
// FGravity
// Particles
// FGravity
// LStr::ToFloat

bool LoadScalarField_Particles_FGravity_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<Particles*>(Obj))->FGravity=LStr::ToFloat( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// Gravity
// FGravity
// Particles
// FGravity
// LStr::ToStrEpsilon

bool SaveScalarField_Particles_FGravity_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<Particles*>(Obj)->FGravity); 
   *Result = new mlNode("Gravity" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// TimeStep
// FTimeStep
// Particles
// FTimeStep
// LStr::ToFloat

bool LoadScalarField_Particles_FTimeStep_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<Particles*>(Obj))->FTimeStep=LStr::ToFloat( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// TimeStep
// FTimeStep
// Particles
// FTimeStep
// LStr::ToStrEpsilon

bool SaveScalarField_Particles_FTimeStep_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<Particles*>(Obj)->FTimeStep); 
   *Result = new mlNode("TimeStep" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// MaxLifeTime
// FMaxLifeTime
// Particles
// FMaxLifeTime
// LStr::ToFloat

bool LoadScalarField_Particles_FMaxLifeTime_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<Particles*>(Obj))->FMaxLifeTime=LStr::ToFloat( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// MaxLifeTime
// FMaxLifeTime
// Particles
// FMaxLifeTime
// LStr::ToStrEpsilon

bool SaveScalarField_Particles_FMaxLifeTime_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<Particles*>(Obj)->FMaxLifeTime); 
   *Result = new mlNode("MaxLifeTime" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// MinPosition
// FMinPosition
// Particles
// FMinPosition
// LStr::StrToVec3

bool LoadScalarField_Particles_FMinPosition_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<Particles*>(Obj))->FMinPosition=LStr::StrToVec3( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// MinPosition
// FMinPosition
// Particles
// FMinPosition
// LStr::Vec3ToStr

bool SaveScalarField_Particles_FMinPosition_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::Vec3ToStr(dynamic_cast<Particles*>(Obj)->FMinPosition); 
   *Result = new mlNode("MinPosition" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// MaxPosition
// FMaxPosition
// Particles
// FMaxPosition
// LStr::StrToVec3

bool LoadScalarField_Particles_FMaxPosition_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<Particles*>(Obj))->FMaxPosition=LStr::StrToVec3( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// MaxPosition
// FMaxPosition
// Particles
// FMaxPosition
// LStr::Vec3ToStr

bool SaveScalarField_Particles_FMaxPosition_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::Vec3ToStr(dynamic_cast<Particles*>(Obj)->FMaxPosition); 
   *Result = new mlNode("MaxPosition" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// MinVelocity
// FMinVelocity
// Particles
// FMinVelocity
// LStr::StrToVec3

bool LoadScalarField_Particles_FMinVelocity_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<Particles*>(Obj))->FMinVelocity=LStr::StrToVec3( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// MinVelocity
// FMinVelocity
// Particles
// FMinVelocity
// LStr::Vec3ToStr

bool SaveScalarField_Particles_FMinVelocity_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::Vec3ToStr(dynamic_cast<Particles*>(Obj)->FMinVelocity); 
   *Result = new mlNode("MinVelocity" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// MaxVelocity
// FMaxVelocity
// Particles
// FMaxVelocity
// LStr::StrToVec3

bool LoadScalarField_Particles_FMaxVelocity_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<Particles*>(Obj))->FMaxVelocity=LStr::StrToVec3( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// MaxVelocity
// FMaxVelocity
// Particles
// FMaxVelocity
// LStr::Vec3ToStr

bool SaveScalarField_Particles_FMaxVelocity_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::Vec3ToStr(dynamic_cast<Particles*>(Obj)->FMaxVelocity); 
   *Result = new mlNode("MaxVelocity" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// ParticleSize
// FParticleSize
// Particles
// FParticleSize
// LStr::ToFloat

bool LoadScalarField_Particles_FParticleSize_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<Particles*>(Obj))->FParticleSize=LStr::ToFloat( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// ParticleSize
// FParticleSize
// Particles
// FParticleSize
// LStr::ToStrEpsilon

bool SaveScalarField_Particles_FParticleSize_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<Particles*>(Obj)->FParticleSize); 
   *Result = new mlNode("ParticleSize" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// ParticleColor
// FParticleColor
// Particles
// FParticleColor
// LStr::StrToVec4

bool LoadScalarField_Particles_FParticleColor_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<Particles*>(Obj))->FParticleColor=LStr::StrToVec4( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// ParticleColor
// FParticleColor
// Particles
// FParticleColor
// LStr::Vec4ToStr

bool SaveScalarField_Particles_FParticleColor_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::Vec4ToStr(dynamic_cast<Particles*>(Obj)->FParticleColor); 
   *Result = new mlNode("ParticleColor" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}




void RegisterPackageLinderdaumCoreClass21(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<Particles>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(Particles,Mtd)
   _RM__(InitBuffersAndShaders)
   _RM__(DestroyBuffersAndShaders)
   _RM__(UpdateDynamics)
   _RM__(ResetDynamics)
   _RM__(UpdateUniforms)
   _RM__(AddToScene)
   _RM__(RemoveFromScene)
   _RM__(DebugRenderWithShader)
   _RM__(MakeExplosion)
   _RM__(GetColorShader)
   #undef _RM__
#endif // _DISABLE_METHODS_
   REGISTER_PROPERTY__SCALAR_FIELD(FGravity, Particles, Gravity)

   REGISTER_PROPERTY__SCALAR_FIELD(FTimeStep, Particles, TimeStep)

   REGISTER_PROPERTY__SCALAR_FIELD(FMaxLifeTime, Particles, MaxLifeTime)

   REGISTER_PROPERTY__SCALAR_FIELD(FMinPosition, Particles, MinPosition)

   REGISTER_PROPERTY__SCALAR_FIELD(FMaxPosition, Particles, MaxPosition)

   REGISTER_PROPERTY__SCALAR_FIELD(FMinVelocity, Particles, MinVelocity)

   REGISTER_PROPERTY__SCALAR_FIELD(FMaxVelocity, Particles, MaxVelocity)

   REGISTER_PROPERTY__SCALAR_FIELD(FParticleSize, Particles, ParticleSize)

   REGISTER_PROPERTY__SCALAR_FIELD(FParticleColor, Particles, ParticleColor)

   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "RigidBodyController_Tunneller.h"

#include "Linderdaum/Physics/BodyControllers.h"

void RegisterPackageLinderdaumCoreClass22(sEnvironment* Env)
{
#if !defined(_DISABLE_TUNNELLERS_)
   iStaticClass* StaticClass = new clNativeStaticClass<RigidBodyController_Tunneller>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(RigidBodyController,Mtd)
   _RM__(Reset)
   _RM__(Update)
   _RM__(ApplyToBody)
   _RM__(SetInputDevice)
   #undef _RM__
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
#endif // _DISABLE_TUNNELLERS_
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: RigidBodyController

void RegisterPackageLinderdaumCoreClass23(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<RigidBodyController>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(RigidBodyController,Mtd)
   _RM__(Reset)
   _RM__(Update)
   _RM__(ApplyToBody)
   _RM__(SetInputDevice)
   #undef _RM__
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: RigidBodyController
         // Class: RigidBodyController_MoveTo

void RegisterPackageLinderdaumCoreClass24(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<RigidBodyController_MoveTo>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   REG_CLS_MTD( RigidBodyController_MoveTo,Update )
   REG_CLS_MTD( RigidBodyController_MoveTo,ApplyToBody )
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "RigidBodyController" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: RigidBodyController
         // Class: RigidBodyController_Walk

void RegisterPackageLinderdaumCoreClass25(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<RigidBodyController_Walk>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   REG_CLS_MTD( RigidBodyController_Walk,Update )
   REG_CLS_MTD( RigidBodyController_Walk,ApplyToBody )
   REG_CLS_MTD( RigidBodyController_Walk,DebugRender )
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "RigidBodyController" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/Physics/SimplePhysics.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: SimplePhysics
// OBJECT_ARRAY_PROPERTY_LOAD__FIELD
// Bodies
// FBodies
// SimplePhysics
// clRigidBody

bool LoadObjectItem_SimplePhysics_FBodies_FIELD(mlNode* Node, iObject* Obj, int i) 
{
   FIX_PARSER_DEFECT(RealNode, Node->children[i]) 
  clRigidBody* Ptr = NULL; 
   bool Res = Obj->Env->Linker->LoadObject(RealNode, reinterpret_cast<iObject**>(&Ptr)); 
  SimplePhysics* CastedObj = dynamic_cast<SimplePhysics*>(Obj); 
   if ( Res ) CastedObj->FBodies[i] = Ptr; 
   return Res; 
}

// OBJECT_ARRAY_PROPERTY_SAVE__FIELD
// Bodies
// FBodies
// SimplePhysics

bool SaveObjectItem_SimplePhysics_FBodies_FIELD(iObject* Obj, int i, mlNode** Result) 
{
   return (dynamic_cast<SimplePhysics*>(Obj)->FBodies[i])->Save(Result);
}


// ARRAY_PROPERTY_FUNCTIONS__FIELD
// FBodies
// SimplePhysics

   ARRAY_PROPERTY_RESIZE_FUNCTION__FIELD(FBodies,SimplePhysics) 
   ARRAY_PROPERTY_SIZE_FUNCTION__FIELD(FBodies,SimplePhysics) 
   ARRAY_PROPERTY_CLEAR_FUNCTION__FIELD(FBodies,SimplePhysics)


// ARRAY_PROPERTY_DELETE_FUNCTION__FIELD
// FBodies
// SimplePhysics

void DeleteFunction_SimplePhysics_FBodies_FIELD(iObject* Obj, int Resize) 
{ 
   int Size = SizeFunction_SimplePhysics_FBodies_FIELD(Obj); 
   for (int i = 0 ; i < Size ; i++) 
   { 
      dynamic_cast<SimplePhysics*>(Obj)->FBodies[i] ->DisposeObject(); 
   }
   dynamic_cast<SimplePhysics*>(Obj)->FBodies.clear(); 
}





void RegisterPackageLinderdaumCoreClass26(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<SimplePhysics>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(SimplePhysics,Mtd)
   _RM__(AfterConstruction)
   _RM__(Update)
   _RM__(UpdateOnlyBodies)
   _RM__(CheckForCollisions)
   _RM__(ResolveCollisions)
   _RM__(DebugRender)
   _RM__(AddBody)
   _RM__(RemoveBody)
   _RM__(Clear)
   _RM__(GetBody)
   _RM__(SetBody)
   _RM__(GetNumBodies)
   _RM__(CreateSolidSphere)
   _RM__(CreateHollowSphere)
   _RM__(CreateSolidCuboid)
   _RM__(CreateCylinderXY)
   _RM__(CreatePlane)
   #undef _RM__
#endif // _DISABLE_METHODS_
   REGISTER_PROPERTY__OBJECT_ARRAY_FIELD(FBodies, SimplePhysics, Bodies)

   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/Geometry/ASE.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: iMeshLoader
            // Adding abstract: LoadMesh
         // Class: clASELoader
            // Overriding abstract: LoadMesh

void RegisterPackageLinderdaumCoreClass27(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clASELoader>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   REG_CLS_MTD( clASELoader,LoadMesh )
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iMeshLoader" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/Scene/Postprocess/ASSAO.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: iPostprocessor
            // Adding abstract: Render
         // Class: clASSAOPostprocessor
            // Overriding abstract: Render

void RegisterPackageLinderdaumCoreClass28(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clASSAOPostprocessor>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   REG_CLS_MTD( clASSAOPostprocessor,AfterConstruction )
   REG_CLS_MTD( clASSAOPostprocessor,Render )
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iPostprocessor" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/Core/VFS/MountPoint.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: iMountPoint
            // Adding abstract: FileExistsAtThisPoint
            // Adding abstract: MapToThisPoint
            // Adding abstract: CreateRAWFile
            // Adding abstract: GetFileTime
         // Class: clAliasMountPoint
            // Overriding abstract: FileExistsAtThisPoint
            // Overriding abstract: MapToThisPoint
            // Overriding abstract: CreateRAWFile
            // Overriding abstract: GetFileTime

void RegisterPackageLinderdaumCoreClass29(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass1<clAliasMountPoint, iMountPoint*>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clAliasMountPoint,Mtd)
   _RM__(SetAlias)
   _RM__(GetAlias)
   _RM__(FileExistsAtThisPoint)
   _RM__(MapToThisPoint)
   _RM__(CreateRAWFile)
   _RM__(GetFileTime)
   _RM__(IsPhysical)
   #undef _RM__
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iMountPoint" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/Geometry/Animation.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clAnimSet

void RegisterPackageLinderdaumCoreClass30(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clAnimSet>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clAnimSet,Mtd)
   _RM__(AddAnimSequence)
   _RM__(GetAnimSequenceByName)
   _RM__(GetAnimSequence)
   _RM__(GetAnimSequenceName)
   _RM__(GetAnimSequenceParams)
   _RM__(GetNumAnimSequences)
   _RM__(LoadAnimSet)
   #undef _RM__
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: iResource
            // Adding abstract: GetCachingDir
         // Class: clAnimation
            // Overriding abstract: GetCachingDir

void RegisterPackageLinderdaumCoreClass31(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clAnimation>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clAnimation,Mtd)
   _RM__(AfterConstruction)
   _RM__(GetCachingDir)
   _RM__(CacheTo)
   _RM__(CacheFrom)
   _RM__(GetCurrentAnimSet)
   _RM__(GetDefaultAnimSet)
   _RM__(SetAnimSet)
   _RM__(CloneAnimation)
   #undef _RM__
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iResource" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/Scene/iUpdater.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: iUpdater
            // Adding abstract: Update
         // Class: clAnimationUpdater
            // Overriding abstract: Update

void RegisterPackageLinderdaumCoreClass32(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clAnimationUpdater>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   REG_CLS_MTD( clAnimationUpdater,Update )
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iUpdater" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/Audio/Audio.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clAnnouncer

void RegisterPackageLinderdaumCoreClass33(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass2<clAnnouncer, const LString&, iAudioSource*>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   REG_CLS_MTD( clAnnouncer,AfterConstruction )
   REG_CLS_MTD( clAnnouncer,IsFinished )
   REG_CLS_MTD( clAnnouncer,GetSource )
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: iMountPoint
            // Adding abstract: FileExistsAtThisPoint
            // Adding abstract: MapToThisPoint
            // Adding abstract: CreateRAWFile
            // Adding abstract: GetFileTime
         // Class: clArchiveMountPoint
            // Overriding abstract: FileExistsAtThisPoint
            // Overriding abstract: MapToThisPoint
            // Overriding abstract: CreateRAWFile
            // Overriding abstract: GetFileTime

void RegisterPackageLinderdaumCoreClass34(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass2<clArchiveMountPoint, sEnvironment*, const LString&>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clArchiveMountPoint,Mtd)
   _RM__(FileExistsAtThisPoint)
   _RM__(MapToThisPoint)
   _RM__(CreateRAWFile)
   _RM__(GetFileTime)
   _RM__(IsPhysical)
   #undef _RM__
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iMountPoint" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/Core/VFS/Archive.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clArchiveReader

void RegisterPackageLinderdaumCoreClass35(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clArchiveReader>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clArchiveReader,Mtd)
   _RM__(OpenArchive)
   _RM__(OpenArchiveFile)
   _RM__(ExtractSingleFile)
   _RM__(CloseArchive)
   _RM__(FileExists)
   _RM__(GetFileSize)
   _RM__(GetFileTime)
   _RM__(GetFileIdx)
   _RM__(GetNumFiles)
   _RM__(GetFileName)
   #undef _RM__
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/Audio/Audio_FMOD.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: iAudioSource
         // Class: clAudioSource_FMOD

void RegisterPackageLinderdaumCoreClass36(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clAudioSource_FMOD>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clAudioSource_FMOD,Mtd)
   _RM__(Play)
   _RM__(Stop)
   _RM__(Pause)
   _RM__(LoopSound)
   _RM__(IsPlaying)
   _RM__(BindWaveform)
   _RM__(SetSystem)
   #undef _RM__
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iAudioSource" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/Audio/Audio_OpenAL.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: iAudioSource
         // Class: clAudioSource_OpenAL

void RegisterPackageLinderdaumCoreClass37(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clAudioSource_OpenAL>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clAudioSource_OpenAL,Mtd)
   _RM__(AfterConstruction)
   _RM__(Play)
   _RM__(Stop)
   _RM__(Pause)
   _RM__(LoopSound)
   _RM__(IsPlaying)
   _RM__(Update)
   _RM__(SetPosition)
   _RM__(SetVelocity)
   _RM__(SetDirection)
   _RM__(SetVolume)
   _RM__(SetVolumeNoFade)
   _RM__(SetPitch)
   _RM__(BindWaveform)
   #undef _RM__
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iAudioSource" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: iAudioSubSystem
         // Class: clAudioSubSystem_FMOD

void RegisterPackageLinderdaumCoreClass38(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clAudioSubSystem_FMOD>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   REG_CLS_MTD( clAudioSubSystem_FMOD,AfterConstruction )
   REG_CLS_MTD( clAudioSubSystem_FMOD,CreateSourceFromFile )
   REG_CLS_MTD( clAudioSubSystem_FMOD,CreateSource )
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iAudioSubSystem" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: iAudioSubSystem
         // Class: clAudioSubSystem_OpenAL

void RegisterPackageLinderdaumCoreClass39(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clAudioSubSystem_OpenAL>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clAudioSubSystem_OpenAL,Mtd)
   _RM__(AfterConstruction)
   _RM__(CreateSourceFromFile)
   _RM__(CreateSource)
   _RM__(RegisterSource)
   _RM__(UnRegisterSource)
   _RM__(SetListenerPosition)
   _RM__(SetListenerVelocity)
   _RM__(SetListenerOrientation)
   _RM__(SetListenerVolume)
   _RM__(StopAll)
   _RM__(PauseAll)
   _RM__(ResumeAll)
   _RM__(ToggleAll)
   _RM__(IsActive)
   #undef _RM__
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iAudioSubSystem" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "clBehaviour_Tunneller.h"

#include "Linderdaum/World/AI/Behaviour.h"

void RegisterPackageLinderdaumCoreClass40(sEnvironment* Env)
{
#if !defined(_DISABLE_TUNNELLERS_)
   iStaticClass* StaticClass = new clNativeStaticClass<clBehaviour_Tunneller>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clBehaviour,Mtd)
   _RM__(DumpDotFile)
   _RM__(SetParent)
   _RM__(GetParent)
   _RM__(SetWeight)
   _RM__(GetWeight)
   _RM__(DumpDot)
   _RM__(Update)
   #undef _RM__
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
#endif // _DISABLE_TUNNELLERS_
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clBehaviour
// SCALAR_PROPERTY_LOAD__SETTER
// Weight
// ""
// clBehaviour
// SetWeight
// LStr::ToFloat

bool LoadScalarField_clBehaviour_Weight_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clBehaviour*>(Obj))->SetWeight(LStr::ToFloat( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Weight
// ""
// clBehaviour
// GetWeight
// LStr::ToStrEpsilon

bool SaveScalarField_clBehaviour_Weight_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<clBehaviour*>(Obj)->GetWeight() ); 
   *Result = new mlNode("Weight" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}




void RegisterPackageLinderdaumCoreClass41(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clBehaviour>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clBehaviour,Mtd)
   _RM__(DumpDotFile)
   _RM__(SetParent)
   _RM__(GetParent)
   _RM__(SetWeight)
   _RM__(GetWeight)
   _RM__(DumpDot)
   _RM__(Update)
   #undef _RM__
#endif // _DISABLE_METHODS_
   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Weight, clBehaviour, Weight)

   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/Images/Bitmap.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clBitmap

void RegisterPackageLinderdaumCoreClass42(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clBitmap>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clBitmap,Mtd)
   _RM__(AfterConstruction)
   _RM__(IsEqual)
   _RM__(Load2DImage)
   _RM__(Load2DImageFromStream)
   _RM__(Load3DImage)
   _RM__(Load3D)
   _RM__(Load3DImageESL)
   _RM__(Load3DImageGradients)
   _RM__(LoadCubeImage)
   _RM__(Save2DImage)
   _RM__(Save3DImage)
   _RM__(RenderHistogram)
   _RM__(RenderIntensityHistogram)
   _RM__(RenderChannelHistogram)
   _RM__(MakeGlow2)
   _RM__(MakeNormalMap)
   _RM__(NoiseFill2)
   _RM__(NoiseFill3)
   _RM__(GenerateRandomVoronoiDiagram)
   _RM__(MakeXorPattern)
   _RM__(ApplyExposure)
   _RM__(MakeRainbowGradient)
   _RM__(FillColorSquare)
   _RM__(MakeWave2D)
   _RM__(MakeWave3D)
   _RM__(FillBox)
   _RM__(SolidTriangle)
   _RM__(NormalizeImage)
   _RM__(NormalizeImageAlloc)
   _RM__(LogNormalize)
   _RM__(LogNormalizeAlloc)
   _RM__(Linearize32BitZBuffer)
   _RM__(CalculateCentroid3D)
   _RM__(CalculateCovariance3D)
   _RM__(CalculateSecondMoments3D)
   _RM__(HoughTransform2D)
   _RM__(Substract)
   _RM__(DifferenceWith)
   _RM__(FlipVertical)
   _RM__(Rotate90CW)
   _RM__(Rotate90CCW)
   _RM__(Rotate180)
   _RM__(Convert_BGRAToRGBA)
   _RM__(ConvertToGrayscale8bit)
   _RM__(ToColorFromGrayscale)
   _RM__(FloatToRGBA8)
   _RM__(ExtractColorPlane8bit)
   _RM__(CopyColorPlane)
   _RM__(ScalePixelComponents)
   _RM__(Tangle2D)
   _RM__(Untangle2D)
   _RM__(CalculateComplexMagnitude)
   _RM__(CalculateComplexPhase)
   _RM__(PutBmp)
   _RM__(RescaleBitmap)
   _RM__(Tile3DImage)
   _RM__(SetPixel)
   _RM__(GetPixel)
   _RM__(SetPixelComponent)
   _RM__(GetPixelComponent)
   _RM__(DrawLine2D)
   _RM__(DrawLine3D)
   _RM__(HorizontalLine)
   _RM__(Clear)
   _RM__(BilinearInterpolate)
   _RM__(CreateEmptyBitmap)
   _RM__(CreateBitmap)
   _RM__(DisposeObject)
   _RM__(GetWidth)
   _RM__(GetHeight)
   _RM__(GetDepth)
   _RM__(GetBitsPerPixel)
   _RM__(IsCompressed)
   _RM__(GetTextureType)
   _RM__(GetBitmapFormat)
   #undef _RM__
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/Input/ScreenJoystick.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clBitmapAxis
// SCALAR_PROPERTY_LOAD__FIELD
// Position
// FPosition
// clBitmapAxis
// FPosition
// LStr::StrToVec2

bool LoadScalarField_clBitmapAxis_FPosition_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clBitmapAxis*>(Obj))->FPosition=LStr::StrToVec2( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// Position
// FPosition
// clBitmapAxis
// FPosition
// LStr::Vec2ToStr

bool SaveScalarField_clBitmapAxis_FPosition_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::Vec2ToStr(dynamic_cast<clBitmapAxis*>(Obj)->FPosition); 
   *Result = new mlNode("Position" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// Radius
// FRadius
// clBitmapAxis
// FRadius
// LStr::ToFloat

bool LoadScalarField_clBitmapAxis_FRadius_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clBitmapAxis*>(Obj))->FRadius=LStr::ToFloat( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// Radius
// FRadius
// clBitmapAxis
// FRadius
// LStr::ToStrEpsilon

bool SaveScalarField_clBitmapAxis_FRadius_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<clBitmapAxis*>(Obj)->FRadius); 
   *Result = new mlNode("Radius" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// Axis1
// FAxis1
// clBitmapAxis
// FAxis1
// LStr::ToInt

bool LoadScalarField_clBitmapAxis_FAxis1_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clBitmapAxis*>(Obj))->FAxis1=LStr::ToInt( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// Axis1
// FAxis1
// clBitmapAxis
// FAxis1
// LStr::ToStr

bool SaveScalarField_clBitmapAxis_FAxis1_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStr(dynamic_cast<clBitmapAxis*>(Obj)->FAxis1); 
   *Result = new mlNode("Axis1" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// Axis2
// FAxis2
// clBitmapAxis
// FAxis2
// LStr::ToInt

bool LoadScalarField_clBitmapAxis_FAxis2_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clBitmapAxis*>(Obj))->FAxis2=LStr::ToInt( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// Axis2
// FAxis2
// clBitmapAxis
// FAxis2
// LStr::ToStr

bool SaveScalarField_clBitmapAxis_FAxis2_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStr(dynamic_cast<clBitmapAxis*>(Obj)->FAxis2); 
   *Result = new mlNode("Axis2" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// Color
// FColor
// clBitmapAxis
// FColor
// LStr::StrToVec4

bool LoadScalarField_clBitmapAxis_FColor_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clBitmapAxis*>(Obj))->FColor=LStr::StrToVec4( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// Color
// FColor
// clBitmapAxis
// FColor
// LStr::Vec4ToStr

bool SaveScalarField_clBitmapAxis_FColor_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::Vec4ToStr(dynamic_cast<clBitmapAxis*>(Obj)->FColor); 
   *Result = new mlNode("Color" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}




void RegisterPackageLinderdaumCoreClass43(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clBitmapAxis>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   REG_CLS_MTD( clBitmapAxis,HasAxis )
#endif // _DISABLE_METHODS_
   REGISTER_PROPERTY__SCALAR_FIELD(FPosition, clBitmapAxis, Position)

   REGISTER_PROPERTY__SCALAR_FIELD(FRadius, clBitmapAxis, Radius)

   REGISTER_PROPERTY__SCALAR_FIELD(FAxis1, clBitmapAxis, Axis1)

   REGISTER_PROPERTY__SCALAR_FIELD(FAxis2, clBitmapAxis, Axis2)

   REGISTER_PROPERTY__SCALAR_FIELD(FColor, clBitmapAxis, Color)

   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clBitmapButton
// SCALAR_PROPERTY_LOAD__FIELD
// Color
// FColor
// clBitmapButton
// FColor
// LStr::StrToVec4

bool LoadScalarField_clBitmapButton_FColor_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clBitmapButton*>(Obj))->FColor=LStr::StrToVec4( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// Color
// FColor
// clBitmapButton
// FColor
// LStr::Vec4ToStr

bool SaveScalarField_clBitmapButton_FColor_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::Vec4ToStr(dynamic_cast<clBitmapButton*>(Obj)->FColor); 
   *Result = new mlNode("Color" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// Index
// FIndex
// clBitmapButton
// FIndex
// LStr::ToInt

bool LoadScalarField_clBitmapButton_FIndex_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clBitmapButton*>(Obj))->FIndex=LStr::ToInt( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// Index
// FIndex
// clBitmapButton
// FIndex
// LStr::ToStr

bool SaveScalarField_clBitmapButton_FIndex_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStr(dynamic_cast<clBitmapButton*>(Obj)->FIndex); 
   *Result = new mlNode("Index" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}




void RegisterPackageLinderdaumCoreClass44(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clBitmapButton>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
#endif // _DISABLE_METHODS_
   REGISTER_PROPERTY__SCALAR_FIELD(FColor, clBitmapButton, Color)

   REGISTER_PROPERTY__SCALAR_FIELD(FIndex, clBitmapButton, Index)

   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/Utils/LBlob.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clBlob

void RegisterPackageLinderdaumCoreClass45(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clBlob>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clBlob,Mtd)
   _RM__(AfterConstruction)
   _RM__(SetSize)
   _RM__(GetSize)
   _RM__(OwnsData)
   _RM__(SetOwnership)
   _RM__(CopyBlob)
   _RM__(HasData)
   _RM__(CompareContents)
   _RM__(SetByte)
   _RM__(GetByte)
   _RM__(CopyFrom)
   _RM__(SafeResize)
   #undef _RM__
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/Renderer/CL/CLContext.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: iGPUBuffer
            // Adding abstract: CreateBuffer
            // Adding abstract: ReadBuffer
            // Adding abstract: BufferData
            // Adding abstract: BufferSubData
         // Class: clCLBuffer
            // Overriding abstract: CreateBuffer
            // Overriding abstract: ReadBuffer
            // Overriding abstract: BufferData
            // Overriding abstract: BufferSubData

void RegisterPackageLinderdaumCoreClass46(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clCLBuffer>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clCLBuffer,Mtd)
   _RM__(CreateBuffer)
   _RM__(ReadBuffer)
   _RM__(BufferData)
   _RM__(BufferSubData)
   _RM__(SetContext)
   _RM__(GetBufferID)
   _RM__(GetBufferIDPtr)
   #undef _RM__
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iGPUBuffer" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: iGPGPUContext
            // Adding abstract: InitContext
            // Adding abstract: CheckError
         // Class: clCLContext
            // Overriding abstract: InitContext
            // Overriding abstract: CheckError

void RegisterPackageLinderdaumCoreClass47(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clCLContext>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clCLContext,Mtd)
   _RM__(InitContext)
   _RM__(CheckError)
   _RM__(CreateBuffer)
   _RM__(CreateProgramWithSource)
   _RM__(GetDeviceContext)
   _RM__(GetCommandQueue)
   _RM__(GetLastErrorPtr)
   #undef _RM__
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iGPGPUContext" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clCLKernel

void RegisterPackageLinderdaumCoreClass48(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clCLKernel>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   REG_CLS_MTD( clCLKernel,SetArgBuffer )
   REG_CLS_MTD( clCLKernel,SetProgram )
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clCLProgram

void RegisterPackageLinderdaumCoreClass49(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clCLProgram>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clCLProgram,Mtd)
   _RM__(SetSource)
   _RM__(CreateKernel)
   _RM__(SetContext)
   _RM__(GetProgramID)
   #undef _RM__
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/Core/CVars.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clCVar
// SCALAR_PROPERTY_LOAD__SETTER
// Vec3
// ""
// clCVar
// SetVector3
// LStr::StrToVec3

bool LoadScalarField_clCVar_Vec3_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clCVar*>(Obj))->SetVector3(LStr::StrToVec3( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Vec3
// ""
// clCVar
// GetVector3
// LStr::Vec3ToStr

bool SaveScalarField_clCVar_Vec3_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::Vec3ToStr(dynamic_cast<clCVar*>(Obj)->GetVector3() ); 
   *Result = new mlNode("Vec3" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// Vec4
// ""
// clCVar
// SetVector4
// LStr::StrToVec4

bool LoadScalarField_clCVar_Vec4_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clCVar*>(Obj))->SetVector4(LStr::StrToVec4( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Vec4
// ""
// clCVar
// GetVector4
// LStr::Vec4ToStr

bool SaveScalarField_clCVar_Vec4_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::Vec4ToStr(dynamic_cast<clCVar*>(Obj)->GetVector4() ); 
   *Result = new mlNode("Vec4" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// Mtx3
// ""
// clCVar
// SetMatrix3
// LStr::StrToMtx3

bool LoadScalarField_clCVar_Mtx3_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clCVar*>(Obj))->SetMatrix3(LStr::StrToMtx3( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Mtx3
// ""
// clCVar
// GetMatrix3
// LStr::Mat3ToStr

bool SaveScalarField_clCVar_Mtx3_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::Mat3ToStr(dynamic_cast<clCVar*>(Obj)->GetMatrix3() ); 
   *Result = new mlNode("Mtx3" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// Mtx4
// ""
// clCVar
// SetMatrix4
// LStr::StrToMtx4

bool LoadScalarField_clCVar_Mtx4_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clCVar*>(Obj))->SetMatrix4(LStr::StrToMtx4( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Mtx4
// ""
// clCVar
// GetMatrix4
// LStr::Mat4ToStr

bool SaveScalarField_clCVar_Mtx4_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::Mat4ToStr(dynamic_cast<clCVar*>(Obj)->GetMatrix4() ); 
   *Result = new mlNode("Mtx4" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// Value
// ""
// clCVar
// SetString
// EMPTY_CONVERTER

bool LoadScalarField_clCVar_Value_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clCVar*>(Obj))->SetString(EMPTY_CONVERTER( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Value
// ""
// clCVar
// GetString
// EMPTY_CONVERTER

bool SaveScalarField_clCVar_Value_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =EMPTY_CONVERTER(dynamic_cast<clCVar*>(Obj)->GetString() ); 
   *Result = new mlNode("Value" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// Flt
// ""
// clCVar
// SetFloat
// LStr::ToFloat

bool LoadScalarField_clCVar_Flt_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clCVar*>(Obj))->SetFloat(LStr::ToFloat( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Flt
// ""
// clCVar
// GetFloat
// LStr::ToStrEpsilon

bool SaveScalarField_clCVar_Flt_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<clCVar*>(Obj)->GetFloat() ); 
   *Result = new mlNode("Flt" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// Dbl
// ""
// clCVar
// SetDouble
// LStr::ToDouble

bool LoadScalarField_clCVar_Dbl_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clCVar*>(Obj))->SetDouble(LStr::ToDouble( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Dbl
// ""
// clCVar
// GetDouble
// LStr::ToStrEpsilon

bool SaveScalarField_clCVar_Dbl_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<clCVar*>(Obj)->GetDouble() ); 
   *Result = new mlNode("Dbl" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// Int
// ""
// clCVar
// SetInt
// LStr::ToInt

bool LoadScalarField_clCVar_Int_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clCVar*>(Obj))->SetInt(LStr::ToInt( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Int
// ""
// clCVar
// GetInt
// LStr::ToStr

bool SaveScalarField_clCVar_Int_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::ToStr(dynamic_cast<clCVar*>(Obj)->GetInt() ); 
   *Result = new mlNode("Int" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}




void RegisterPackageLinderdaumCoreClass50(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clCVar>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clCVar,Mtd)
   _RM__(GetString)
   _RM__(GetInt)
   _RM__(GetDouble)
   _RM__(GetFloat)
   _RM__(GetBool)
   _RM__(GetVector2)
   _RM__(GetVector3)
   _RM__(GetVector4)
   _RM__(GetMatrix3)
   _RM__(GetMatrix4)
   _RM__(SetString)
   _RM__(SetInt)
   _RM__(SetDouble)
   _RM__(SetFloat)
   _RM__(SetBool)
   _RM__(SetVector2)
   _RM__(SetVector3)
   _RM__(SetVector4)
   _RM__(SetMatrix3)
   _RM__(SetMatrix4)
   _RM__(AddInt)
   #undef _RM__
#endif // _DISABLE_METHODS_
   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Vec3, clCVar, Vec3)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Vec4, clCVar, Vec4)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Mtx3, clCVar, Mtx3)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Mtx4, clCVar, Mtx4)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Value, clCVar, Value)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Flt, clCVar, Flt)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Dbl, clCVar, Dbl)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Int, clCVar, Int)

   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#undef REG_CLS_MTD

/*
 * 16/01/2012
     Autogenerated via LinderScript Database Compiler 0.9.24
*/
