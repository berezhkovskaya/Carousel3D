/**
 * \file ExpReg_Core5.cpp
 * \brief Autogenerated via LinderScript Database Compiler 0.9.24
 * \version 0.6.06
 * \date 16/01/2012
 * \author Sergey Kosarevsky, 2005-2011
 * \author Viktor Latypov, 2007-2011
 * \author support@linderdaum.com http://www.linderdaum.com
 */

#include "Generated/MethodBind.h"

#include "Core/Linker.h"
#include "Core/RTTI/iStaticClass.h"
#include "Core/RTTI/FieldBinding.h"
#include "Core/RTTI/PropertyMacros.h"

#include "Core/VFS/ML.h"

// Custom include file
#include "Generated/CoreExport_Includes.h"

#define REG_CLS_MTD(ClsName, MtdName) \
StaticClass->RegisterMethod( BindNativeMethod( & ClsName :: MtdName, #MtdName ) );

#include "clSelector_Tunneller.h"

void RegisterPackageLinderdaumCoreClass204(sEnvironment* Env)
{
#if !defined(_DISABLE_TUNNELLERS_)
   iStaticClass* StaticClass = new clNativeStaticClass<clSelector_Tunneller>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clSelector,Mtd)
   _RM__(Restart)
   _RM__(SelectNext)
   _RM__(DumpDot)
   _RM__(Update)
   _RM__(GetCurrentBehaviour)
   _RM__(SetCurrentBehaviour)
   #undef _RM__
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "clCompositeBehaviour" );

   Env->Linker->RegisterStaticClass( StaticClass );
#endif // _DISABLE_TUNNELLERS_
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clBehaviour
         // Class: clCompositeBehaviour
         // Class: clSelector
// SCALAR_PROPERTY_LOAD__SETTER
// CurrentBehaviour
// ""
// clSelector
// SetCurrentBehaviour
// LStr::ToInt

bool LoadScalarField_clSelector_CurrentBehaviour_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clSelector*>(Obj))->SetCurrentBehaviour(LStr::ToInt( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// CurrentBehaviour
// ""
// clSelector
// GetCurrentBehaviour
// LStr::ToStr

bool SaveScalarField_clSelector_CurrentBehaviour_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::ToStr(dynamic_cast<clSelector*>(Obj)->GetCurrentBehaviour() ); 
   *Result = new mlNode("CurrentBehaviour" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}




void RegisterPackageLinderdaumCoreClass205(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clSelector>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clSelector,Mtd)
   _RM__(Restart)
   _RM__(SelectNext)
   _RM__(DumpDot)
   _RM__(Update)
   _RM__(GetCurrentBehaviour)
   _RM__(SetCurrentBehaviour)
   #undef _RM__
#endif // _DISABLE_METHODS_
   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(CurrentBehaviour, clSelector, CurrentBehaviour)

   StaticClass->SetSuperClassName( "clCompositeBehaviour" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "clSequence_Tunneller.h"

void RegisterPackageLinderdaumCoreClass206(sEnvironment* Env)
{
#if !defined(_DISABLE_TUNNELLERS_)
   iStaticClass* StaticClass = new clNativeStaticClass<clSequence_Tunneller>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   REG_CLS_MTD( clSequence,DumpDot )
   REG_CLS_MTD( clSequence,SelectNext )
   REG_CLS_MTD( clSequence,Update )
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "clSelector" );

   Env->Linker->RegisterStaticClass( StaticClass );
#endif // _DISABLE_TUNNELLERS_
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clBehaviour
         // Class: clCompositeBehaviour
         // Class: clSelector
         // Class: clSequence

void RegisterPackageLinderdaumCoreClass207(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clSequence>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   REG_CLS_MTD( clSequence,DumpDot )
   REG_CLS_MTD( clSequence,SelectNext )
   REG_CLS_MTD( clSequence,Update )
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "clSelector" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clUVSurfaceGenerator
            // Adding abstract: R_and_dR
         // Class: clSimplePlane
            // Overriding abstract: R_and_dR
// SCALAR_PROPERTY_LOAD__FIELD
// V1
// V1
// clSimplePlane
// V1
// LStr::StrToVec3

bool LoadScalarField_clSimplePlane_V1_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clSimplePlane*>(Obj))->V1=LStr::StrToVec3( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// V1
// V1
// clSimplePlane
// V1
// LStr::Vec3ToStr

bool SaveScalarField_clSimplePlane_V1_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::Vec3ToStr(dynamic_cast<clSimplePlane*>(Obj)->V1); 
   *Result = new mlNode("V1" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// V2
// V2
// clSimplePlane
// V2
// LStr::StrToVec3

bool LoadScalarField_clSimplePlane_V2_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clSimplePlane*>(Obj))->V2=LStr::StrToVec3( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// V2
// V2
// clSimplePlane
// V2
// LStr::Vec3ToStr

bool SaveScalarField_clSimplePlane_V2_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::Vec3ToStr(dynamic_cast<clSimplePlane*>(Obj)->V2); 
   *Result = new mlNode("V2" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// Origin
// P
// clSimplePlane
// P
// LStr::StrToVec3

bool LoadScalarField_clSimplePlane_P_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clSimplePlane*>(Obj))->P=LStr::StrToVec3( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// Origin
// P
// clSimplePlane
// P
// LStr::Vec3ToStr

bool SaveScalarField_clSimplePlane_P_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::Vec3ToStr(dynamic_cast<clSimplePlane*>(Obj)->P); 
   *Result = new mlNode("Origin" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}




void RegisterPackageLinderdaumCoreClass208(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clSimplePlane>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   REG_CLS_MTD( clSimplePlane,R_and_dR )
#endif // _DISABLE_METHODS_
   REGISTER_PROPERTY__SCALAR_FIELD(V1, clSimplePlane, V1)

   REGISTER_PROPERTY__SCALAR_FIELD(V2, clSimplePlane, V2)

   REGISTER_PROPERTY__SCALAR_FIELD(P, clSimplePlane, Origin)

   StaticClass->SetSuperClassName( "clUVSurfaceGenerator" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/Renderer/Soft/SoftFrameBuffer.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: iRenderTarget
            // Adding abstract: InitRenderTarget
            // Adding abstract: InitRenderTargetV
            // Adding abstract: GetColorTexture
            // Adding abstract: GetDepthTexture
            // Adding abstract: Bind
            // Adding abstract: BindReadFrom
            // Adding abstract: UnBind
            // Adding abstract: GetViewport
            // Adding abstract: UpdateWithProgram
            // Adding abstract: UpdateWithRenderState
         // Class: clSoftFrameBuffer
            // Overriding abstract: InitRenderTarget
            // Overriding abstract: InitRenderTargetV
            // Overriding abstract: GetColorTexture
            // Overriding abstract: GetDepthTexture
            // Overriding abstract: Bind
            // Overriding abstract: BindReadFrom
            // Overriding abstract: UnBind
            // Overriding abstract: GetViewport
            // Overriding abstract: UpdateWithProgram
            // Overriding abstract: UpdateWithRenderState

void RegisterPackageLinderdaumCoreClass209(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clSoftFrameBuffer>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clSoftFrameBuffer,Mtd)
   _RM__(InitRenderTarget)
   _RM__(InitRenderTargetV)
   _RM__(GetColorTexture)
   _RM__(GetDepthTexture)
   _RM__(Bind)
   _RM__(BindReadFrom)
   _RM__(UnBind)
   _RM__(GetViewport)
   _RM__(UpdateWithProgram)
   _RM__(UpdateWithRenderState)
   #undef _RM__
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iRenderTarget" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/Renderer/Soft/SoftRenderContext.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: iRenderContext
            // Adding abstract: GetPixel
            // Adding abstract: SetViewport
            // Adding abstract: SetViewportV
            // Adding abstract: RestoreViewport
            // Adding abstract: SetClearColor4v
            // Adding abstract: GetScreenshotSize
            // Adding abstract: GetScreenshot
            // Adding abstract: GetVideoSystemInfo
            // Adding abstract: GetTotalVideoMemory
            // Adding abstract: GetFreeVideoMemory
            // Adding abstract: CheckError
            // Adding abstract: ClearRenderTarget
            // Adding abstract: SetPolygonFillMode
            // Adding abstract: Finish
            // Adding abstract: SetState
            // Adding abstract: UpdateState
         // Class: clSoftRenderContext
            // Overriding abstract: GetPixel
            // Overriding abstract: SetViewport
            // Overriding abstract: SetViewportV
            // Overriding abstract: RestoreViewport
            // Overriding abstract: SetClearColor4v
            // Overriding abstract: GetScreenshotSize
            // Overriding abstract: GetScreenshot
            // Overriding abstract: GetVideoSystemInfo
            // Overriding abstract: GetTotalVideoMemory
            // Overriding abstract: GetFreeVideoMemory
            // Overriding abstract: CheckError
            // Overriding abstract: ClearRenderTarget
            // Overriding abstract: SetPolygonFillMode
            // Overriding abstract: Finish
            // Overriding abstract: SetState
            // Overriding abstract: UpdateState

void RegisterPackageLinderdaumCoreClass210(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clSoftRenderContext>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clSoftRenderContext,Mtd)
   _RM__(InitContext)
   _RM__(EndFrame)
   _RM__(GetPixel)
   _RM__(SetViewport)
   _RM__(SetViewportV)
   _RM__(RestoreViewport)
   _RM__(SetClearColor4v)
   _RM__(GetScreenshotSize)
   _RM__(GetScreenshot)
   _RM__(GetVideoSystemInfo)
   _RM__(GetTotalVideoMemory)
   _RM__(GetFreeVideoMemory)
   _RM__(CheckError)
   _RM__(AddBuffer)
   _RM__(ClearRenderTarget)
   _RM__(SetPolygonFillMode)
   _RM__(Finish)
   _RM__(SetState)
   _RM__(UpdateState)
   #undef _RM__
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iRenderContext" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/Renderer/Soft/SoftShaderProgram.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: iResource
            // Adding abstract: GetCachingDir
         // Class: iShaderProgram
            // Overriding abstract: GetCachingDir
            // Adding abstract: Bind
            // Adding abstract: UnBind
            // Adding abstract: BindUniforms
            // Adding abstract: CreateUniform
            // Adding abstract: SetUniformInt
            // Adding abstract: SetUniformIntArray
            // Adding abstract: SetUniformFloat
            // Adding abstract: SetUniformFloatArray
            // Adding abstract: SetUniformVec3Array
            // Adding abstract: SetUniformVec4Array
            // Adding abstract: SetUniformMat3Array
            // Adding abstract: SetUniformMat4Array
            // Adding abstract: SetUniformNameInt
            // Adding abstract: SetUniformNameIntArray
            // Adding abstract: SetUniformNameFloat
            // Adding abstract: SetUniformNameFloatArray
            // Adding abstract: SetUniformNameVec3Array
            // Adding abstract: SetUniformNameVec4Array
            // Adding abstract: SetUniformNameMat3Array
            // Adding abstract: SetUniformNameMat4Array
            // Adding abstract: SetTransformationUniforms
            // Adding abstract: SetMaterialUniforms
            // Adding abstract: SetGUIUniforms
            // Adding abstract: SetSceneUniformsPerRigid
            // Adding abstract: SetLightUniformsPerShader
            // Adding abstract: SetSceneUniformsPerShader
            // Adding abstract: SetFragDataLocationName
            // Adding abstract: SetAttribLocationName
            // Adding abstract: BindConsoleVariableType
            // Adding abstract: SetInputPrimitiveType
            // Adding abstract: SetOutputPrimitiveType
            // Adding abstract: SetOutputVerticesCount
            // Adding abstract: SetDefinesList
            // Adding abstract: GetDefinesList
         // Class: clSoftShaderProgram
            // Overriding abstract: Bind
            // Overriding abstract: UnBind
            // Overriding abstract: BindUniforms
            // Overriding abstract: CreateUniform
            // Overriding abstract: SetUniformFloat
            // Overriding abstract: SetUniformFloatArray
            // Overriding abstract: SetUniformVec3Array
            // Overriding abstract: SetUniformVec4Array
            // Overriding abstract: SetUniformMat3Array
            // Overriding abstract: SetUniformMat4Array
            // Overriding abstract: SetUniformNameFloat
            // Overriding abstract: SetUniformNameFloatArray
            // Overriding abstract: SetUniformNameVec3Array
            // Overriding abstract: SetUniformNameVec4Array
            // Overriding abstract: SetUniformNameMat3Array
            // Overriding abstract: SetUniformNameMat4Array
            // Overriding abstract: SetTransformationUniforms
            // Overriding abstract: SetMaterialUniforms
            // Overriding abstract: SetGUIUniforms
            // Overriding abstract: SetSceneUniformsPerRigid
            // Overriding abstract: SetSceneUniformsPerShader
            // Overriding abstract: SetFragDataLocationName
            // Overriding abstract: SetAttribLocationName
            // Overriding abstract: SetInputPrimitiveType
            // Overriding abstract: SetOutputPrimitiveType
            // Overriding abstract: SetOutputVerticesCount
            // Overriding abstract: SetDefinesList
            // Overriding abstract: GetDefinesList
      // Abstract method: SetUniformInt
      // Abstract method: SetUniformIntArray
      // Abstract method: SetUniformNameInt
      // Abstract method: SetUniformNameIntArray
      // Abstract method: SetLightUniformsPerShader
      // Abstract method: BindConsoleVariableType

void RegisterPackageLinderdaumCoreClass211(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeAbstractStaticClass<clSoftShaderProgram>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clSoftShaderProgram,Mtd)
   _RM__(IsSameResource)
   _RM__(RelinkShaderProgram)
   _RM__(Bind)
   _RM__(UnBind)
   _RM__(BindUniforms)
   _RM__(CreateUniform)
   _RM__(SetUniformFloat)
   _RM__(SetUniformFloatArray)
   _RM__(SetUniformVec3Array)
   _RM__(SetUniformVec4Array)
   _RM__(SetUniformMat3Array)
   _RM__(SetUniformMat4Array)
   _RM__(SetUniformNameFloat)
   _RM__(SetUniformNameFloatArray)
   _RM__(SetUniformNameVec3Array)
   _RM__(SetUniformNameVec4Array)
   _RM__(SetUniformNameMat3Array)
   _RM__(SetUniformNameMat4Array)
   _RM__(SetTransformationUniforms)
   _RM__(SetMaterialUniforms)
   _RM__(SetGUIUniforms)
   _RM__(SetSceneUniformsPerRigid)
   _RM__(SetSceneUniformsPerShader)
   _RM__(BindConsoleVariable)
   _RM__(SetFragDataLocationName)
   _RM__(SetAttribLocationName)
   _RM__(SetInputPrimitiveType)
   _RM__(SetOutputPrimitiveType)
   _RM__(SetOutputVerticesCount)
   _RM__(SetDefinesList)
   _RM__(GetDefinesList)
   #undef _RM__
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iShaderProgram" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/Renderer/Soft/SoftTexture.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: iTexture
            // Adding abstract: Bind
            // Adding abstract: SaveToBitmap
            // Adding abstract: LoadFromBitmap
            // Adding abstract: UpdateSubImageFromBitmap
            // Adding abstract: GetBitmapFormat
            // Adding abstract: SetMipMapping
            // Adding abstract: SetClamping
            // Adding abstract: UpdateMipmaps
            // Adding abstract: SetFormat
            // Adding abstract: AttachToCurrentFB
            // Adding abstract: CommitChanges
         // Class: clSoftTexture
            // Overriding abstract: Bind
            // Overriding abstract: SaveToBitmap
            // Overriding abstract: GetBitmapFormat
            // Overriding abstract: LoadFromBitmap
            // Overriding abstract: UpdateSubImageFromBitmap
            // Overriding abstract: CommitChanges
            // Overriding abstract: SetMipMapping
            // Overriding abstract: SetClamping
            // Overriding abstract: UpdateMipmaps
            // Overriding abstract: SetFormat
            // Overriding abstract: AttachToCurrentFB

void RegisterPackageLinderdaumCoreClass212(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clSoftTexture>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clSoftTexture,Mtd)
   _RM__(Bind)
   _RM__(SaveToBitmap)
   _RM__(GetBitmapFormat)
   _RM__(LoadFromBitmap)
   _RM__(UpdateSubImageFromBitmap)
   _RM__(SetImage)
   _RM__(CommitChanges)
   _RM__(SetMipMapping)
   _RM__(SetClamping)
   _RM__(UpdateMipmaps)
   _RM__(SetFormat)
   _RM__(AttachToCurrentFB)
   #undef _RM__
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iTexture" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/Renderer/Soft/SoftVertexArray.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: iVertexArray
            // Adding abstract: FeedIntoGPU
            // Adding abstract: FeedIntoGPUInstanced
            // Adding abstract: CommitChanges
         // Class: clSoftVertexArray
            // Overriding abstract: FeedIntoGPU
            // Overriding abstract: FeedIntoGPUInstanced
            // Overriding abstract: CommitChanges

void RegisterPackageLinderdaumCoreClass213(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clSoftVertexArray>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   REG_CLS_MTD( clSoftVertexArray,FeedIntoGPU )
   REG_CLS_MTD( clSoftVertexArray,FeedIntoGPUInstanced )
   REG_CLS_MTD( clSoftVertexArray,CommitChanges )
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iVertexArray" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/VisualScene/VisualRenderables.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clSplineKB
// SCALAR_PROPERTY_LOAD__FIELD
// Tension
// FTension
// clSplineKB
// FTension
// LStr::ToFloat

bool LoadScalarField_clSplineKB_FTension_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clSplineKB*>(Obj))->FTension=LStr::ToFloat( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// Tension
// FTension
// clSplineKB
// FTension
// LStr::ToStrEpsilon

bool SaveScalarField_clSplineKB_FTension_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<clSplineKB*>(Obj)->FTension); 
   *Result = new mlNode("Tension" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// Bias
// FBias
// clSplineKB
// FBias
// LStr::ToFloat

bool LoadScalarField_clSplineKB_FBias_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clSplineKB*>(Obj))->FBias=LStr::ToFloat( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// Bias
// FBias
// clSplineKB
// FBias
// LStr::ToStrEpsilon

bool SaveScalarField_clSplineKB_FBias_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<clSplineKB*>(Obj)->FBias); 
   *Result = new mlNode("Bias" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// Continuity
// FContinuity
// clSplineKB
// FContinuity
// LStr::ToFloat

bool LoadScalarField_clSplineKB_FContinuity_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clSplineKB*>(Obj))->FContinuity=LStr::ToFloat( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// Continuity
// FContinuity
// clSplineKB
// FContinuity
// LStr::ToStrEpsilon

bool SaveScalarField_clSplineKB_FContinuity_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<clSplineKB*>(Obj)->FContinuity); 
   *Result = new mlNode("Continuity" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}




void RegisterPackageLinderdaumCoreClass214(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clSplineKB>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clSplineKB,Mtd)
   _RM__(GetPosition)
   _RM__(GetDerivative)
   _RM__(GetSecondDerivative)
   _RM__(GetCanonicalFrame)
   _RM__(GetKnot)
   _RM__(SetKnot)
   #undef _RM__
#endif // _DISABLE_METHODS_
   REGISTER_PROPERTY__SCALAR_FIELD(FTension, clSplineKB, Tension)

   REGISTER_PROPERTY__SCALAR_FIELD(FBias, clSplineKB, Bias)

   REGISTER_PROPERTY__SCALAR_FIELD(FContinuity, clSplineKB, Continuity)

   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: iCameraPositioner
            // Adding abstract: Update
         // Class: clSelectionPositioner
            // Overriding abstract: Update
         // Class: clStandartPositioner

void RegisterPackageLinderdaumCoreClass215(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clStandartPositioner>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clStandartPositioner,Mtd)
   _RM__(AfterConstruction)
   _RM__(GenerateOrbit)
   _RM__(GetRail)
   _RM__(GetMaxLike)
   _RM__(GetTrajectoryPositioner)
   #undef _RM__
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "clSelectionPositioner" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/Core/RTTI/State.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clState
// OBJECT_ARRAY_PROPERTY_LOAD__FIELD
// Methods
// FMethods
// clState
// iMethod

bool LoadObjectItem_clState_FMethods_FIELD(mlNode* Node, iObject* Obj, int i) 
{
   FIX_PARSER_DEFECT(RealNode, Node->children[i]) 
  iMethod* Ptr = NULL; 
   bool Res = Obj->Env->Linker->LoadObject(RealNode, reinterpret_cast<iObject**>(&Ptr)); 
  clState* CastedObj = dynamic_cast<clState*>(Obj); 
   if ( Res ) CastedObj->FMethods[i] = Ptr; 
   return Res; 
}

// OBJECT_ARRAY_PROPERTY_SAVE__FIELD
// Methods
// FMethods
// clState

bool SaveObjectItem_clState_FMethods_FIELD(iObject* Obj, int i, mlNode** Result) 
{
   return (dynamic_cast<clState*>(Obj)->FMethods[i])->Save(Result);
}


// ARRAY_PROPERTY_FUNCTIONS__FIELD
// FMethods
// clState

   ARRAY_PROPERTY_RESIZE_FUNCTION__FIELD(FMethods,clState) 
   ARRAY_PROPERTY_SIZE_FUNCTION__FIELD(FMethods,clState) 
   ARRAY_PROPERTY_CLEAR_FUNCTION__FIELD(FMethods,clState)


// ARRAY_PROPERTY_DELETE_FUNCTION__FIELD
// FMethods
// clState

void DeleteFunction_clState_FMethods_FIELD(iObject* Obj, int Resize) 
{ 
   int Size = SizeFunction_clState_FMethods_FIELD(Obj); 
   for (int i = 0 ; i < Size ; i++) 
   { 
      dynamic_cast<clState*>(Obj)->FMethods[i] ->DisposeObject(); 
   }
   dynamic_cast<clState*>(Obj)->FMethods.clear(); 
}



// SCALAR_PROPERTY_LOAD__FIELD
// StateName
// FStateName
// clState
// FStateName
// EMPTY_CONVERTER

bool LoadScalarField_clState_FStateName_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clState*>(Obj))->FStateName=EMPTY_CONVERTER( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// StateName
// FStateName
// clState
// FStateName
// EMPTY_CONVERTER

bool SaveScalarField_clState_FStateName_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =EMPTY_CONVERTER(dynamic_cast<clState*>(Obj)->FStateName); 
   *Result = new mlNode("StateName" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// SuperStateName
// ""
// clState
// SetSuperStateName
// EMPTY_CONVERTER

bool LoadScalarField_clState_SuperStateName_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clState*>(Obj))->SetSuperStateName(EMPTY_CONVERTER( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// SuperStateName
// ""
// clState
// GetSuperStateName
// EMPTY_CONVERTER

bool SaveScalarField_clState_SuperStateName_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =EMPTY_CONVERTER(dynamic_cast<clState*>(Obj)->GetSuperStateName() ); 
   *Result = new mlNode("SuperStateName" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}




void RegisterPackageLinderdaumCoreClass216(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clState>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clState,Mtd)
   _RM__(GetStateName)
   _RM__(SetStateName)
   _RM__(RegisterMethod)
   _RM__(FindMethod)
   _RM__(SetSuperState)
   _RM__(GetSuperState)
   _RM__(GetMethodByIndex)
   _RM__(GetMethodIndexByName)
   _RM__(GetLocalMethodByIndex)
   _RM__(GetLinearMethodsListPtr)
   _RM__(SetMethodByIndex)
   _RM__(GetSuperStateName)
   _RM__(SetSuperStateName)
   _RM__(EndLoad)
   _RM__(BuildVirtualMethodTable)
   #undef _RM__
#endif // _DISABLE_METHODS_
   REGISTER_PROPERTY__OBJECT_ARRAY_FIELD(FMethods, clState, Methods)

   REGISTER_PROPERTY__SCALAR_FIELD(FStateName, clState, StateName)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(SuperStateName, clState, SuperStateName)

   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: iCameraPositioner
            // Adding abstract: Update
         // Class: clStdCameraPositioner
            // Overriding abstract: Update

void RegisterPackageLinderdaumCoreClass217(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clStdCameraPositioner>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   REG_CLS_MTD( clStdCameraPositioner,Update )
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iCameraPositioner" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clUVSurfaceGenerator
            // Adding abstract: R_and_dR
         // Class: clSuperShapeGenerator
            // Overriding abstract: R_and_dR
// SCALAR_PROPERTY_LOAD__FIELD
// A1
// FA_1
// clSuperShapeGenerator
// FA_1
// LStr::ToFloat

bool LoadScalarField_clSuperShapeGenerator_FA_1_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clSuperShapeGenerator*>(Obj))->FA_1=LStr::ToFloat( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// A1
// FA_1
// clSuperShapeGenerator
// FA_1
// LStr::ToStrEpsilon

bool SaveScalarField_clSuperShapeGenerator_FA_1_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<clSuperShapeGenerator*>(Obj)->FA_1); 
   *Result = new mlNode("A1" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// A2
// FA_2
// clSuperShapeGenerator
// FA_2
// LStr::ToFloat

bool LoadScalarField_clSuperShapeGenerator_FA_2_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clSuperShapeGenerator*>(Obj))->FA_2=LStr::ToFloat( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// A2
// FA_2
// clSuperShapeGenerator
// FA_2
// LStr::ToStrEpsilon

bool SaveScalarField_clSuperShapeGenerator_FA_2_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<clSuperShapeGenerator*>(Obj)->FA_2); 
   *Result = new mlNode("A2" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// B1
// FB_1
// clSuperShapeGenerator
// FB_1
// LStr::ToFloat

bool LoadScalarField_clSuperShapeGenerator_FB_1_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clSuperShapeGenerator*>(Obj))->FB_1=LStr::ToFloat( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// B1
// FB_1
// clSuperShapeGenerator
// FB_1
// LStr::ToStrEpsilon

bool SaveScalarField_clSuperShapeGenerator_FB_1_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<clSuperShapeGenerator*>(Obj)->FB_1); 
   *Result = new mlNode("B1" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// B2
// FB_2
// clSuperShapeGenerator
// FB_2
// LStr::ToFloat

bool LoadScalarField_clSuperShapeGenerator_FB_2_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clSuperShapeGenerator*>(Obj))->FB_2=LStr::ToFloat( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// B2
// FB_2
// clSuperShapeGenerator
// FB_2
// LStr::ToStrEpsilon

bool SaveScalarField_clSuperShapeGenerator_FB_2_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<clSuperShapeGenerator*>(Obj)->FB_2); 
   *Result = new mlNode("B2" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// M_1
// FM_1
// clSuperShapeGenerator
// FM_1
// LStr::ToInt

bool LoadScalarField_clSuperShapeGenerator_FM_1_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clSuperShapeGenerator*>(Obj))->FM_1=LStr::ToInt( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// M_1
// FM_1
// clSuperShapeGenerator
// FM_1
// LStr::ToStr

bool SaveScalarField_clSuperShapeGenerator_FM_1_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStr(dynamic_cast<clSuperShapeGenerator*>(Obj)->FM_1); 
   *Result = new mlNode("M_1" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// N1_1
// FN1_1
// clSuperShapeGenerator
// FN1_1
// LStr::ToInt

bool LoadScalarField_clSuperShapeGenerator_FN1_1_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clSuperShapeGenerator*>(Obj))->FN1_1=LStr::ToInt( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// N1_1
// FN1_1
// clSuperShapeGenerator
// FN1_1
// LStr::ToStr

bool SaveScalarField_clSuperShapeGenerator_FN1_1_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStr(dynamic_cast<clSuperShapeGenerator*>(Obj)->FN1_1); 
   *Result = new mlNode("N1_1" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// N2_1
// FN2_1
// clSuperShapeGenerator
// FN2_1
// LStr::ToInt

bool LoadScalarField_clSuperShapeGenerator_FN2_1_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clSuperShapeGenerator*>(Obj))->FN2_1=LStr::ToInt( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// N2_1
// FN2_1
// clSuperShapeGenerator
// FN2_1
// LStr::ToStr

bool SaveScalarField_clSuperShapeGenerator_FN2_1_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStr(dynamic_cast<clSuperShapeGenerator*>(Obj)->FN2_1); 
   *Result = new mlNode("N2_1" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// N3_1
// FN3_1
// clSuperShapeGenerator
// FN3_1
// LStr::ToInt

bool LoadScalarField_clSuperShapeGenerator_FN3_1_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clSuperShapeGenerator*>(Obj))->FN3_1=LStr::ToInt( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// N3_1
// FN3_1
// clSuperShapeGenerator
// FN3_1
// LStr::ToStr

bool SaveScalarField_clSuperShapeGenerator_FN3_1_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStr(dynamic_cast<clSuperShapeGenerator*>(Obj)->FN3_1); 
   *Result = new mlNode("N3_1" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// M_2
// FM_2
// clSuperShapeGenerator
// FM_2
// LStr::ToInt

bool LoadScalarField_clSuperShapeGenerator_FM_2_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clSuperShapeGenerator*>(Obj))->FM_2=LStr::ToInt( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// M_2
// FM_2
// clSuperShapeGenerator
// FM_2
// LStr::ToStr

bool SaveScalarField_clSuperShapeGenerator_FM_2_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStr(dynamic_cast<clSuperShapeGenerator*>(Obj)->FM_2); 
   *Result = new mlNode("M_2" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// N1_2
// FN1_2
// clSuperShapeGenerator
// FN1_2
// LStr::ToInt

bool LoadScalarField_clSuperShapeGenerator_FN1_2_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clSuperShapeGenerator*>(Obj))->FN1_2=LStr::ToInt( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// N1_2
// FN1_2
// clSuperShapeGenerator
// FN1_2
// LStr::ToStr

bool SaveScalarField_clSuperShapeGenerator_FN1_2_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStr(dynamic_cast<clSuperShapeGenerator*>(Obj)->FN1_2); 
   *Result = new mlNode("N1_2" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// N2_2
// FN2_2
// clSuperShapeGenerator
// FN2_2
// LStr::ToInt

bool LoadScalarField_clSuperShapeGenerator_FN2_2_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clSuperShapeGenerator*>(Obj))->FN2_2=LStr::ToInt( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// N2_2
// FN2_2
// clSuperShapeGenerator
// FN2_2
// LStr::ToStr

bool SaveScalarField_clSuperShapeGenerator_FN2_2_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStr(dynamic_cast<clSuperShapeGenerator*>(Obj)->FN2_2); 
   *Result = new mlNode("N2_2" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// N3_2
// FN3_2
// clSuperShapeGenerator
// FN3_2
// LStr::ToInt

bool LoadScalarField_clSuperShapeGenerator_FN3_2_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clSuperShapeGenerator*>(Obj))->FN3_2=LStr::ToInt( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// N3_2
// FN3_2
// clSuperShapeGenerator
// FN3_2
// LStr::ToStr

bool SaveScalarField_clSuperShapeGenerator_FN3_2_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStr(dynamic_cast<clSuperShapeGenerator*>(Obj)->FN3_2); 
   *Result = new mlNode("N3_2" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// IsToroidal
// FToroidal
// clSuperShapeGenerator
// FToroidal
// LStr::ToBool

bool LoadScalarField_clSuperShapeGenerator_FToroidal_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clSuperShapeGenerator*>(Obj))->FToroidal=LStr::ToBool( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// IsToroidal
// FToroidal
// clSuperShapeGenerator
// FToroidal
// LStr::ToStr_Bool

bool SaveScalarField_clSuperShapeGenerator_FToroidal_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStr_Bool(dynamic_cast<clSuperShapeGenerator*>(Obj)->FToroidal); 
   *Result = new mlNode("IsToroidal" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}




void RegisterPackageLinderdaumCoreClass218(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clSuperShapeGenerator>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   REG_CLS_MTD( clSuperShapeGenerator,R_and_dR )
   REG_CLS_MTD( clSuperShapeGenerator,R_dR )
#endif // _DISABLE_METHODS_
   REGISTER_PROPERTY__SCALAR_FIELD(FA_1, clSuperShapeGenerator, A1)

   REGISTER_PROPERTY__SCALAR_FIELD(FA_2, clSuperShapeGenerator, A2)

   REGISTER_PROPERTY__SCALAR_FIELD(FB_1, clSuperShapeGenerator, B1)

   REGISTER_PROPERTY__SCALAR_FIELD(FB_2, clSuperShapeGenerator, B2)

   REGISTER_PROPERTY__SCALAR_FIELD(FM_1, clSuperShapeGenerator, M_1)

   REGISTER_PROPERTY__SCALAR_FIELD(FN1_1, clSuperShapeGenerator, N1_1)

   REGISTER_PROPERTY__SCALAR_FIELD(FN2_1, clSuperShapeGenerator, N2_1)

   REGISTER_PROPERTY__SCALAR_FIELD(FN3_1, clSuperShapeGenerator, N3_1)

   REGISTER_PROPERTY__SCALAR_FIELD(FM_2, clSuperShapeGenerator, M_2)

   REGISTER_PROPERTY__SCALAR_FIELD(FN1_2, clSuperShapeGenerator, N1_2)

   REGISTER_PROPERTY__SCALAR_FIELD(FN2_2, clSuperShapeGenerator, N2_2)

   REGISTER_PROPERTY__SCALAR_FIELD(FN3_2, clSuperShapeGenerator, N3_2)

   REGISTER_PROPERTY__SCALAR_FIELD(FToroidal, clSuperShapeGenerator, IsToroidal)

   StaticClass->SetSuperClassName( "clUVSurfaceGenerator" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/Scene/Terrain/Terrain.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clTerrain

void RegisterPackageLinderdaumCoreClass219(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clTerrain>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   REG_CLS_MTD( clTerrain,LoadHeightMap )
   REG_CLS_MTD( clTerrain,GetBoundingBox )
   REG_CLS_MTD( clTerrain,RenderDirect )
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "clTestClient_Tunneller.h"

#include "Linderdaum/UnitTests/Tests/Classes_Test_8.h"

void RegisterPackageLinderdaumCoreClass220(sEnvironment* Env)
{
#if !defined(_DISABLE_TUNNELLERS_)
   iStaticClass* StaticClass = new clNativeStaticClass<clTestClient_Tunneller>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   REG_CLS_MTD( clTestClient,AcceptString )
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
#endif // _DISABLE_TUNNELLERS_
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clTestClient

void RegisterPackageLinderdaumCoreClass221(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clTestClient>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   REG_CLS_MTD( clTestClient,AcceptString )
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/UnitTests/Tests/Classes_Test_9.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: iHeightDataProvider
         // Class: clTestHeightDataProvider

void RegisterPackageLinderdaumCoreClass222(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clTestHeightDataProvider>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clTestHeightDataProvider,Mtd)
   _RM__(GetSizeX)
   _RM__(GetSizeY)
   _RM__(GetHeight)
   _RM__(SetHeight)
   _RM__(GetMaximalHeight)
   _RM__(GetMinimalHeight)
   #undef _RM__
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iHeightDataProvider" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clTextRenderer

void RegisterPackageLinderdaumCoreClass223(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clTextRenderer>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clTextRenderer,Mtd)
   _RM__(IsInitialized)
   _RM__(SetFont)
   _RM__(SetFontByName)
   _RM__(LoadTextStringWithFont)
   _RM__(LoadTextString)
   _RM__(CalculateLineWidth)
   _RM__(CalculateLineHeight)
   _RM__(RenderLineOnBitmap)
   _RM__(RenderLineInVertexAttribs)
   _RM__(RenderLine)
   _RM__(RenderText)
   _RM__(RenderTextWithFont)
   _RM__(PreloadFont)
   _RM__(GetFontHandle)
   _RM__(SetMaskMode)
   _RM__(GetMaskMode)
   #undef _RM__
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: iWaveDataProvider
            // Adding abstract: Clone
            // Adding abstract: IsStreaming
            // Adding abstract: IsEOF
            // Adding abstract: GetWaveDataFormat
            // Adding abstract: GetWaveData
            // Adding abstract: GetWaveDataSize
            // Adding abstract: StreamWaveData
            // Adding abstract: Seek
         // Class: clToneGenerator
            // Overriding abstract: IsStreaming
            // Overriding abstract: IsEOF
            // Overriding abstract: GetWaveDataFormat
            // Overriding abstract: GetWaveData
            // Overriding abstract: GetWaveDataSize
            // Overriding abstract: StreamWaveData
            // Overriding abstract: Seek
      // Abstract method: Clone

void RegisterPackageLinderdaumCoreClass224(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeAbstractStaticClass<clToneGenerator>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clToneGenerator,Mtd)
   _RM__(IsStreaming)
   _RM__(IsEOF)
   _RM__(GetWaveDataFormat)
   _RM__(GetWaveData)
   _RM__(GetWaveDataSize)
   _RM__(StreamWaveData)
   _RM__(Seek)
   #undef _RM__
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iWaveDataProvider" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clUVSurfaceGenerator
            // Adding abstract: R_and_dR
         // Class: clTorusKnot
            // Overriding abstract: R_and_dR
// SCALAR_PROPERTY_LOAD__FIELD
// BaseRadius
// BaseRadius
// clTorusKnot
// BaseRadius
// LStr::ToFloat

bool LoadScalarField_clTorusKnot_BaseRadius_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clTorusKnot*>(Obj))->BaseRadius=LStr::ToFloat( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// BaseRadius
// BaseRadius
// clTorusKnot
// BaseRadius
// LStr::ToStrEpsilon

bool SaveScalarField_clTorusKnot_BaseRadius_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<clTorusKnot*>(Obj)->BaseRadius); 
   *Result = new mlNode("BaseRadius" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// SegmentRadius
// SegmentRadius
// clTorusKnot
// SegmentRadius
// LStr::ToFloat

bool LoadScalarField_clTorusKnot_SegmentRadius_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clTorusKnot*>(Obj))->SegmentRadius=LStr::ToFloat( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// SegmentRadius
// SegmentRadius
// clTorusKnot
// SegmentRadius
// LStr::ToStrEpsilon

bool SaveScalarField_clTorusKnot_SegmentRadius_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<clTorusKnot*>(Obj)->SegmentRadius); 
   *Result = new mlNode("SegmentRadius" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// TubeRadius
// TubeRadius
// clTorusKnot
// TubeRadius
// LStr::ToFloat

bool LoadScalarField_clTorusKnot_TubeRadius_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clTorusKnot*>(Obj))->TubeRadius=LStr::ToFloat( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// TubeRadius
// TubeRadius
// clTorusKnot
// TubeRadius
// LStr::ToStrEpsilon

bool SaveScalarField_clTorusKnot_TubeRadius_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<clTorusKnot*>(Obj)->TubeRadius); 
   *Result = new mlNode("TubeRadius" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// p
// p
// clTorusKnot
// p
// LStr::ToInt

bool LoadScalarField_clTorusKnot_p_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clTorusKnot*>(Obj))->p=LStr::ToInt( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// p
// p
// clTorusKnot
// p
// LStr::ToStr

bool SaveScalarField_clTorusKnot_p_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStr(dynamic_cast<clTorusKnot*>(Obj)->p); 
   *Result = new mlNode("p" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// q
// q
// clTorusKnot
// q
// LStr::ToInt

bool LoadScalarField_clTorusKnot_q_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clTorusKnot*>(Obj))->q=LStr::ToInt( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// q
// q
// clTorusKnot
// q
// LStr::ToStr

bool SaveScalarField_clTorusKnot_q_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStr(dynamic_cast<clTorusKnot*>(Obj)->q); 
   *Result = new mlNode("q" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}




void RegisterPackageLinderdaumCoreClass225(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clTorusKnot>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   REG_CLS_MTD( clTorusKnot,R_and_dR )
   REG_CLS_MTD( clTorusKnot,AfterLoad )
   REG_CLS_MTD( clTorusKnot,BeforeSave )
#endif // _DISABLE_METHODS_
   REGISTER_PROPERTY__SCALAR_FIELD(BaseRadius, clTorusKnot, BaseRadius)

   REGISTER_PROPERTY__SCALAR_FIELD(SegmentRadius, clTorusKnot, SegmentRadius)

   REGISTER_PROPERTY__SCALAR_FIELD(TubeRadius, clTorusKnot, TubeRadius)

   REGISTER_PROPERTY__SCALAR_FIELD(p, clTorusKnot, p)

   REGISTER_PROPERTY__SCALAR_FIELD(q, clTorusKnot, q)

   StaticClass->SetSuperClassName( "clUVSurfaceGenerator" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clTrajectoryNode
// SCALAR_PROPERTY_LOAD__FIELD
// Position
// FPosition
// clTrajectoryNode
// FPosition
// LStr::StrToVec3

bool LoadScalarField_clTrajectoryNode_FPosition_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clTrajectoryNode*>(Obj))->FPosition=LStr::StrToVec3( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// Position
// FPosition
// clTrajectoryNode
// FPosition
// LStr::Vec3ToStr

bool SaveScalarField_clTrajectoryNode_FPosition_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::Vec3ToStr(dynamic_cast<clTrajectoryNode*>(Obj)->FPosition); 
   *Result = new mlNode("Position" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// Orientation
// FOrientation
// clTrajectoryNode
// FOrientation
// LStr::StrToQuat

bool LoadScalarField_clTrajectoryNode_FOrientation_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clTrajectoryNode*>(Obj))->FOrientation=LStr::StrToQuat( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// Orientation
// FOrientation
// clTrajectoryNode
// FOrientation
// LStr::QuatToStr

bool SaveScalarField_clTrajectoryNode_FOrientation_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::QuatToStr(dynamic_cast<clTrajectoryNode*>(Obj)->FOrientation); 
   *Result = new mlNode("Orientation" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// Timestamp
// FTimestamp
// clTrajectoryNode
// FTimestamp
// LStr::ToFloat

bool LoadScalarField_clTrajectoryNode_FTimestamp_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clTrajectoryNode*>(Obj))->FTimestamp=LStr::ToFloat( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// Timestamp
// FTimestamp
// clTrajectoryNode
// FTimestamp
// LStr::ToStrEpsilon

bool SaveScalarField_clTrajectoryNode_FTimestamp_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<clTrajectoryNode*>(Obj)->FTimestamp); 
   *Result = new mlNode("Timestamp" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}




void RegisterPackageLinderdaumCoreClass226(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clTrajectoryNode>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
#endif // _DISABLE_METHODS_
   REGISTER_PROPERTY__SCALAR_FIELD(FPosition, clTrajectoryNode, Position)

   REGISTER_PROPERTY__SCALAR_FIELD(FOrientation, clTrajectoryNode, Orientation)

   REGISTER_PROPERTY__SCALAR_FIELD(FTimestamp, clTrajectoryNode, Timestamp)

   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: iCameraPositioner
            // Adding abstract: Update
         // Class: clTrajectoryPositioner
            // Overriding abstract: Update
// SCALAR_PROPERTY_LOAD__FIELD
// UpdateTime
// FUpdateTime
// clTrajectoryPositioner
// FUpdateTime
// LStr::ToBool

bool LoadScalarField_clTrajectoryPositioner_FUpdateTime_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clTrajectoryPositioner*>(Obj))->FUpdateTime=LStr::ToBool( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// UpdateTime
// FUpdateTime
// clTrajectoryPositioner
// FUpdateTime
// LStr::ToStr_Bool

bool SaveScalarField_clTrajectoryPositioner_FUpdateTime_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStr_Bool(dynamic_cast<clTrajectoryPositioner*>(Obj)->FUpdateTime); 
   *Result = new mlNode("UpdateTime" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// SpeedFactor
// FSpeedFactor
// clTrajectoryPositioner
// FSpeedFactor
// LStr::ToFloat

bool LoadScalarField_clTrajectoryPositioner_FSpeedFactor_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clTrajectoryPositioner*>(Obj))->FSpeedFactor=LStr::ToFloat( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// SpeedFactor
// FSpeedFactor
// clTrajectoryPositioner
// FSpeedFactor
// LStr::ToStrEpsilon

bool SaveScalarField_clTrajectoryPositioner_FSpeedFactor_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<clTrajectoryPositioner*>(Obj)->FSpeedFactor); 
   *Result = new mlNode("SpeedFactor" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// TrackTarget
// FTrackTarget
// clTrajectoryPositioner
// FTrackTarget
// LStr::ToBool

bool LoadScalarField_clTrajectoryPositioner_FTrackTarget_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clTrajectoryPositioner*>(Obj))->FTrackTarget=LStr::ToBool( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// TrackTarget
// FTrackTarget
// clTrajectoryPositioner
// FTrackTarget
// LStr::ToStr_Bool

bool SaveScalarField_clTrajectoryPositioner_FTrackTarget_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStr_Bool(dynamic_cast<clTrajectoryPositioner*>(Obj)->FTrackTarget); 
   *Result = new mlNode("TrackTarget" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// StaticTarget
// FStaticTarget
// clTrajectoryPositioner
// FStaticTarget
// LStr::StrToVec3

bool LoadScalarField_clTrajectoryPositioner_FStaticTarget_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clTrajectoryPositioner*>(Obj))->FStaticTarget=LStr::StrToVec3( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// StaticTarget
// FStaticTarget
// clTrajectoryPositioner
// FStaticTarget
// LStr::Vec3ToStr

bool SaveScalarField_clTrajectoryPositioner_FStaticTarget_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::Vec3ToStr(dynamic_cast<clTrajectoryPositioner*>(Obj)->FStaticTarget); 
   *Result = new mlNode("StaticTarget" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// LocalTime
// FLocalTime
// clTrajectoryPositioner
// FLocalTime
// LStr::ToFloat

bool LoadScalarField_clTrajectoryPositioner_FLocalTime_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clTrajectoryPositioner*>(Obj))->FLocalTime=LStr::ToFloat( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// LocalTime
// FLocalTime
// clTrajectoryPositioner
// FLocalTime
// LStr::ToStrEpsilon

bool SaveScalarField_clTrajectoryPositioner_FLocalTime_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<clTrajectoryPositioner*>(Obj)->FLocalTime); 
   *Result = new mlNode("LocalTime" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// UpVector
// FUpVector
// clTrajectoryPositioner
// FUpVector
// LStr::StrToVec3

bool LoadScalarField_clTrajectoryPositioner_FUpVector_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clTrajectoryPositioner*>(Obj))->FUpVector=LStr::StrToVec3( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// UpVector
// FUpVector
// clTrajectoryPositioner
// FUpVector
// LStr::Vec3ToStr

bool SaveScalarField_clTrajectoryPositioner_FUpVector_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::Vec3ToStr(dynamic_cast<clTrajectoryPositioner*>(Obj)->FUpVector); 
   *Result = new mlNode("UpVector" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}




void RegisterPackageLinderdaumCoreClass227(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clTrajectoryPositioner>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clTrajectoryPositioner,Mtd)
   _RM__(AfterConstruction)
   _RM__(ToggleTimeLine)
   _RM__(GenerateOrbit)
   _RM__(GetMinTime)
   _RM__(GetMaxTime)
   _RM__(ResetTime)
   _RM__(Update)
   _RM__(AddControlUI)
   _RM__(RemoveControlUI)
   #undef _RM__
#endif // _DISABLE_METHODS_
   REGISTER_PROPERTY__SCALAR_FIELD(FUpdateTime, clTrajectoryPositioner, UpdateTime)

   REGISTER_PROPERTY__SCALAR_FIELD(FSpeedFactor, clTrajectoryPositioner, SpeedFactor)

   REGISTER_PROPERTY__SCALAR_FIELD(FTrackTarget, clTrajectoryPositioner, TrackTarget)

   REGISTER_PROPERTY__SCALAR_FIELD(FStaticTarget, clTrajectoryPositioner, StaticTarget)

   REGISTER_PROPERTY__SCALAR_FIELD(FLocalTime, clTrajectoryPositioner, LocalTime)

   REGISTER_PROPERTY__SCALAR_FIELD(FUpVector, clTrajectoryPositioner, UpVector)

   StaticClass->SetSuperClassName( "iCameraPositioner" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clVisualObject
         // Class: clVisualModifier
         // Class: clGizmo
         // Class: clTranslateGizmo

void RegisterPackageLinderdaumCoreClass228(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clTranslateGizmo>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   REG_CLS_MTD( clTranslateGizmo,CalculateTransform )
   REG_CLS_MTD( clTranslateGizmo,FetchInitialPropertyValue )
   REG_CLS_MTD( clTranslateGizmo,SetCurrentValue )
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "clGizmo" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clUVSurfaceGenerator
            // Adding abstract: R_and_dR
         // Class: clTubularNeighbourhood
            // Overriding abstract: R_and_dR
// SCALAR_PROPERTY_LOAD__FIELD
// TubeRadius
// TubeRadius
// clTubularNeighbourhood
// TubeRadius
// LStr::ToFloat

bool LoadScalarField_clTubularNeighbourhood_TubeRadius_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clTubularNeighbourhood*>(Obj))->TubeRadius=LStr::ToFloat( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// TubeRadius
// TubeRadius
// clTubularNeighbourhood
// TubeRadius
// LStr::ToStrEpsilon

bool SaveScalarField_clTubularNeighbourhood_TubeRadius_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<clTubularNeighbourhood*>(Obj)->TubeRadius); 
   *Result = new mlNode("TubeRadius" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}




void RegisterPackageLinderdaumCoreClass229(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clTubularNeighbourhood>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   REG_CLS_MTD( clTubularNeighbourhood,R_and_dR )
#endif // _DISABLE_METHODS_
   REGISTER_PROPERTY__SCALAR_FIELD(TubeRadius, clTubularNeighbourhood, TubeRadius)

   StaticClass->SetSuperClassName( "clUVSurfaceGenerator" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clUVSurfaceGenerator
            // Adding abstract: R_and_dR
      // Abstract method: R_and_dR
// SCALAR_PROPERTY_LOAD__FIELD
// MinU
// MinU
// clUVSurfaceGenerator
// MinU
// LStr::ToFloat

bool LoadScalarField_clUVSurfaceGenerator_MinU_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clUVSurfaceGenerator*>(Obj))->MinU=LStr::ToFloat( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// MinU
// MinU
// clUVSurfaceGenerator
// MinU
// LStr::ToStrEpsilon

bool SaveScalarField_clUVSurfaceGenerator_MinU_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<clUVSurfaceGenerator*>(Obj)->MinU); 
   *Result = new mlNode("MinU" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// MinV
// MinV
// clUVSurfaceGenerator
// MinV
// LStr::ToFloat

bool LoadScalarField_clUVSurfaceGenerator_MinV_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clUVSurfaceGenerator*>(Obj))->MinV=LStr::ToFloat( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// MinV
// MinV
// clUVSurfaceGenerator
// MinV
// LStr::ToStrEpsilon

bool SaveScalarField_clUVSurfaceGenerator_MinV_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<clUVSurfaceGenerator*>(Obj)->MinV); 
   *Result = new mlNode("MinV" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// MaxU
// MaxU
// clUVSurfaceGenerator
// MaxU
// LStr::ToFloat

bool LoadScalarField_clUVSurfaceGenerator_MaxU_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clUVSurfaceGenerator*>(Obj))->MaxU=LStr::ToFloat( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// MaxU
// MaxU
// clUVSurfaceGenerator
// MaxU
// LStr::ToStrEpsilon

bool SaveScalarField_clUVSurfaceGenerator_MaxU_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<clUVSurfaceGenerator*>(Obj)->MaxU); 
   *Result = new mlNode("MaxU" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// MaxV
// MaxV
// clUVSurfaceGenerator
// MaxV
// LStr::ToFloat

bool LoadScalarField_clUVSurfaceGenerator_MaxV_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clUVSurfaceGenerator*>(Obj))->MaxV=LStr::ToFloat( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// MaxV
// MaxV
// clUVSurfaceGenerator
// MaxV
// LStr::ToStrEpsilon

bool SaveScalarField_clUVSurfaceGenerator_MaxV_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<clUVSurfaceGenerator*>(Obj)->MaxV); 
   *Result = new mlNode("MaxV" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// GlueUEdges
// GlueUEdges
// clUVSurfaceGenerator
// GlueUEdges
// LStr::ToBool

bool LoadScalarField_clUVSurfaceGenerator_GlueUEdges_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clUVSurfaceGenerator*>(Obj))->GlueUEdges=LStr::ToBool( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// GlueUEdges
// GlueUEdges
// clUVSurfaceGenerator
// GlueUEdges
// LStr::ToStr_Bool

bool SaveScalarField_clUVSurfaceGenerator_GlueUEdges_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStr_Bool(dynamic_cast<clUVSurfaceGenerator*>(Obj)->GlueUEdges); 
   *Result = new mlNode("GlueUEdges" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// GlueVEdges
// GlueVEdges
// clUVSurfaceGenerator
// GlueVEdges
// LStr::ToBool

bool LoadScalarField_clUVSurfaceGenerator_GlueVEdges_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clUVSurfaceGenerator*>(Obj))->GlueVEdges=LStr::ToBool( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// GlueVEdges
// GlueVEdges
// clUVSurfaceGenerator
// GlueVEdges
// LStr::ToStr_Bool

bool SaveScalarField_clUVSurfaceGenerator_GlueVEdges_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStr_Bool(dynamic_cast<clUVSurfaceGenerator*>(Obj)->GlueVEdges); 
   *Result = new mlNode("GlueVEdges" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// NumU
// NumU
// clUVSurfaceGenerator
// NumU
// LStr::ToInt

bool LoadScalarField_clUVSurfaceGenerator_NumU_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clUVSurfaceGenerator*>(Obj))->NumU=LStr::ToInt( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// NumU
// NumU
// clUVSurfaceGenerator
// NumU
// LStr::ToStr

bool SaveScalarField_clUVSurfaceGenerator_NumU_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStr(dynamic_cast<clUVSurfaceGenerator*>(Obj)->NumU); 
   *Result = new mlNode("NumU" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// NumV
// NumV
// clUVSurfaceGenerator
// NumV
// LStr::ToInt

bool LoadScalarField_clUVSurfaceGenerator_NumV_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clUVSurfaceGenerator*>(Obj))->NumV=LStr::ToInt( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// NumV
// NumV
// clUVSurfaceGenerator
// NumV
// LStr::ToStr

bool SaveScalarField_clUVSurfaceGenerator_NumV_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStr(dynamic_cast<clUVSurfaceGenerator*>(Obj)->NumV); 
   *Result = new mlNode("NumV" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}




void RegisterPackageLinderdaumCoreClass230(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeAbstractStaticClass<clUVSurfaceGenerator>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   REG_CLS_MTD( clUVSurfaceGenerator,CreateGeom )
   REG_CLS_MTD( clUVSurfaceGenerator,CreateSurface )
   REG_CLS_MTD( clUVSurfaceGenerator,R_and_dR )
#endif // _DISABLE_METHODS_
   REGISTER_PROPERTY__SCALAR_FIELD(MinU, clUVSurfaceGenerator, MinU)

   REGISTER_PROPERTY__SCALAR_FIELD(MinV, clUVSurfaceGenerator, MinV)

   REGISTER_PROPERTY__SCALAR_FIELD(MaxU, clUVSurfaceGenerator, MaxU)

   REGISTER_PROPERTY__SCALAR_FIELD(MaxV, clUVSurfaceGenerator, MaxV)

   REGISTER_PROPERTY__SCALAR_FIELD(GlueUEdges, clUVSurfaceGenerator, GlueUEdges)

   REGISTER_PROPERTY__SCALAR_FIELD(GlueVEdges, clUVSurfaceGenerator, GlueVEdges)

   REGISTER_PROPERTY__SCALAR_FIELD(NumU, clUVSurfaceGenerator, NumU)

   REGISTER_PROPERTY__SCALAR_FIELD(NumV, clUVSurfaceGenerator, NumV)

   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/Resources/VFW.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: iVideoDecoder
            // Adding abstract: GetMaxFrames
            // Adding abstract: ExtractFrame
            // Adding abstract: GetFrameSeconds
            // Adding abstract: GetWidth
            // Adding abstract: GetHeight
            // Adding abstract: OpenStream
         // Class: clVFWVideoDecoder
            // Overriding abstract: GetMaxFrames
            // Overriding abstract: ExtractFrame
            // Overriding abstract: GetFrameSeconds
            // Overriding abstract: GetWidth
            // Overriding abstract: GetHeight
            // Overriding abstract: OpenStream

void RegisterPackageLinderdaumCoreClass231(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clVFWVideoDecoder>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clVFWVideoDecoder,Mtd)
   _RM__(GetMaxFrames)
   _RM__(ExtractFrame)
   _RM__(GetFrameSeconds)
   _RM__(GetWidth)
   _RM__(GetHeight)
   _RM__(OpenStream)
   #undef _RM__
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iVideoDecoder" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: iVideoEncoder
            // Adding abstract: AddVideoFrame
            // Adding abstract: CreateStream
         // Class: clVFWVideoEncoder
            // Overriding abstract: AddVideoFrame
            // Overriding abstract: CreateStream

void RegisterPackageLinderdaumCoreClass232(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clVFWVideoEncoder>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   REG_CLS_MTD( clVFWVideoEncoder,AddVideoFrame )
   REG_CLS_MTD( clVFWVideoEncoder,CreateStream )
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iVideoEncoder" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "clValidator_Tunneller.h"

void RegisterPackageLinderdaumCoreClass233(sEnvironment* Env)
{
#if !defined(_DISABLE_TUNNELLERS_)
   iStaticClass* StaticClass = new clNativeStaticClass<clValidator_Tunneller>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   REG_CLS_MTD( clValidator,IsValid )
   REG_CLS_MTD( clValidator,SetMaxLength )
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
#endif // _DISABLE_TUNNELLERS_
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clValidator

void RegisterPackageLinderdaumCoreClass234(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clValidator>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   REG_CLS_MTD( clValidator,IsValid )
   REG_CLS_MTD( clValidator,SetMaxLength )
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/Utils/Viewport.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clViewport


void RegisterPackageLinderdaumCoreClass235(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass9<clViewport, const LString&, LWindowHandle, const LString&, int, int, bool, bool, bool, bool>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clViewport,Mtd)
   _RM__(AfterConstruction)
   _RM__(GetMouseCursorInfo)
   _RM__(GetWidth)
   _RM__(GetHeight)
   _RM__(GetAspectRatio)
   _RM__(GetTop)
   _RM__(GetLeft)
   _RM__(IsLandscape)
   _RM__(IsPortrait)
   _RM__(SetViewportTitle)
   _RM__(SetMousePosition)
   _RM__(GetMousePosition)
   _RM__(MoveMouse)
   _RM__(TransformPointerPosition)
   _RM__(ShowOSMouseCursor)
   _RM__(HideOSMouseCursor)
   _RM__(UpdateTrackball)
   _RM__(MousePositionIntToFloat)
   _RM__(SetViewportSize)
   _RM__(BlitBitmap)
   _RM__(DrawLine)
   _RM__(DrawText)
   _RM__(Clear)
   _RM__(DispatchEvents)
   _RM__(SwapBuffers)
   _RM__(GetDevice)
   _RM__(GetWindow)
   #undef _RM__
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/VisualScene/VisualProjector.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clVisualObject
         // Class: clVisualProjector
         // Class: clVisualLight
         // Class: clVisualDirectionalLight
         // Class: clVisualCSMDirectionalLight

void RegisterPackageLinderdaumCoreClass236(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clVisualCSMDirectionalLight>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "clVisualDirectionalLight" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/VisualScene/VisualCamera.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clVisualObject
         // Class: clVisualProjector
         // Class: clVisualCamera

void RegisterPackageLinderdaumCoreClass237(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clVisualCamera>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clVisualCamera,Mtd)
   _RM__(RenderDebug)
   _RM__(SetTransform)
   _RM__(GetTransform)
   _RM__(Update)
   #undef _RM__
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "clVisualProjector" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clVisualObject
         // Class: clVisualRenderable
         // Class: clVisualCurve

void RegisterPackageLinderdaumCoreClass238(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clVisualCurve>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   REG_CLS_MTD( clVisualCurve,AddGeometry )
   REG_CLS_MTD( clVisualCurve,RemoveGeometry )
   REG_CLS_MTD( clVisualCurve,RenderDebug )
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "clVisualRenderable" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clVisualObject
         // Class: clVisualRenderable
         // Class: clVisualDebugItem
         // Class: clVisualDebugBox

void RegisterPackageLinderdaumCoreClass239(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clVisualDebugBox>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   REG_CLS_MTD( clVisualDebugBox,RenderDebug )
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "clVisualDebugItem" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clVisualObject
         // Class: clVisualRenderable
         // Class: clVisualDebugItem
// SCALAR_PROPERTY_LOAD__FIELD
// Color
// FColor
// clVisualDebugItem
// FColor
// LStr::StrToVec4

bool LoadScalarField_clVisualDebugItem_FColor_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clVisualDebugItem*>(Obj))->FColor=LStr::StrToVec4( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// Color
// FColor
// clVisualDebugItem
// FColor
// LStr::Vec4ToStr

bool SaveScalarField_clVisualDebugItem_FColor_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::Vec4ToStr(dynamic_cast<clVisualDebugItem*>(Obj)->FColor); 
   *Result = new mlNode("Color" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}




void RegisterPackageLinderdaumCoreClass240(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clVisualDebugItem>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
#endif // _DISABLE_METHODS_
   REGISTER_PROPERTY__SCALAR_FIELD(FColor, clVisualDebugItem, Color)

   StaticClass->SetSuperClassName( "clVisualRenderable" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clVisualObject
         // Class: clVisualRenderable
         // Class: clVisualDebugItem
         // Class: clVisualDebugPlane

void RegisterPackageLinderdaumCoreClass241(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clVisualDebugPlane>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   REG_CLS_MTD( clVisualDebugPlane,RenderDebug )
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "clVisualDebugItem" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clVisualObject
         // Class: clVisualProjector
         // Class: clVisualLight
         // Class: clVisualDirectionalLight

void RegisterPackageLinderdaumCoreClass242(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clVisualDirectionalLight>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clVisualDirectionalLight,Mtd)
   _RM__(AddToScene)
   _RM__(RemoveFromScene)
   _RM__(SyncWithScene)
   _RM__(GetDebugMeshName)
   #undef _RM__
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "clVisualLight" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clVisualObject
         // Class: clVisualRenderable
         // Class: clVisualGeom
         // Class: clVisualGenerator
// OBJECT_PROPERTY_LOAD__FIELD
// Generator
// FGenerator
// clVisualGenerator
// FGenerator

bool LoadObjectField_clVisualGenerator_FGenerator_FIELD(mlNode* Node, iObject* Obj) 
{
   iObject** Ptr = reinterpret_cast<iObject**>(&(dynamic_cast<clVisualGenerator*>(Obj)->FGenerator)); 
   *Ptr = NULL;   
   return Obj->Env->Linker->LoadObject(Node, Ptr);
}

// OBJECT_PROPERTY_SAVE__FIELD
// Generator
// FGenerator
// clVisualGenerator
// FGenerator

bool SaveObjectField_clVisualGenerator_FGenerator_FIELD(iObject* Obj, mlNode** Result) 
{ 
  clVisualGenerator* Object = dynamic_cast<clVisualGenerator*>(Obj); 
   if ( Object->FGenerator== NULL ) 
   { 
      *Result = new mlNode("Object", "NULL"); 
      return true; 
   } 
   if (!(Object->FGenerator)->Save( Result )) return false; 
   (*Result)->setID("Generator"); 
   return true; 
}




void RegisterPackageLinderdaumCoreClass243(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clVisualGenerator>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clVisualGenerator,Mtd)
   _RM__(RegenerateSurface)
   _RM__(AddGeometry)
   _RM__(RemoveGeometry)
   _RM__(RenderDebug)
   #undef _RM__
#endif // _DISABLE_METHODS_
   REGISTER_PROPERTY__OBJECT_FIELD(FGenerator, clVisualGenerator, Generator)

   StaticClass->SetSuperClassName( "clVisualGeom" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clVisualObject
         // Class: clVisualRenderable
         // Class: clVisualGeom
// SCALAR_PROPERTY_LOAD__SETTER
// Material
// ""
// clVisualGeom
// SetMaterialName
// EMPTY_CONVERTER

bool LoadScalarField_clVisualGeom_Material_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clVisualGeom*>(Obj))->SetMaterialName(EMPTY_CONVERTER( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Material
// ""
// clVisualGeom
// GetMaterialName
// EMPTY_CONVERTER

bool SaveScalarField_clVisualGeom_Material_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =EMPTY_CONVERTER(dynamic_cast<clVisualGeom*>(Obj)->GetMaterialName() ); 
   *Result = new mlNode("Material" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}




void RegisterPackageLinderdaumCoreClass244(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clVisualGeom>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clVisualGeom,Mtd)
   _RM__(SetGeom)
   _RM__(UpdateMaterial)
   _RM__(UpdateGeom)
   _RM__(SetMaterial)
   _RM__(GetMaterial)
   _RM__(SetTransform)
   _RM__(GetTransform)
   _RM__(SetAnimation)
   _RM__(SetAnimationSpeed)
   _RM__(GetMaterialName)
   _RM__(SetMaterialName)
   _RM__(AddGeometry)
   _RM__(RemoveGeometry)
   _RM__(IntersectsWithRay)
   _RM__(UpdateTransform)
   #undef _RM__
#endif // _DISABLE_METHODS_
   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Material, clVisualGeom, Material)

   StaticClass->SetSuperClassName( "clVisualRenderable" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/VisualScene/VisualGraph.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clVisualObject
         // Class: clVisualRenderable
         // Class: clVisualGraph
// OBJECT_PROPERTY_LOAD__FIELD
// Graph
// FGraph
// clVisualGraph
// FGraph

bool LoadObjectField_clVisualGraph_FGraph_FIELD(mlNode* Node, iObject* Obj) 
{
   iObject** Ptr = reinterpret_cast<iObject**>(&(dynamic_cast<clVisualGraph*>(Obj)->FGraph)); 
   *Ptr = NULL;   
   return Obj->Env->Linker->LoadObject(Node, Ptr);
}

// OBJECT_PROPERTY_SAVE__FIELD
// Graph
// FGraph
// clVisualGraph
// FGraph

bool SaveObjectField_clVisualGraph_FGraph_FIELD(iObject* Obj, mlNode** Result) 
{ 
  clVisualGraph* Object = dynamic_cast<clVisualGraph*>(Obj); 
   if ( Object->FGraph== NULL ) 
   { 
      *Result = new mlNode("Object", "NULL"); 
      return true; 
   } 
   if (!(Object->FGraph)->Save( Result )) return false; 
   (*Result)->setID("Graph"); 
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// BeadRadius
// FBeadRadius
// clVisualGraph
// FBeadRadius
// LStr::ToFloat

bool LoadScalarField_clVisualGraph_FBeadRadius_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clVisualGraph*>(Obj))->FBeadRadius=LStr::ToFloat( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// BeadRadius
// FBeadRadius
// clVisualGraph
// FBeadRadius
// LStr::ToStrEpsilon

bool SaveScalarField_clVisualGraph_FBeadRadius_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<clVisualGraph*>(Obj)->FBeadRadius); 
   *Result = new mlNode("BeadRadius" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// StickRadius
// FStickRadius
// clVisualGraph
// FStickRadius
// LStr::ToFloat

bool LoadScalarField_clVisualGraph_FStickRadius_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clVisualGraph*>(Obj))->FStickRadius=LStr::ToFloat( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// StickRadius
// FStickRadius
// clVisualGraph
// FStickRadius
// LStr::ToStrEpsilon

bool SaveScalarField_clVisualGraph_FStickRadius_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<clVisualGraph*>(Obj)->FStickRadius); 
   *Result = new mlNode("StickRadius" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// ArrowSize
// FArrowSize
// clVisualGraph
// FArrowSize
// LStr::ToFloat

bool LoadScalarField_clVisualGraph_FArrowSize_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clVisualGraph*>(Obj))->FArrowSize=LStr::ToFloat( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// ArrowSize
// FArrowSize
// clVisualGraph
// FArrowSize
// LStr::ToStrEpsilon

bool SaveScalarField_clVisualGraph_FArrowSize_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<clVisualGraph*>(Obj)->FArrowSize); 
   *Result = new mlNode("ArrowSize" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// UseCubes
// FUseCubes
// clVisualGraph
// FUseCubes
// LStr::ToBool

bool LoadScalarField_clVisualGraph_FUseCubes_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clVisualGraph*>(Obj))->FUseCubes=LStr::ToBool( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// UseCubes
// FUseCubes
// clVisualGraph
// FUseCubes
// LStr::ToStr_Bool

bool SaveScalarField_clVisualGraph_FUseCubes_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStr_Bool(dynamic_cast<clVisualGraph*>(Obj)->FUseCubes); 
   *Result = new mlNode("UseCubes" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// BeadMaterial
// ""
// clVisualGraph
// SetBeadMaterialName
// EMPTY_CONVERTER

bool LoadScalarField_clVisualGraph_BeadMaterial_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clVisualGraph*>(Obj))->SetBeadMaterialName(EMPTY_CONVERTER( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// BeadMaterial
// ""
// clVisualGraph
// GetBeadMaterialName
// EMPTY_CONVERTER

bool SaveScalarField_clVisualGraph_BeadMaterial_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =EMPTY_CONVERTER(dynamic_cast<clVisualGraph*>(Obj)->GetBeadMaterialName() ); 
   *Result = new mlNode("BeadMaterial" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// StickMaterial
// ""
// clVisualGraph
// SetStickMaterialName
// EMPTY_CONVERTER

bool LoadScalarField_clVisualGraph_StickMaterial_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clVisualGraph*>(Obj))->SetStickMaterialName(EMPTY_CONVERTER( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// StickMaterial
// ""
// clVisualGraph
// GetStickMaterialName
// EMPTY_CONVERTER

bool SaveScalarField_clVisualGraph_StickMaterial_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =EMPTY_CONVERTER(dynamic_cast<clVisualGraph*>(Obj)->GetStickMaterialName() ); 
   *Result = new mlNode("StickMaterial" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// ArrowMaterial
// ""
// clVisualGraph
// SetArrowMaterialName
// EMPTY_CONVERTER

bool LoadScalarField_clVisualGraph_ArrowMaterial_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clVisualGraph*>(Obj))->SetArrowMaterialName(EMPTY_CONVERTER( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// ArrowMaterial
// ""
// clVisualGraph
// GetArrowMaterialName
// EMPTY_CONVERTER

bool SaveScalarField_clVisualGraph_ArrowMaterial_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =EMPTY_CONVERTER(dynamic_cast<clVisualGraph*>(Obj)->GetArrowMaterialName() ); 
   *Result = new mlNode("ArrowMaterial" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}




void RegisterPackageLinderdaumCoreClass245(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clVisualGraph>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clVisualGraph,Mtd)
   _RM__(AddDebugGeometry)
   _RM__(RemoveDebugGeometry)
   _RM__(RefreshDebugGeometry)
   _RM__(UpdateTransform)
   _RM__(GetGraph)
   _RM__(SetGraph)
   _RM__(SetBeadMaterialName)
   _RM__(SetStickMaterialName)
   _RM__(SetArrowMaterialName)
   _RM__(GetBeadMaterialName)
   _RM__(GetStickMaterialName)
   _RM__(GetArrowMaterialName)
   #undef _RM__
#endif // _DISABLE_METHODS_
   REGISTER_PROPERTY__OBJECT_FIELD(FGraph, clVisualGraph, Graph)

   REGISTER_PROPERTY__SCALAR_FIELD(FBeadRadius, clVisualGraph, BeadRadius)

   REGISTER_PROPERTY__SCALAR_FIELD(FStickRadius, clVisualGraph, StickRadius)

   REGISTER_PROPERTY__SCALAR_FIELD(FArrowSize, clVisualGraph, ArrowSize)

   REGISTER_PROPERTY__SCALAR_FIELD(FUseCubes, clVisualGraph, UseCubes)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(BeadMaterial, clVisualGraph, BeadMaterial)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(StickMaterial, clVisualGraph, StickMaterial)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(ArrowMaterial, clVisualGraph, ArrowMaterial)

   StaticClass->SetSuperClassName( "clVisualRenderable" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clVisualObject
         // Class: clVisualProjector
         // Class: clVisualLight
// SCALAR_PROPERTY_LOAD__SETTER
// LightEnabled
// ""
// clVisualLight
// SetEnabled
// LStr::ToBool

bool LoadScalarField_clVisualLight_LightEnabled_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clVisualLight*>(Obj))->SetEnabled(LStr::ToBool( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// LightEnabled
// ""
// clVisualLight
// GetEnabled
// LStr::ToStr_Bool

bool SaveScalarField_clVisualLight_LightEnabled_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::ToStr_Bool(dynamic_cast<clVisualLight*>(Obj)->GetEnabled() ); 
   *Result = new mlNode("LightEnabled" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// AmbientColor
// ""
// clVisualLight
// SetAmbientColor
// LStr::StrToVec4

bool LoadScalarField_clVisualLight_AmbientColor_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clVisualLight*>(Obj))->SetAmbientColor(LStr::StrToVec4( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// AmbientColor
// ""
// clVisualLight
// GetAmbientColor
// LStr::Vec4ToStr

bool SaveScalarField_clVisualLight_AmbientColor_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::Vec4ToStr(dynamic_cast<clVisualLight*>(Obj)->GetAmbientColor() ); 
   *Result = new mlNode("AmbientColor" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// DiffuseColor
// ""
// clVisualLight
// SetDiffuseColor
// LStr::StrToVec4

bool LoadScalarField_clVisualLight_DiffuseColor_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clVisualLight*>(Obj))->SetDiffuseColor(LStr::StrToVec4( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// DiffuseColor
// ""
// clVisualLight
// GetDiffuseColor
// LStr::Vec4ToStr

bool SaveScalarField_clVisualLight_DiffuseColor_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::Vec4ToStr(dynamic_cast<clVisualLight*>(Obj)->GetDiffuseColor() ); 
   *Result = new mlNode("DiffuseColor" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// SpecularColor
// ""
// clVisualLight
// SetSpecularColor
// LStr::StrToVec4

bool LoadScalarField_clVisualLight_SpecularColor_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clVisualLight*>(Obj))->SetSpecularColor(LStr::StrToVec4( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// SpecularColor
// ""
// clVisualLight
// GetSpecularColor
// LStr::Vec4ToStr

bool SaveScalarField_clVisualLight_SpecularColor_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::Vec4ToStr(dynamic_cast<clVisualLight*>(Obj)->GetSpecularColor() ); 
   *Result = new mlNode("SpecularColor" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// Attenuations
// ""
// clVisualLight
// SetAttenuations
// LStr::StrToVec3

bool LoadScalarField_clVisualLight_Attenuations_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clVisualLight*>(Obj))->SetAttenuations(LStr::StrToVec3( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Attenuations
// ""
// clVisualLight
// GetAttenuations
// LStr::Vec3ToStr

bool SaveScalarField_clVisualLight_Attenuations_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::Vec3ToStr(dynamic_cast<clVisualLight*>(Obj)->GetAttenuations() ); 
   *Result = new mlNode("Attenuations" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}




void RegisterPackageLinderdaumCoreClass246(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clVisualLight>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clVisualLight,Mtd)
   _RM__(SyncWithScene)
   _RM__(GetEnabled)
   _RM__(GetAmbientColor)
   _RM__(GetDiffuseColor)
   _RM__(GetSpecularColor)
   _RM__(GetAttenuations)
   _RM__(SetEnabled)
   _RM__(SetAmbientColor)
   _RM__(SetDiffuseColor)
   _RM__(SetSpecularColor)
   _RM__(SetAttenuations)
   _RM__(UpdateTransform)
   _RM__(UpdateLight)
   #undef _RM__
#endif // _DISABLE_METHODS_
   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(LightEnabled, clVisualLight, LightEnabled)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(AmbientColor, clVisualLight, AmbientColor)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(DiffuseColor, clVisualLight, DiffuseColor)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(SpecularColor, clVisualLight, SpecularColor)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Attenuations, clVisualLight, Attenuations)

   StaticClass->SetSuperClassName( "clVisualProjector" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clVisualObject
         // Class: clVisualRenderable
         // Class: clVisualGeom
         // Class: clVisualMesh
// SCALAR_PROPERTY_LOAD__SETTER
// Mesh
// ""
// clVisualMesh
// SetMesh
// EMPTY_CONVERTER

bool LoadScalarField_clVisualMesh_Mesh_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clVisualMesh*>(Obj))->SetMesh(EMPTY_CONVERTER( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Mesh
// ""
// clVisualMesh
// GetMesh
// EMPTY_CONVERTER

bool SaveScalarField_clVisualMesh_Mesh_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =EMPTY_CONVERTER(dynamic_cast<clVisualMesh*>(Obj)->GetMesh() ); 
   *Result = new mlNode("Mesh" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}




void RegisterPackageLinderdaumCoreClass247(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clVisualMesh>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   REG_CLS_MTD( clVisualMesh,GetMesh )
   REG_CLS_MTD( clVisualMesh,SetMesh )
#endif // _DISABLE_METHODS_
   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Mesh, clVisualMesh, Mesh)

   StaticClass->SetSuperClassName( "clVisualGeom" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/VisualScene/VisualModifier.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clVisualObject
         // Class: clVisualModifier

void RegisterPackageLinderdaumCoreClass248(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clVisualModifier>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "clVisualObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/VisualScene/VisualObject.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clVisualObject
// SCALAR_PROPERTY_LOAD__SETTER
// Position
// ""
// clVisualObject
// SetPosition
// LStr::StrToVec3

bool LoadScalarField_clVisualObject_Position_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clVisualObject*>(Obj))->SetPosition(LStr::StrToVec3( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Position
// ""
// clVisualObject
// GetPosition
// LStr::Vec3ToStr

bool SaveScalarField_clVisualObject_Position_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::Vec3ToStr(dynamic_cast<clVisualObject*>(Obj)->GetPosition() ); 
   *Result = new mlNode("Position" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// Angles
// ""
// clVisualObject
// SetAngles
// LStr::StrToVec3

bool LoadScalarField_clVisualObject_Angles_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clVisualObject*>(Obj))->SetAngles(LStr::StrToVec3( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Angles
// ""
// clVisualObject
// GetAngles
// LStr::Vec3ToStr

bool SaveScalarField_clVisualObject_Angles_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::Vec3ToStr(dynamic_cast<clVisualObject*>(Obj)->GetAngles() ); 
   *Result = new mlNode("Angles" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}




void RegisterPackageLinderdaumCoreClass249(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clVisualObject>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clVisualObject,Mtd)
   _RM__(BeginLoad)
   _RM__(EndLoad)
   _RM__(AddToScene)
   _RM__(RemoveFromScene)
   _RM__(AddDebugGeometry)
   _RM__(RemoveDebugGeometry)
   _RM__(AddGeometry)
   _RM__(RemoveGeometry)
   _RM__(SetScene)
   _RM__(RenderDebug)
   _RM__(RenderAuxBuffers)
   _RM__(Refresh)
   _RM__(Update)
   _RM__(MakeLocalRotation)
   _RM__(MakeGlobalTranform)
   _RM__(SetTransform)
   _RM__(GetTransform)
   _RM__(SetAngles)
   _RM__(GetAngles)
   _RM__(SetPosition)
   _RM__(GetPosition)
   _RM__(SetAngleSystem)
   _RM__(GetAngleSystem)
   _RM__(UpdateTransform)
   _RM__(IntersectsWithRay)
   _RM__(SetBoundingRadius)
   _RM__(GetBoundingRadius)
   #undef _RM__
#endif // _DISABLE_METHODS_
   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Position, clVisualObject, Position)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Angles, clVisualObject, Angles)

   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clVisualObject
         // Class: clVisualRenderable
         // Class: clVisualParticles

void RegisterPackageLinderdaumCoreClass250(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clVisualParticles>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "clVisualRenderable" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clVisualObject
         // Class: clVisualProjector
         // Class: clVisualLight
         // Class: clVisualPointLight

void RegisterPackageLinderdaumCoreClass251(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clVisualPointLight>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clVisualPointLight,Mtd)
   _RM__(AddToScene)
   _RM__(RemoveFromScene)
   _RM__(SyncWithScene)
   _RM__(GetDebugMeshName)
   #undef _RM__
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "clVisualLight" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clVisualObject
         // Class: clVisualProjector
// SCALAR_PROPERTY_LOAD__FIELD
// UseTarget
// FUseTarget
// clVisualProjector
// FUseTarget
// LStr::ToBool

bool LoadScalarField_clVisualProjector_FUseTarget_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clVisualProjector*>(Obj))->FUseTarget=LStr::ToBool( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// UseTarget
// FUseTarget
// clVisualProjector
// FUseTarget
// LStr::ToStr_Bool

bool SaveScalarField_clVisualProjector_FUseTarget_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::ToStr_Bool(dynamic_cast<clVisualProjector*>(Obj)->FUseTarget); 
   *Result = new mlNode("UseTarget" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// Up
// FUpVector
// clVisualProjector
// FUpVector
// LStr::StrToVec3

bool LoadScalarField_clVisualProjector_FUpVector_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clVisualProjector*>(Obj))->FUpVector=LStr::StrToVec3( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// Up
// FUpVector
// clVisualProjector
// FUpVector
// LStr::Vec3ToStr

bool SaveScalarField_clVisualProjector_FUpVector_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::Vec3ToStr(dynamic_cast<clVisualProjector*>(Obj)->FUpVector); 
   *Result = new mlNode("Up" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__FIELD
// Side
// FSideVector
// clVisualProjector
// FSideVector
// LStr::StrToVec3

bool LoadScalarField_clVisualProjector_FSideVector_FIELD(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clVisualProjector*>(Obj))->FSideVector=LStr::StrToVec3( Node->getValue() );
   return true; 
}

// SCALAR_PROPERTY_SAVE__FIELD
// Side
// FSideVector
// clVisualProjector
// FSideVector
// LStr::Vec3ToStr

bool SaveScalarField_clVisualProjector_FSideVector_FIELD(iObject* Obj, mlNode** Result) 
{  
   LString Value =LStr::Vec3ToStr(dynamic_cast<clVisualProjector*>(Obj)->FSideVector); 
   *Result = new mlNode("Side" , Value); 
   /* *Result->setValue( Value );*/   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// Target
// ""
// clVisualProjector
// SetTarget
// LStr::StrToVec3

bool LoadScalarField_clVisualProjector_Target_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clVisualProjector*>(Obj))->SetTarget(LStr::StrToVec3( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Target
// ""
// clVisualProjector
// GetTarget
// LStr::Vec3ToStr

bool SaveScalarField_clVisualProjector_Target_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::Vec3ToStr(dynamic_cast<clVisualProjector*>(Obj)->GetTarget() ); 
   *Result = new mlNode("Target" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// Direction
// ""
// clVisualProjector
// SetDirection
// LStr::StrToVec3

bool LoadScalarField_clVisualProjector_Direction_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clVisualProjector*>(Obj))->SetDirection(LStr::StrToVec3( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Direction
// ""
// clVisualProjector
// GetDirection
// LStr::Vec3ToStr

bool SaveScalarField_clVisualProjector_Direction_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::Vec3ToStr(dynamic_cast<clVisualProjector*>(Obj)->GetDirection() ); 
   *Result = new mlNode("Direction" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// DistanceToTarget
// ""
// clVisualProjector
// SetDistanceToTarget
// LStr::ToFloat

bool LoadScalarField_clVisualProjector_DistanceToTarget_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clVisualProjector*>(Obj))->SetDistanceToTarget(LStr::ToFloat( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// DistanceToTarget
// ""
// clVisualProjector
// GetDistanceToTarget
// LStr::ToStrEpsilon

bool SaveScalarField_clVisualProjector_DistanceToTarget_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<clVisualProjector*>(Obj)->GetDistanceToTarget() ); 
   *Result = new mlNode("DistanceToTarget" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// Projection
// ""
// clVisualProjector
// SetProjection
// LStr::StrToMtx4

bool LoadScalarField_clVisualProjector_Projection_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clVisualProjector*>(Obj))->SetProjection(LStr::StrToMtx4( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Projection
// ""
// clVisualProjector
// GetProjection
// LStr::Mat4ToStr

bool SaveScalarField_clVisualProjector_Projection_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::Mat4ToStr(dynamic_cast<clVisualProjector*>(Obj)->GetProjection() ); 
   *Result = new mlNode("Projection" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// ProjectionType
// ""
// clVisualProjector
// SetProjectionType
// LStr::StrToProjectionType

bool LoadScalarField_clVisualProjector_ProjectionType_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clVisualProjector*>(Obj))->SetProjectionType(LStr::StrToProjectionType( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// ProjectionType
// ""
// clVisualProjector
// GetProjectionType
// LStr::ProjectionTypeToStr

bool SaveScalarField_clVisualProjector_ProjectionType_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::ProjectionTypeToStr(dynamic_cast<clVisualProjector*>(Obj)->GetProjectionType() ); 
   *Result = new mlNode("ProjectionType" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// Left
// ""
// clVisualProjector
// SetLeft_Internal
// LStr::ToFloat

bool LoadScalarField_clVisualProjector_Left_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clVisualProjector*>(Obj))->SetLeft_Internal(LStr::ToFloat( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Left
// ""
// clVisualProjector
// GetLeft_Internal
// LStr::ToStrEpsilon

bool SaveScalarField_clVisualProjector_Left_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<clVisualProjector*>(Obj)->GetLeft_Internal() ); 
   *Result = new mlNode("Left" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// Right
// ""
// clVisualProjector
// SetRight_Internal
// LStr::ToFloat

bool LoadScalarField_clVisualProjector_Right_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clVisualProjector*>(Obj))->SetRight_Internal(LStr::ToFloat( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Right
// ""
// clVisualProjector
// GetRight_Internal
// LStr::ToStrEpsilon

bool SaveScalarField_clVisualProjector_Right_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<clVisualProjector*>(Obj)->GetRight_Internal() ); 
   *Result = new mlNode("Right" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// Bottom
// ""
// clVisualProjector
// SetBottom_Internal
// LStr::ToFloat

bool LoadScalarField_clVisualProjector_Bottom_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clVisualProjector*>(Obj))->SetBottom_Internal(LStr::ToFloat( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Bottom
// ""
// clVisualProjector
// GetBottom_Internal
// LStr::ToStrEpsilon

bool SaveScalarField_clVisualProjector_Bottom_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<clVisualProjector*>(Obj)->GetBottom_Internal() ); 
   *Result = new mlNode("Bottom" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// Top
// ""
// clVisualProjector
// SetTop_Internal
// LStr::ToFloat

bool LoadScalarField_clVisualProjector_Top_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clVisualProjector*>(Obj))->SetTop_Internal(LStr::ToFloat( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Top
// ""
// clVisualProjector
// GetTop_Internal
// LStr::ToStrEpsilon

bool SaveScalarField_clVisualProjector_Top_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<clVisualProjector*>(Obj)->GetTop_Internal() ); 
   *Result = new mlNode("Top" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// Far
// ""
// clVisualProjector
// SetFar_Internal
// LStr::ToFloat

bool LoadScalarField_clVisualProjector_Far_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clVisualProjector*>(Obj))->SetFar_Internal(LStr::ToFloat( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Far
// ""
// clVisualProjector
// GetFar_Internal
// LStr::ToStrEpsilon

bool SaveScalarField_clVisualProjector_Far_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<clVisualProjector*>(Obj)->GetFar_Internal() ); 
   *Result = new mlNode("Far" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// Near
// ""
// clVisualProjector
// SetNear_Internal
// LStr::ToFloat

bool LoadScalarField_clVisualProjector_Near_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clVisualProjector*>(Obj))->SetNear_Internal(LStr::ToFloat( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Near
// ""
// clVisualProjector
// GetNear_Internal
// LStr::ToStrEpsilon

bool SaveScalarField_clVisualProjector_Near_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<clVisualProjector*>(Obj)->GetNear_Internal() ); 
   *Result = new mlNode("Near" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// Aspect
// ""
// clVisualProjector
// SetAspect_Internal
// LStr::ToFloat

bool LoadScalarField_clVisualProjector_Aspect_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clVisualProjector*>(Obj))->SetAspect_Internal(LStr::ToFloat( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// Aspect
// ""
// clVisualProjector
// GetAspect_Internal
// LStr::ToStrEpsilon

bool SaveScalarField_clVisualProjector_Aspect_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<clVisualProjector*>(Obj)->GetAspect_Internal() ); 
   *Result = new mlNode("Aspect" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}


// SCALAR_PROPERTY_LOAD__SETTER
// FOV
// ""
// clVisualProjector
// SetFOV_Internal
// LStr::ToFloat

bool LoadScalarField_clVisualProjector_FOV_SETTER(mlNode* Node, iObject* Obj) 
{
   (dynamic_cast<clVisualProjector*>(Obj))->SetFOV_Internal(LStr::ToFloat( Node->getValue() ) );
   return true; 
}

// SCALAR_PROPERTY_SAVE__GETTER
// FOV
// ""
// clVisualProjector
// GetFOV_Internal
// LStr::ToStrEpsilon

bool SaveScalarField_clVisualProjector_FOV_GETTER(iObject* Obj, mlNode** Result)   
{  
   LString Value =LStr::ToStrEpsilon(dynamic_cast<clVisualProjector*>(Obj)->GetFOV_Internal() ); 
   *Result = new mlNode("FOV" , Value ); 
   /* *Result->setValue( Value ); */   
   return true; 
}




void RegisterPackageLinderdaumCoreClass252(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clVisualProjector>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clVisualProjector,Mtd)
   _RM__(AddDebugGeometry)
   _RM__(RemoveDebugGeometry)
   _RM__(GetDebugMeshName)
   _RM__(GetProjection)
   _RM__(SetProjection)
   _RM__(SetProjectionType)
   _RM__(GetProjectionType)
   _RM__(CalculateTransformFromDirUpTarget)
   _RM__(SetTransform)
   _RM__(SetAngles)
   _RM__(SetPosition)
   _RM__(SplitFrustum)
   _RM__(SplitMatrices)
   _RM__(CalculateCropMatrix)
   _RM__(RenderDebug)
   _RM__(Refresh)
   _RM__(SetPositioner)
   _RM__(Update)
   _RM__(UpdateProjection)
   #undef _RM__
#endif // _DISABLE_METHODS_
   REGISTER_PROPERTY__SCALAR_FIELD(FUseTarget, clVisualProjector, UseTarget)

   REGISTER_PROPERTY__SCALAR_FIELD(FUpVector, clVisualProjector, Up)

   REGISTER_PROPERTY__SCALAR_FIELD(FSideVector, clVisualProjector, Side)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Target, clVisualProjector, Target)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Direction, clVisualProjector, Direction)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(DistanceToTarget, clVisualProjector, DistanceToTarget)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Projection, clVisualProjector, Projection)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(ProjectionType, clVisualProjector, ProjectionType)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Left, clVisualProjector, Left)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Right, clVisualProjector, Right)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Bottom, clVisualProjector, Bottom)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Top, clVisualProjector, Top)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Far, clVisualProjector, Far)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Near, clVisualProjector, Near)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(Aspect, clVisualProjector, Aspect)

   REGISTER_PROPERTY__SCALAR_GETTER_SETTER(FOV, clVisualProjector, FOV)

   StaticClass->SetSuperClassName( "clVisualObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clVisualObject
         // Class: clVisualRenderable

void RegisterPackageLinderdaumCoreClass253(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clVisualRenderable>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   REG_CLS_MTD( clVisualRenderable,SetTransform )
   REG_CLS_MTD( clVisualRenderable,UpdateTransform )
#endif // _DISABLE_METHODS_
   StaticClass->SetSuperClassName( "clVisualObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#include "Linderdaum/VisualScene/VisualScene.h"
         // Class: iIntrusiveCounter
         // Class: iObject
         // Class: clVisualScene
// OBJECT_ARRAY_PROPERTY_LOAD__FIELD
// Cameras
// FCameras
// clVisualScene
// clVisualCamera

bool LoadObjectItem_clVisualScene_FCameras_FIELD(mlNode* Node, iObject* Obj, int i) 
{
   FIX_PARSER_DEFECT(RealNode, Node->children[i]) 
  clVisualCamera* Ptr = NULL; 
   bool Res = Obj->Env->Linker->LoadObject(RealNode, reinterpret_cast<iObject**>(&Ptr)); 
  clVisualScene* CastedObj = dynamic_cast<clVisualScene*>(Obj); 
   if ( Res ) CastedObj->FCameras[i] = Ptr; 
   return Res; 
}

// OBJECT_ARRAY_PROPERTY_SAVE__FIELD
// Cameras
// FCameras
// clVisualScene

bool SaveObjectItem_clVisualScene_FCameras_FIELD(iObject* Obj, int i, mlNode** Result) 
{
   return (dynamic_cast<clVisualScene*>(Obj)->FCameras[i])->Save(Result);
}


// ARRAY_PROPERTY_FUNCTIONS__FIELD
// FCameras
// clVisualScene

   ARRAY_PROPERTY_RESIZE_FUNCTION__FIELD(FCameras,clVisualScene) 
   ARRAY_PROPERTY_SIZE_FUNCTION__FIELD(FCameras,clVisualScene) 
   ARRAY_PROPERTY_CLEAR_FUNCTION__FIELD(FCameras,clVisualScene)


// ARRAY_PROPERTY_DELETE_FUNCTION__FIELD
// FCameras
// clVisualScene

void DeleteFunction_clVisualScene_FCameras_FIELD(iObject* Obj, int Resize) 
{ 
   int Size = SizeFunction_clVisualScene_FCameras_FIELD(Obj); 
   for (int i = 0 ; i < Size ; i++) 
   { 
      dynamic_cast<clVisualScene*>(Obj)->FCameras[i] ->DisposeObject(); 
   }
   dynamic_cast<clVisualScene*>(Obj)->FCameras.clear(); 
}



// OBJECT_ARRAY_PROPERTY_LOAD__FIELD
// Lights
// FLights
// clVisualScene
// clVisualLight

bool LoadObjectItem_clVisualScene_FLights_FIELD(mlNode* Node, iObject* Obj, int i) 
{
   FIX_PARSER_DEFECT(RealNode, Node->children[i]) 
  clVisualLight* Ptr = NULL; 
   bool Res = Obj->Env->Linker->LoadObject(RealNode, reinterpret_cast<iObject**>(&Ptr)); 
  clVisualScene* CastedObj = dynamic_cast<clVisualScene*>(Obj); 
   if ( Res ) CastedObj->FLights[i] = Ptr; 
   return Res; 
}

// OBJECT_ARRAY_PROPERTY_SAVE__FIELD
// Lights
// FLights
// clVisualScene

bool SaveObjectItem_clVisualScene_FLights_FIELD(iObject* Obj, int i, mlNode** Result) 
{
   return (dynamic_cast<clVisualScene*>(Obj)->FLights[i])->Save(Result);
}


// ARRAY_PROPERTY_FUNCTIONS__FIELD
// FLights
// clVisualScene

   ARRAY_PROPERTY_RESIZE_FUNCTION__FIELD(FLights,clVisualScene) 
   ARRAY_PROPERTY_SIZE_FUNCTION__FIELD(FLights,clVisualScene) 
   ARRAY_PROPERTY_CLEAR_FUNCTION__FIELD(FLights,clVisualScene)


// ARRAY_PROPERTY_DELETE_FUNCTION__FIELD
// FLights
// clVisualScene

void DeleteFunction_clVisualScene_FLights_FIELD(iObject* Obj, int Resize) 
{ 
   int Size = SizeFunction_clVisualScene_FLights_FIELD(Obj); 
   for (int i = 0 ; i < Size ; i++) 
   { 
      dynamic_cast<clVisualScene*>(Obj)->FLights[i] ->DisposeObject(); 
   }
   dynamic_cast<clVisualScene*>(Obj)->FLights.clear(); 
}



// OBJECT_ARRAY_PROPERTY_LOAD__FIELD
// Visuals
// FVisuals
// clVisualScene
// clVisualRenderable

bool LoadObjectItem_clVisualScene_FVisuals_FIELD(mlNode* Node, iObject* Obj, int i) 
{
   FIX_PARSER_DEFECT(RealNode, Node->children[i]) 
  clVisualRenderable* Ptr = NULL; 
   bool Res = Obj->Env->Linker->LoadObject(RealNode, reinterpret_cast<iObject**>(&Ptr)); 
  clVisualScene* CastedObj = dynamic_cast<clVisualScene*>(Obj); 
   if ( Res ) CastedObj->FVisuals[i] = Ptr; 
   return Res; 
}

// OBJECT_ARRAY_PROPERTY_SAVE__FIELD
// Visuals
// FVisuals
// clVisualScene

bool SaveObjectItem_clVisualScene_FVisuals_FIELD(iObject* Obj, int i, mlNode** Result) 
{
   return (dynamic_cast<clVisualScene*>(Obj)->FVisuals[i])->Save(Result);
}


// ARRAY_PROPERTY_FUNCTIONS__FIELD
// FVisuals
// clVisualScene

   ARRAY_PROPERTY_RESIZE_FUNCTION__FIELD(FVisuals,clVisualScene) 
   ARRAY_PROPERTY_SIZE_FUNCTION__FIELD(FVisuals,clVisualScene) 
   ARRAY_PROPERTY_CLEAR_FUNCTION__FIELD(FVisuals,clVisualScene)


// ARRAY_PROPERTY_DELETE_FUNCTION__FIELD
// FVisuals
// clVisualScene

void DeleteFunction_clVisualScene_FVisuals_FIELD(iObject* Obj, int Resize) 
{ 
   int Size = SizeFunction_clVisualScene_FVisuals_FIELD(Obj); 
   for (int i = 0 ; i < Size ; i++) 
   { 
      dynamic_cast<clVisualScene*>(Obj)->FVisuals[i] ->DisposeObject(); 
   }
   dynamic_cast<clVisualScene*>(Obj)->FVisuals.clear(); 
}



// OBJECT_ARRAY_PROPERTY_LOAD__FIELD
// Volumes
// FVolumes
// clVisualScene
// clVisualVolume

bool LoadObjectItem_clVisualScene_FVolumes_FIELD(mlNode* Node, iObject* Obj, int i) 
{
   FIX_PARSER_DEFECT(RealNode, Node->children[i]) 
  clVisualVolume* Ptr = NULL; 
   bool Res = Obj->Env->Linker->LoadObject(RealNode, reinterpret_cast<iObject**>(&Ptr)); 
  clVisualScene* CastedObj = dynamic_cast<clVisualScene*>(Obj); 
   if ( Res ) CastedObj->FVolumes[i] = Ptr; 
   return Res; 
}

// OBJECT_ARRAY_PROPERTY_SAVE__FIELD
// Volumes
// FVolumes
// clVisualScene

bool SaveObjectItem_clVisualScene_FVolumes_FIELD(iObject* Obj, int i, mlNode** Result) 
{
   return (dynamic_cast<clVisualScene*>(Obj)->FVolumes[i])->Save(Result);
}


// ARRAY_PROPERTY_FUNCTIONS__FIELD
// FVolumes
// clVisualScene

   ARRAY_PROPERTY_RESIZE_FUNCTION__FIELD(FVolumes,clVisualScene) 
   ARRAY_PROPERTY_SIZE_FUNCTION__FIELD(FVolumes,clVisualScene) 
   ARRAY_PROPERTY_CLEAR_FUNCTION__FIELD(FVolumes,clVisualScene)


// ARRAY_PROPERTY_DELETE_FUNCTION__FIELD
// FVolumes
// clVisualScene

void DeleteFunction_clVisualScene_FVolumes_FIELD(iObject* Obj, int Resize) 
{ 
   int Size = SizeFunction_clVisualScene_FVolumes_FIELD(Obj); 
   for (int i = 0 ; i < Size ; i++) 
   { 
      dynamic_cast<clVisualScene*>(Obj)->FVolumes[i] ->DisposeObject(); 
   }
   dynamic_cast<clVisualScene*>(Obj)->FVolumes.clear(); 
}



// OBJECT_ARRAY_PROPERTY_LOAD__FIELD
// Modifiers
// FModifiers
// clVisualScene
// clVisualModifier

bool LoadObjectItem_clVisualScene_FModifiers_FIELD(mlNode* Node, iObject* Obj, int i) 
{
   FIX_PARSER_DEFECT(RealNode, Node->children[i]) 
  clVisualModifier* Ptr = NULL; 
   bool Res = Obj->Env->Linker->LoadObject(RealNode, reinterpret_cast<iObject**>(&Ptr)); 
  clVisualScene* CastedObj = dynamic_cast<clVisualScene*>(Obj); 
   if ( Res ) CastedObj->FModifiers[i] = Ptr; 
   return Res; 
}

// OBJECT_ARRAY_PROPERTY_SAVE__FIELD
// Modifiers
// FModifiers
// clVisualScene

bool SaveObjectItem_clVisualScene_FModifiers_FIELD(iObject* Obj, int i, mlNode** Result) 
{
   return (dynamic_cast<clVisualScene*>(Obj)->FModifiers[i])->Save(Result);
}


// ARRAY_PROPERTY_FUNCTIONS__FIELD
// FModifiers
// clVisualScene

   ARRAY_PROPERTY_RESIZE_FUNCTION__FIELD(FModifiers,clVisualScene) 
   ARRAY_PROPERTY_SIZE_FUNCTION__FIELD(FModifiers,clVisualScene) 
   ARRAY_PROPERTY_CLEAR_FUNCTION__FIELD(FModifiers,clVisualScene)


// ARRAY_PROPERTY_DELETE_FUNCTION__FIELD
// FModifiers
// clVisualScene

void DeleteFunction_clVisualScene_FModifiers_FIELD(iObject* Obj, int Resize) 
{ 
   int Size = SizeFunction_clVisualScene_FModifiers_FIELD(Obj); 
   for (int i = 0 ; i < Size ; i++) 
   { 
      dynamic_cast<clVisualScene*>(Obj)->FModifiers[i] ->DisposeObject(); 
   }
   dynamic_cast<clVisualScene*>(Obj)->FModifiers.clear(); 
}



// OBJECT_ARRAY_PROPERTY_LOAD__FIELD
// Particles
// FParticles
// clVisualScene
// clVisualParticles

bool LoadObjectItem_clVisualScene_FParticles_FIELD(mlNode* Node, iObject* Obj, int i) 
{
   FIX_PARSER_DEFECT(RealNode, Node->children[i]) 
  clVisualParticles* Ptr = NULL; 
   bool Res = Obj->Env->Linker->LoadObject(RealNode, reinterpret_cast<iObject**>(&Ptr)); 
  clVisualScene* CastedObj = dynamic_cast<clVisualScene*>(Obj); 
   if ( Res ) CastedObj->FParticles[i] = Ptr; 
   return Res; 
}

// OBJECT_ARRAY_PROPERTY_SAVE__FIELD
// Particles
// FParticles
// clVisualScene

bool SaveObjectItem_clVisualScene_FParticles_FIELD(iObject* Obj, int i, mlNode** Result) 
{
   return (dynamic_cast<clVisualScene*>(Obj)->FParticles[i])->Save(Result);
}


// ARRAY_PROPERTY_FUNCTIONS__FIELD
// FParticles
// clVisualScene

   ARRAY_PROPERTY_RESIZE_FUNCTION__FIELD(FParticles,clVisualScene) 
   ARRAY_PROPERTY_SIZE_FUNCTION__FIELD(FParticles,clVisualScene) 
   ARRAY_PROPERTY_CLEAR_FUNCTION__FIELD(FParticles,clVisualScene)


// ARRAY_PROPERTY_DELETE_FUNCTION__FIELD
// FParticles
// clVisualScene

void DeleteFunction_clVisualScene_FParticles_FIELD(iObject* Obj, int Resize) 
{ 
   int Size = SizeFunction_clVisualScene_FParticles_FIELD(Obj); 
   for (int i = 0 ; i < Size ; i++) 
   { 
      dynamic_cast<clVisualScene*>(Obj)->FParticles[i] ->DisposeObject(); 
   }
   dynamic_cast<clVisualScene*>(Obj)->FParticles.clear(); 
}





void RegisterPackageLinderdaumCoreClass254(sEnvironment* Env)
{
   iStaticClass* StaticClass = new clNativeStaticClass<clVisualScene>;

   StaticClass->Env = Env;

#if !defined(_DISABLE_METHODS_)
   #define _RM__(Mtd) REG_CLS_MTD(clVisualScene,Mtd)
   _RM__(AfterConstruction)
   _RM__(Register)
   _RM__(Unregister)
   _RM__(BeginLoad)
   _RM__(EndLoad)
   _RM__(Clear)
   _RM__(GetLastError)
   _RM__(RenderDebug)
   _RM__(RenderAuxBuffers)
   _RM__(Render)
   _RM__(PickObject)
   _RM__(FindObject)
   _RM__(SetActiveCamera)
   _RM__(GetActiveCamera)
   _RM__(GetCurrentView)
   _RM__(GetCurrentProjection)
   _RM__(GetNumVolumes)
   _RM__(GetNumParticles)
   _RM__(GetNumCameras)
   _RM__(GetNumLights)
   _RM__(GetNumRenderables)
   _RM__(GetNumModifiers)
   _RM__(GetVolume)
   _RM__(GetParticles)
   _RM__(GetRenderable)
   _RM__(GetLight)
   _RM__(GetCamera)
   _RM__(GetModifier)
   _RM__(SetVolume)
   _RM__(SetParticles)
   _RM__(SetRenderable)
   _RM__(SetCamera)
   _RM__(SetLight)
   _RM__(SetModifier)
   _RM__(GetObjectIndex)
   _RM__(GetCameraIndex)
   _RM__(GetLightIndex)
   _RM__(GetRenderableIndex)
   _RM__(GetModifierIndex)
   _RM__(AddSpotLight)
   _RM__(AddPointLight)
   _RM__(AddDirectionalLight)
   _RM__(AddCamera)
   _RM__(AddGeom)
   _RM__(AddParticles)
   _RM__(AddModifier)
   _RM__(AddLight)
   _RM__(RemoveLight)
   _RM__(RemoveCamera)
   _RM__(RemoveRenderable)
   _RM__(RemoveGeom)
   _RM__(RemoveVolume)
   _RM__(RemoveParticles)
   _RM__(RemoveModifier)
   _RM__(AddTranslateGizmoPropMtx)
   _RM__(AddTranslateGizmoPropVec)
   _RM__(AddTranslateGizmoVarMtx)
   _RM__(AddTranslateGizmoVarVec)
   _RM__(AddRotateGizmoPropMtx)
   _RM__(AddRotateGizmoPropVec)
   _RM__(AddRotateGizmoPropQuat)
   _RM__(AddRotateGizmoVarMtx)
   _RM__(AddRotateGizmoVarVec)
   _RM__(AddRotateGizmoVarQuat)
   _RM__(AddSubObject)
   _RM__(RemoveSubObject)
   _RM__(ClearSubObjects)
   _RM__(GetTotalSubObjects)
   _RM__(GetObject)
   _RM__(GetObjectConst)
   _RM__(GetDebugScene)
   _RM__(GetScene)
   _RM__(Update)
   _RM__(HandleKey)
   _RM__(GetTechnique)
   #undef _RM__
#endif // _DISABLE_METHODS_
   REGISTER_PROPERTY__OBJECT_ARRAY_FIELD(FCameras, clVisualScene, Cameras)

   REGISTER_PROPERTY__OBJECT_ARRAY_FIELD(FLights, clVisualScene, Lights)

   REGISTER_PROPERTY__OBJECT_ARRAY_FIELD(FVisuals, clVisualScene, Visuals)

   REGISTER_PROPERTY__OBJECT_ARRAY_FIELD(FVolumes, clVisualScene, Volumes)

   REGISTER_PROPERTY__OBJECT_ARRAY_FIELD(FModifiers, clVisualScene, Modifiers)

   REGISTER_PROPERTY__OBJECT_ARRAY_FIELD(FParticles, clVisualScene, Particles)

   StaticClass->SetSuperClassName( "iObject" );

   Env->Linker->RegisterStaticClass( StaticClass );
}

#undef REG_CLS_MTD

/*
 * 16/01/2012
     Autogenerated via LinderScript Database Compiler 0.9.24
*/
