
// Autogenerated by GLExtractor 0.5.93 (GL3 mode) (C) Sergey Kosarevsky
// Part of Linderdaum Engine
// http://www.linderdaum.com

#include "LGL.h"
#include "LGLAPI.h"

#include "Engine.h"
#include "Utils/Library.h"

#ifdef OS_ANDROID
#include <android/log.h>
#define LOGI(...) ((void)__android_log_print(ANDROID_LOG_INFO, "native-activity", __VA_ARGS__))
#define LOGW(...) ((void)__android_log_print(ANDROID_LOG_WARN, "native-activity", __VA_ARGS__))
#else

#if defined(OS_LINUX)

typedef GLXContext ( *GLXCREATECONTEXTATTRIBSARBPROC )( Display*, GLXFBConfig, GLXContext, Bool, const int* );

#endif


#define LOGI(...)
#define LOGW(...)
#endif // OS_ANDROID

// sLGLAPI LGL3;

#if defined(OS_WINDOWS) || defined(OS_ANDROID)
//PFNwglGetProcAddress    lglGetProcAddress    = NULL;
#endif

#ifdef OS_WINDOWS
/*
PFNwglGetCurrentContext lglGetCurrentContext = NULL;

PFNwglCreateContext     lglCreateContext     = NULL;
PFNwglMakeCurrent       lglMakeCurrent       = NULL;
PFNwglDeleteContext     lglDeleteContext     = NULL;
*/
#else

#if defined(OS_LINUX) && !defined(OS_ANDROID)

//PFNglXGetProcAddress    lglGetProcAddress = NULL;

#endif

#endif

LString LGL::GetExtensionsString( sLGLAPI* LGL3 )
{
	LString Extensions( "" );

#if defined(USE_OPENGL_3)

	if ( LGL3->glGetStringi != NULL )
	{
		// GL3 functionality
		Lint NumExt = 0;

		LGL3->glGetIntegerv( GL_NUM_EXTENSIONS, &NumExt );

		for ( Lint i = 0; i != NumExt; i++ )
		{
			Extensions += LString( ( const char* )LGL3->glGetStringi( GL_EXTENSIONS, i ) ) + " ";
		}
	}
	else
#endif
	{
		if ( LGL3->glGetString != NULL )
		{
			// old functionality
			Extensions = reinterpret_cast<const char*>( LGL3->glGetString( GL_EXTENSIONS ) );
		}
	}

#ifdef OS_WINDOWS

	if ( LGL3->wglGetExtensionsStringARB )
	{
		//Extensions += LString(" ")+wglGetExtensionsStringARB( (HDC)lglGetCurrentContext() );
	}

#endif

	return Extensions;
}

bool LGL::IsExtensionSupported( sLGLAPI* LGL3, const LString& ExtName )
{
	return GetExtensionsString( LGL3 ).find( ExtName + " " ) != LString::npos;
}

#ifdef OS_WINDOWS
bool LGL::clGLExtRetriever::ChooseAndSetPixelFormat( sLGLAPI* LGL3, HDC DeviceContext, int BitsPerPixel, int ZBufferBits, int StencilBits, int Multisample )
{
	PIXELFORMATDESCRIPTOR PFD;

	memset( &PFD, 0, sizeof( PFD ) );

	PFD.nSize        = sizeof( PIXELFORMATDESCRIPTOR );
	PFD.nVersion     = 1;
	PFD.dwFlags      = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER;
	PFD.iPixelType   = PFD_TYPE_RGBA;
	PFD.cColorBits   = static_cast<BYTE>( BitsPerPixel & 0xFF );
	PFD.cDepthBits   = static_cast<BYTE>( ZBufferBits  & 0xFF );
	PFD.cStencilBits = static_cast<BYTE>( StencilBits  & 0xFF );
	PFD.iLayerType   = PFD_MAIN_PLANE;

	Lint PixelFormat = 0;

	if ( LGL3->wglChoosePixelFormatARB )
	{
		const int Attribs[] =
		{
			WGL_DRAW_TO_WINDOW_ARB,  GL_TRUE,
			WGL_SUPPORT_OPENGL_ARB,  GL_TRUE,
			WGL_ACCELERATION_ARB  ,  WGL_FULL_ACCELERATION_ARB,
			WGL_DOUBLE_BUFFER_ARB ,  GL_TRUE,
			WGL_PIXEL_TYPE_ARB    ,  WGL_TYPE_RGBA_ARB,
			WGL_COLOR_BITS_ARB    ,  BitsPerPixel,
			WGL_DEPTH_BITS_ARB    ,  ZBufferBits,
			WGL_STENCIL_BITS_ARB  ,  StencilBits,
			WGL_SAMPLE_BUFFERS_ARB,  GL_TRUE,
			WGL_SAMPLES_ARB       ,  Multisample,
			0 // end
		};

		Luint Count = 0;

		LGL3->wglChoosePixelFormatARB( DeviceContext, Attribs, NULL, 1, &PixelFormat, &Count );

		if ( !PixelFormat )
		{
			PixelFormat = ::ChoosePixelFormat( DeviceContext, &PFD );
		}

		return ::SetPixelFormat( DeviceContext, PixelFormat, NULL );
	}

	if ( !PixelFormat )
	{
		PixelFormat = ::ChoosePixelFormat( DeviceContext, &PFD );
	}

	return ::SetPixelFormat( DeviceContext, PixelFormat, &PFD );
}

HGLRC LGL::clGLExtRetriever::CreateContext( sLGLAPI* LGL3, HDC DeviceContext, int VersionMajor, int VersionMinor, bool DebugContext )
{
	HGLRC RenderContext = 0;

//   Reload( false );

	if ( LGL3->wglCreateContextAttribsARB )
	{
		const int Attribs[] =
		{
			WGL_CONTEXT_MAJOR_VERSION_ARB, VersionMajor,
			WGL_CONTEXT_MINOR_VERSION_ARB, VersionMinor,
			WGL_CONTEXT_LAYER_PLANE_ARB  , 0,
			WGL_CONTEXT_FLAGS_ARB        , WGL_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB | ( DebugContext ? WGL_CONTEXT_DEBUG_BIT_ARB : 0 ),
			WGL_CONTEXT_PROFILE_MASK_ARB , WGL_CONTEXT_CORE_PROFILE_BIT_ARB,
			0 // end
		};

		RenderContext = LGL3->wglCreateContextAttribsARB( DeviceContext, 0, Attribs );
	}
	else
	{
		RenderContext = LGL3->lglCreateContext( DeviceContext );
	}

	return RenderContext;
}

HGLRC LGL::clGLExtRetriever::CreateContextFull( sLGLAPI* LGL3, HDC DeviceContext, int BitsPerPixel, int ZBufferBits, int StencilBits, int Multisample, int VersionMajor, int VersionMinor, bool DebugContext )
{
	bool FormatSet = ChooseAndSetPixelFormat( LGL3, DeviceContext, BitsPerPixel, ZBufferBits, StencilBits, Multisample );

	if ( !FormatSet )
	{
		FError = "Can't set the pixel format";
		FErrorCode = LGLError_NoPixelFormat;
		return 0;
	}

	//Reload( false );

	HGLRC RenderContext = CreateContext( LGL3, DeviceContext, VersionMajor, VersionMinor, DebugContext );

	if ( !RenderContext )
	{
		FError = "Can't create an OpenGL " + LStr::ToStr( VersionMajor ) + " " + LStr::ToStr( VersionMinor ) + " rendering context";
		FErrorCode = LGLError_NoGLVersion;
		return 0;
	}

	if ( !MakeCurrent( LGL3, DeviceContext, RenderContext ) ) { return 0; }

	Reload( LGL3, true );

	return RenderContext;
}

GL_CONTEXT_TYPE LGL::clGLExtRetriever::MakeCurrent( sLGLAPI* LGL3, DEVICE_CONTEXT_TYPE DeviceContext, GL_CONTEXT_TYPE RenderContext )
{
	if ( !LGL3->lglMakeCurrent( DeviceContext, RenderContext ) )
	{
		FError = "Can't activate the OpenGL rendering context";
		FErrorCode = LGLError_CantMakeCurrent;
		return 0;
	}

	return RenderContext;
}

void LGL::clGLExtRetriever::DeleteContext( sLGLAPI* LGL3, HDC DeviceContext, HGLRC RenderContext )
{
	LGL3->lglMakeCurrent( DeviceContext, 0 );
	LGL3->lglDeleteContext( RenderContext );
}
#endif

#if defined( OS_ANDROID )
void LGL::clGLExtRetriever::DeleteContext( sLGLAPI* LGL3, DEVICE_CONTEXT_TYPE DeviceContext, GL_CONTEXT_TYPE RenderContext )
{
	// Nothing to do here
}

GL_CONTEXT_TYPE LGL::clGLExtRetriever::CreateContext( sLGLAPI* LGL3, DEVICE_CONTEXT_TYPE DeviceContext, int VersionMajor, int VersionMinor, bool DebugContext )
{
#if defined( ANDROID9 )
	return eglGetCurrentContext();
#else
	return NULL;
#endif
}

GL_CONTEXT_TYPE LGL::clGLExtRetriever::CreateContextFull( sLGLAPI* LGL3, DEVICE_CONTEXT_TYPE DeviceContext, int BitsPerPixel, int ZBufferBits, int StencilBits, int Multisample, int VersionMajor, int VersionMinor, bool DebugContext )
{
#if defined( ANDROID9 )
	return eglGetCurrentContext();
#else
	return NULL;
#endif
}

bool LGL::clGLExtRetriever::ChooseAndSetPixelFormat( sLGLAPI* LGL3, DEVICE_CONTEXT_TYPE DeviceContext, int BitsPerPixel, int ZBufferBits, int StencilBits, int Multisample )
{
	return true;
}

GL_CONTEXT_TYPE LGL::clGLExtRetriever::MakeCurrent( sLGLAPI* LGL3, DEVICE_CONTEXT_TYPE DeviceContext, GL_CONTEXT_TYPE RenderContext )
{
	return RenderContext;
}

#endif

#if defined(OS_LINUX) && !defined(OS_ANDROID)

static bool LGLContextErrorOccurred = false;

static int LGLContextErrorHandler( Display* Disp, XErrorEvent* Event )
{
	LGLContextErrorOccurred = true;

	return 0;
}

bool LGL::clGLExtRetriever::ChooseAndSetPixelFormat( Display* Disp, int BitsPerPixel, int ZBufferBits, int StencilBits, int Multisample )
{
	const int Attribs[] =
	{
		GLX_X_RENDERABLE  , True,
		GLX_DRAWABLE_TYPE , GLX_WINDOW_BIT,
		GLX_RENDER_TYPE   , GLX_RGBA_BIT,
		GLX_X_VISUAL_TYPE , GLX_TRUE_COLOR,
		GLX_RED_SIZE      , 8,
		GLX_GREEN_SIZE    , 8,
		GLX_BLUE_SIZE     , 8,
		GLX_ALPHA_SIZE    , 8,
		GLX_DEPTH_SIZE    , ZBufferBits,
		GLX_STENCIL_SIZE  , StencilBits,
		GLX_DOUBLEBUFFER  , True,
		//GLX_SAMPLE_BUFFERS, 1,
		//GLX_SAMPLES         , 4,
		None
	};

	int GLXVerMajor = 0;
	int GLXVerMinor = 0;

	// FBConfigs were added in GLX version 1.3
	if ( !glXQueryVersion( Disp, &GLXVerMajor, &GLXVerMinor ) ||
	     ( ( GLXVerMajor == 1 ) && ( GLXVerMinor < 3 ) ) || ( GLXVerMajor < 1 ) )
	{
		FError = "Invalid GLX version";
		FErrorCode = LGLError_NoGLVersion;
		return false;
	}

	int FBCount = 0;

	GLXFBConfig* FBConfig = glXChooseFBConfig( Disp, DefaultScreen( Disp ), Attribs, &FBCount );

	if ( !FBConfig )
	{
		FError = "Failed to retrieve a framebuffer config";
		FErrorCode = LGLError_NoFramebufferConfig;
		return false;
	}

	// pick the FB config/visual with the most samples per pixel
	int BestFBC     = -1;
	int BestNumSamp = -1;

	for ( int i = 0; i != FBCount; i++ )
	{
		XVisualInfo* VI = glXGetVisualFromFBConfig( Disp, FBConfig[i] );

		if ( VI )
		{
			int SampBuf = 0;
			int Samples = 0;

			glXGetFBConfigAttrib( Disp, FBConfig[i], GLX_SAMPLE_BUFFERS, &SampBuf );
			glXGetFBConfigAttrib( Disp, FBConfig[i], GLX_SAMPLES       , &Samples );

			if ( BestFBC < 0 || SampBuf && Samples > BestNumSamp )
			{
				BestFBC     = i;
				BestNumSamp = Samples;
			}
		}

		XFree( VI );
	}

	GLXFBConfig SelectedFBC = FBConfig[ BestFBC ];

	// be sure to free the GLXFBConfig list allocated by glXChooseFBConfig()
	XFree( FBConfig );

	// get a visual
	XVisualInfo* VI = glXGetVisualFromFBConfig( Disp, SelectedFBC );

	// create color map
	XSetWindowAttributes SWA;

	SWA.colormap = XCreateColormap( Disp, RootWindow( Disp, VI->screen ), VI->visual, AllocNone );
	SWA.background_pixmap = None ;
	SWA.border_pixel      = 0;
	SWA.event_mask        = StructureNotifyMask;

	TODO( "Move window creation code to clViewport" )

	// create window
	Window Win = XCreateWindow( Disp, RootWindow( Disp, VI->screen ),
	                            0, 0, 100, 100, 0, VI->depth, InputOutput, VI->visual,
	                            CWBorderPixel | CWColormap | CWEventMask, &SWA );

	if ( !Win )
	{
		FError = "Failed to create window";
		FErrorCode = LGLError_NoWindow;
		return false;
	}

	XFree( VI );

	XStoreName( Disp, Win, "GL 3.0 Window" );
	XMapWindow( Disp, Win );

	// Install an X error handler so the application won't exit if GL 3.x context allocation fails.
	int ( *OldHandler )( Display*, XErrorEvent* ) = XSetErrorHandler( &LGLContextErrorHandler );

	return true;
}

GLXContext LGL::clGLExtRetriever::CreateContext( Display* Disp, int VersionMajor, int VersionMinor, bool DebugContext )
{
	GLXContext Context = 0;

	GLXCREATECONTEXTATTRIBSARBPROC glXCreateContextAttribsARB = ( GLXCREATECONTEXTATTRIBSARBPROC ) glXGetProcAddress( ( const GLubyte* )"glXCreateContextAttribsARB" );

	// GLXFBConfig, GLXContext - Warning: conflicts with ChooseAndSet, must be in sync
	int FBCount = 0;
	GLXFBConfig* bestFbc = glXChooseFBConfig( Disp, DefaultScreen( Disp ), 0, &FBCount );

	if ( glXCreateContextAttribsARB )
	{
		const int Attribs[] =
		{
			GLX_CONTEXT_MAJOR_VERSION_ARB, VersionMajor,
			GLX_CONTEXT_MINOR_VERSION_ARB, VersionMinor,
//			GLX_CONTEXT_LAYER_PLANE_ARB,   0,
			GLX_CONTEXT_FLAGS_ARB,         GLX_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB | ( DebugContext ? GLX_CONTEXT_DEBUG_BIT_ARB : 0 ),
			GLX_CONTEXT_PROFILE_MASK_ARB,  GLX_CONTEXT_CORE_PROFILE_BIT_ARB,
			0 // end
		};

		Context = glXCreateContextAttribsARB( Disp, *bestFbc, 0, True, Attribs );

		// Sync to ensure any errors generated are processed.
		XSync( Disp, False );
	}
	else
	{
		Context = glXCreateNewContext( Disp, *bestFbc, GLX_RGBA_TYPE, 0, True );
	}

	return Context;
}

void LGL::clGLExtRetriever::DeleteContext( Display* Disp, GLXContext RenderContext )
{
	glXMakeCurrent( Disp, 0, 0 );
	glXDestroyContext( Disp, RenderContext );
}

GLXContext LGL::clGLExtRetriever::CreateContextFull( Display* Disp, int BitsPerPixel, int ZBufferBits, int StencilBits, int Multisample, int VersionMajor, int VersionMinor, bool DebugContext )
{
	bool FormatSet = ChooseAndSetPixelFormat( Disp, BitsPerPixel, ZBufferBits, StencilBits, Multisample );

	if ( !FormatSet )
	{
		FError = "Can't set the pixel format";
		FErrorCode = LGLError_NoPixelFormat;
		return 0;
	}

	GLXContext Context = CreateContext( Disp, VersionMajor, VersionMinor, DebugContext );

	if ( !Context )
	{
		FError = "Can't create an OpenGL rendering context";
		FErrorCode = LGLError_NoGLVersion;
		return 0;
	}

	// FIXME: pass window handle here
	if ( !glXMakeCurrent( Disp, 0 /*win*/, Context ) )
	{
		FError = "Can't activate the OpenGL rendering context";
		FErrorCode = LGLError_CantMakeCurrent;
		return 0;
	}

	Reload( false );

	return Context;
}


GL_CONTEXT_TYPE LGL::clGLExtRetriever::MakeCurrent( DEVICE_CONTEXT_TYPE DeviceContext, GL_CONTEXT_TYPE RenderContext )
{
	/*
	   if ( !lglMakeCurrent( DeviceContext, RenderContext ) )
	   {
	      FError = "Can't activate the OpenGL rendering context";
	      FErrorCode = FErrorCode = LGLError_CantMakeCurrent;
	      return 0;
	   }
	*/
	return RenderContext;
}

#endif

LGL::clGLExtRetriever::clGLExtRetriever()
	: FError( "" ),
	  FErrorCode( LGLError_Ok ),
	  FLib( NULL )
{
}

void LGL::clGLExtRetriever::Unload()
{
	delete( FLib );

	FLib = NULL;
	/*
	lglGetProcAddress = NULL;

	#ifdef OS_WINDOWS
	lglGetCurrentContext = NULL;
	lglCreateContext     = NULL;
	lglMakeCurrent       = NULL;
	lglDeleteContext     = NULL;
	#endif // OS_WINDOWS
	*/
	//memset( &LGL3, 0, sizeof( LGL3 ) );
}

void* LGL::clGLExtRetriever::GetGLProc( sLGLAPI* LGL3, const char* Name ) const
{
	LOGI( "GetGLProc( %s )", Name );

	void* Proc = NULL;

	if ( LGL3->lglGetProcAddress

#if defined(OS_WINDOWS) || defined(OS_ANDROID)
	     && ( LGL3->lglGetProcAddress != ( PFNwglGetProcAddress )0xdeadbeef )
#endif

#if defined(OS_LINUX) && !defined(OS_ANDROID)
	     && ( LGL3->lglGetProcAddress != ( PFNglXGetProcAddress )0xdeadbeef )
#endif
	   )
	{
		Proc = ( void* )LGL3->lglGetProcAddress( Name );
	}

	return Proc ? Proc : ( FLib ? FLib->GetProcAddress( Name ) : NULL );
}

void LGL::clGLExtRetriever::Reload( sLGLAPI* LGL3, bool UpdateExtensionsFlags )
{
	// use this to obtain GL 1.0 entry points
	if ( !FLib )
	{
#if defined( OS_WINDOWS )
		const char* LibName = "opengl32.dll";
#endif // OS_WINDOWS

#if defined( OS_LINUX ) && !defined(OS_ANDROID)
		const char* LibName = "opengl.so";
#endif

#if !defined( OS_ANDROID )
		FLib = new clLibrary();
		FLib->Load( LibName );
#endif
	}

	bool FirstCall = ( LGL3->lglGetProcAddress == NULL );

#if defined( OS_WINDOWS )
	// WGL
	LGL3->lglGetProcAddress = ( PFNwglGetProcAddress )FLib->GetProcAddress( "wglGetProcAddress" );
#elif defined(OS_LINUX) && !defined(OS_ANDROID)
	LGL3->lglGetProcAddress = ( PFNglXGetProcAddress )FLib->GetProcAddress( "glXGetProcAddress" );
#else
	LGL3->lglGetProcAddress = ( PFNwglGetProcAddress )0xdeadbeef;
#endif // OS_WINDOWS

#if defined( OS_ANDROID ) && defined( ANDROID9 )
	lglGetCurrentContext = ( PFNwglGetCurrentContext )&eglGetCurrentContext;
#endif // OS_ANDROID & ANDROID9

#if defined( OS_WINDOWS )
	LGL3->lglCreateContext = ( PFNwglCreateContext )FLib->GetProcAddress( "wglCreateContext" );
	LGL3->lglGetCurrentContext = ( PFNwglGetCurrentContext )FLib->GetProcAddress( "wglGetCurrentContext" );
	LGL3->lglMakeCurrent = ( PFNwglMakeCurrent )FLib->GetProcAddress( "wglMakeCurrent" );
	LGL3->lglDeleteContext = ( PFNwglDeleteContext )FLib->GetProcAddress( "wglDeleteContext" );
#endif // OS_LINUX

	// nothing to do here if we a calling Reload() for the first time
	if ( FirstCall ) { return; }

	GetAPI( LGL3 );

	if ( UpdateExtensionsFlags )
	{
		LGL3->Has_GL_ARB_framebuffer_object = LGL::IsExtensionSupported( LGL3, "GL_ARB_framebuffer_object" );
		LGL3->Has_GL_ARB_vertex_array_object = LGL::IsExtensionSupported( LGL3, "GL_ARB_vertex_array_object" );
		LGL3->Has_GL_ARB_timer_query = LGL::IsExtensionSupported( LGL3, "GL_ARB_timer_query" );
		LGL3->Has_GL_ARB_uniform_buffer_object = LGL::IsExtensionSupported( LGL3, "GL_ARB_uniform_buffer_object" );
		LGL3->Has_GL_ARB_debug_output = LGL::IsExtensionSupported( LGL3, "GL_ARB_debug_output" );
		LGL3->Has_GL_ARB_get_program_binary = LGL::IsExtensionSupported( LGL3, "GL_ARB_get_program_binary" );
		LGL3->Has_GL_ARB_viewport_array = LGL::IsExtensionSupported( LGL3, "GL_ARB_viewport_array" );
		LGL3->Has_GL_ARB_tessellation_shader = LGL::IsExtensionSupported( LGL3, "GL_ARB_tessellation_shader" );
		LGL3->Has_GL_EXT_direct_state_access = LGL::IsExtensionSupported( LGL3, "GL_EXT_direct_state_access" );
		LGL3->Has_GL_ATI_meminfo = LGL::IsExtensionSupported( LGL3, "GL_ATI_meminfo" );
		LGL3->Has_GL_NVX_gpu_memory_info = LGL::IsExtensionSupported( LGL3, "GL_NVX_gpu_memory_info" );
		LGL3->Has_WGL_ARB_create_context = LGL::IsExtensionSupported( LGL3, "WGL_ARB_create_context" );
		LGL3->Has_WGL_ARB_extensions_string = LGL::IsExtensionSupported( LGL3, "WGL_ARB_extensions_string" );
		LGL3->Has_WGL_ARB_pixel_format = LGL::IsExtensionSupported( LGL3, "WGL_ARB_pixel_format" );
		LGL3->Has_WGL_EXT_swap_control = LGL::IsExtensionSupported( LGL3, "WGL_EXT_swap_control" );
#if defined( USE_OPENGL_3 )
		LGL3->Is24DepthBufferSupported = true;
#else
		LGL3->Is24DepthBufferSupported = LGL::IsExtensionSupported( LGL3, "GL_OES_depth24" );
#endif
	}
}

#if defined( USE_OPENGL_3 )
// read OpenGL 3.x
void LGL::clGLExtRetriever::GetAPI( sLGLAPI* API ) const
{
	API->glActiveTexture = ( PFNGLACTIVETEXTUREPROC )GetGLProc( API, "glActiveTexture" );
	API->glAttachShader = ( PFNGLATTACHSHADERPROC )GetGLProc( API, "glAttachShader" );
	API->glBeginQuery = ( PFNGLBEGINQUERYPROC )GetGLProc( API, "glBeginQuery" );
	API->glBindAttribLocation = ( PFNGLBINDATTRIBLOCATIONPROC )GetGLProc( API, "glBindAttribLocation" );
	API->glBindBuffer = ( PFNGLBINDBUFFERPROC )GetGLProc( API, "glBindBuffer" );
	API->glBindBufferBase = ( PFNGLBINDBUFFERBASEPROC )GetGLProc( API, "glBindBufferBase" );
	API->glBindFragDataLocation = ( PFNGLBINDFRAGDATALOCATIONPROC )GetGLProc( API, "glBindFragDataLocation" );
	API->glBindFramebuffer = ( PFNGLBINDFRAMEBUFFERPROC )GetGLProc( API, "glBindFramebuffer" );
	API->glBindTexture = ( PFNGLBINDTEXTUREPROC )GetGLProc( API, "glBindTexture" );
	API->glBindVertexArray = ( PFNGLBINDVERTEXARRAYPROC )GetGLProc( API, "glBindVertexArray" );
	API->glBlendFunc = ( PFNGLBLENDFUNCPROC )GetGLProc( API, "glBlendFunc" );
	API->glBufferData = ( PFNGLBUFFERDATAPROC )GetGLProc( API, "glBufferData" );
	API->glBufferSubData = ( PFNGLBUFFERSUBDATAPROC )GetGLProc( API, "glBufferSubData" );
	API->glCheckFramebufferStatus = ( PFNGLCHECKFRAMEBUFFERSTATUSPROC )GetGLProc( API, "glCheckFramebufferStatus" );
	API->glClear = ( PFNGLCLEARPROC )GetGLProc( API, "glClear" );
	API->glClearColor = ( PFNGLCLEARCOLORPROC )GetGLProc( API, "glClearColor" );
	API->glClearDepth = ( PFNGLCLEARDEPTHPROC )GetGLProc( API, "glClearDepth" );
	API->glClearStencil = ( PFNGLCLEARSTENCILPROC )GetGLProc( API, "glClearStencil" );
	API->glColorMask = ( PFNGLCOLORMASKPROC )GetGLProc( API, "glColorMask" );
	API->glCompileShader = ( PFNGLCOMPILESHADERPROC )GetGLProc( API, "glCompileShader" );
	API->glCompressedTexImage2D = ( PFNGLCOMPRESSEDTEXIMAGE2DPROC )GetGLProc( API, "glCompressedTexImage2D" );
	API->glCompressedTexImage3D = ( PFNGLCOMPRESSEDTEXIMAGE3DPROC )GetGLProc( API, "glCompressedTexImage3D" );
	API->glCreateProgram = ( PFNGLCREATEPROGRAMPROC )GetGLProc( API, "glCreateProgram" );
	API->glCreateShader = ( PFNGLCREATESHADERPROC )GetGLProc( API, "glCreateShader" );
	API->glCullFace = ( PFNGLCULLFACEPROC )GetGLProc( API, "glCullFace" );
	API->glDebugMessageCallbackARB = ( PFNGLDEBUGMESSAGECALLBACKARBPROC )GetGLProc( API, "glDebugMessageCallbackARB" );
	API->glDebugMessageControlARB = ( PFNGLDEBUGMESSAGECONTROLARBPROC )GetGLProc( API, "glDebugMessageControlARB" );
	API->glDeleteBuffers = ( PFNGLDELETEBUFFERSPROC )GetGLProc( API, "glDeleteBuffers" );
	API->glDeleteFramebuffers = ( PFNGLDELETEFRAMEBUFFERSPROC )GetGLProc( API, "glDeleteFramebuffers" );
	API->glDeleteProgram = ( PFNGLDELETEPROGRAMPROC )GetGLProc( API, "glDeleteProgram" );
	API->glDeleteQueries = ( PFNGLDELETEQUERIESPROC )GetGLProc( API, "glDeleteQueries" );
	API->glDeleteShader = ( PFNGLDELETESHADERPROC )GetGLProc( API, "glDeleteShader" );
	API->glDeleteTextures = ( PFNGLDELETETEXTURESPROC )GetGLProc( API, "glDeleteTextures" );
	API->glDeleteVertexArrays = ( PFNGLDELETEVERTEXARRAYSPROC )GetGLProc( API, "glDeleteVertexArrays" );
	API->glDepthMask = ( PFNGLDEPTHMASKPROC )GetGLProc( API, "glDepthMask" );
	API->glDisable = ( PFNGLDISABLEPROC )GetGLProc( API, "glDisable" );
	API->glDisablei = ( PFNGLDISABLEIPROC )GetGLProc( API, "glDisablei" );
	API->glDisableVertexAttribArray = ( PFNGLDISABLEVERTEXATTRIBARRAYPROC )GetGLProc( API, "glDisableVertexAttribArray" );
	API->glDrawArrays = ( PFNGLDRAWARRAYSPROC )GetGLProc( API, "glDrawArrays" );
	API->glDrawArraysInstanced = ( PFNGLDRAWARRAYSINSTANCEDPROC )GetGLProc( API, "glDrawArraysInstanced" );
	API->glDrawBuffers = ( PFNGLDRAWBUFFERSPROC )GetGLProc( API, "glDrawBuffers" );
	API->glDrawElements = ( PFNGLDRAWELEMENTSPROC )GetGLProc( API, "glDrawElements" );
	API->glDrawElementsInstanced = ( PFNGLDRAWELEMENTSINSTANCEDPROC )GetGLProc( API, "glDrawElementsInstanced" );
	API->glEnable = ( PFNGLENABLEPROC )GetGLProc( API, "glEnable" );
	API->glEnablei = ( PFNGLENABLEIPROC )GetGLProc( API, "glEnablei" );
	API->glEnableVertexAttribArray = ( PFNGLENABLEVERTEXATTRIBARRAYPROC )GetGLProc( API, "glEnableVertexAttribArray" );
	API->glEndQuery = ( PFNGLENDQUERYPROC )GetGLProc( API, "glEndQuery" );
	API->glFinish = ( PFNGLFINISHPROC )GetGLProc( API, "glFinish" );
	API->glFlush = ( PFNGLFLUSHPROC )GetGLProc( API, "glFlush" );
	API->glFramebufferTexture2D = ( PFNGLFRAMEBUFFERTEXTURE2DPROC )GetGLProc( API, "glFramebufferTexture2D" );
	API->glFramebufferTexture3D = ( PFNGLFRAMEBUFFERTEXTURE3DPROC )GetGLProc( API, "glFramebufferTexture3D" );
	API->glGenBuffers = ( PFNGLGENBUFFERSPROC )GetGLProc( API, "glGenBuffers" );
	API->glGenerateMipmap = ( PFNGLGENERATEMIPMAPPROC )GetGLProc( API, "glGenerateMipmap" );
	API->glGenFramebuffers = ( PFNGLGENFRAMEBUFFERSPROC )GetGLProc( API, "glGenFramebuffers" );
	API->glGenQueries = ( PFNGLGENQUERIESPROC )GetGLProc( API, "glGenQueries" );
	API->glGenTextures = ( PFNGLGENTEXTURESPROC )GetGLProc( API, "glGenTextures" );
	API->glGenVertexArrays = ( PFNGLGENVERTEXARRAYSPROC )GetGLProc( API, "glGenVertexArrays" );
	API->glGetActiveAttrib = ( PFNGLGETACTIVEATTRIBPROC )GetGLProc( API, "glGetActiveAttrib" );
	API->glGetActiveUniform = ( PFNGLGETACTIVEUNIFORMPROC )GetGLProc( API, "glGetActiveUniform" );
	API->glGetActiveUniformBlockiv = ( PFNGLGETACTIVEUNIFORMBLOCKIVPROC )GetGLProc( API, "glGetActiveUniformBlockiv" );
	API->glGetAttribLocation = ( PFNGLGETATTRIBLOCATIONPROC )GetGLProc( API, "glGetAttribLocation" );
	API->glGetCompressedTexImage = ( PFNGLGETCOMPRESSEDTEXIMAGEPROC )GetGLProc( API, "glGetCompressedTexImage" );
	API->glGetDebugMessageLogARB = ( PFNGLGETDEBUGMESSAGELOGARBPROC )GetGLProc( API, "glGetDebugMessageLogARB" );
	API->glGetError = ( PFNGLGETERRORPROC )GetGLProc( API, "glGetError" );
	API->glGetIntegerv = ( PFNGLGETINTEGERVPROC )GetGLProc( API, "glGetIntegerv" );
	API->glGetProgramBinary = ( PFNGLGETPROGRAMBINARYPROC )GetGLProc( API, "glGetProgramBinary" );
	API->glGetProgramInfoLog = ( PFNGLGETPROGRAMINFOLOGPROC )GetGLProc( API, "glGetProgramInfoLog" );
	API->glGetProgramiv = ( PFNGLGETPROGRAMIVPROC )GetGLProc( API, "glGetProgramiv" );
	API->glGetQueryObjectiv = ( PFNGLGETQUERYOBJECTIVPROC )GetGLProc( API, "glGetQueryObjectiv" );
	API->glGetQueryObjectui64v = ( PFNGLGETQUERYOBJECTUI64VPROC )GetGLProc( API, "glGetQueryObjectui64v" );
	API->glGetShaderInfoLog = ( PFNGLGETSHADERINFOLOGPROC )GetGLProc( API, "glGetShaderInfoLog" );
	API->glGetShaderiv = ( PFNGLGETSHADERIVPROC )GetGLProc( API, "glGetShaderiv" );
	API->glGetString = ( PFNGLGETSTRINGPROC )GetGLProc( API, "glGetString" );
	API->glGetStringi = ( PFNGLGETSTRINGIPROC )GetGLProc( API, "glGetStringi" );
	API->glGetTexImage = ( PFNGLGETTEXIMAGEPROC )GetGLProc( API, "glGetTexImage" );
	API->glGetTexLevelParameteriv = ( PFNGLGETTEXLEVELPARAMETERIVPROC )GetGLProc( API, "glGetTexLevelParameteriv" );
	API->glGetUniformLocation = ( PFNGLGETUNIFORMLOCATIONPROC )GetGLProc( API, "glGetUniformLocation" );
	API->glIsProgram = ( PFNGLISPROGRAMPROC )GetGLProc( API, "glIsProgram" );
	API->glIsShader = ( PFNGLISSHADERPROC )GetGLProc( API, "glIsShader" );
	API->glLinkProgram = ( PFNGLLINKPROGRAMPROC )GetGLProc( API, "glLinkProgram" );
	API->glPatchParameteri = ( PFNGLPATCHPARAMETERIPROC )GetGLProc( API, "glPatchParameteri" );
	API->glPixelStorei = ( PFNGLPIXELSTOREIPROC )GetGLProc( API, "glPixelStorei" );
	API->glPolygonMode = ( PFNGLPOLYGONMODEPROC )GetGLProc( API, "glPolygonMode" );
	API->glProgramBinary = ( PFNGLPROGRAMBINARYPROC )GetGLProc( API, "glProgramBinary" );
	API->glProgramParameteri = ( PFNGLPROGRAMPARAMETERIPROC )GetGLProc( API, "glProgramParameteri" );
	API->glReadBuffer = ( PFNGLREADBUFFERPROC )GetGLProc( API, "glReadBuffer" );
	API->glReadPixels = ( PFNGLREADPIXELSPROC )GetGLProc( API, "glReadPixels" );
	API->glShaderSource = ( PFNGLSHADERSOURCEPROC )GetGLProc( API, "glShaderSource" );
	API->glTexSubImage2D = ( PFNGLTEXSUBIMAGE2DPROC )GetGLProc( API, "glTexSubImage2D" );
	API->glTexImage2D = ( PFNGLTEXIMAGE2DPROC )GetGLProc( API, "glTexImage2D" );
	API->glTexImage3D = ( PFNGLTEXIMAGE3DPROC )GetGLProc( API, "glTexImage3D" );
	API->glTexParameterf = ( PFNGLTEXPARAMETERFPROC )GetGLProc( API, "glTexParameterf" );
	API->glTexParameteri = ( PFNGLTEXPARAMETERIPROC )GetGLProc( API, "glTexParameteri" );
	API->glUniform1f = ( PFNGLUNIFORM1FPROC )GetGLProc( API, "glUniform1f" );
	API->glUniform1fv = ( PFNGLUNIFORM1FVPROC )GetGLProc( API, "glUniform1fv" );
	API->glUniform1i = ( PFNGLUNIFORM1IPROC )GetGLProc( API, "glUniform1i" );
	API->glUniform1iv = ( PFNGLUNIFORM1IVPROC )GetGLProc( API, "glUniform1iv" );
	API->glUniform3fv = ( PFNGLUNIFORM3FVPROC )GetGLProc( API, "glUniform3fv" );
	API->glUniform4fv = ( PFNGLUNIFORM4FVPROC )GetGLProc( API, "glUniform4fv" );
	API->glUniformBlockBinding = ( PFNGLUNIFORMBLOCKBINDINGPROC )GetGLProc( API, "glUniformBlockBinding" );
	API->glUniformMatrix3fv = ( PFNGLUNIFORMMATRIX3FVPROC )GetGLProc( API, "glUniformMatrix3fv" );
	API->glUniformMatrix4fv = ( PFNGLUNIFORMMATRIX4FVPROC )GetGLProc( API, "glUniformMatrix4fv" );
	API->glUseProgram = ( PFNGLUSEPROGRAMPROC )GetGLProc( API, "glUseProgram" );
	API->glValidateProgram = ( PFNGLVALIDATEPROGRAMPROC )GetGLProc( API, "glValidateProgram" );
	API->glVertexAttribPointer = ( PFNGLVERTEXATTRIBPOINTERPROC )GetGLProc( API, "glVertexAttribPointer" );
	API->glViewport = ( PFNGLVIEWPORTPROC )GetGLProc( API, "glViewport" );
#if !defined(OS_LINUX)
	API->wglChoosePixelFormatARB = ( PFNWGLCHOOSEPIXELFORMATARBPROC )GetGLProc( API, "wglChoosePixelFormatARB" );
	API->wglCreateContextAttribsARB = ( PFNWGLCREATECONTEXTATTRIBSARBPROC )GetGLProc( API, "wglCreateContextAttribsARB" );
	API->wglGetExtensionsStringARB = ( PFNWGLGETEXTENSIONSSTRINGARBPROC )GetGLProc( API, "wglGetExtensionsStringARB" );
	API->wglSwapIntervalEXT = ( PFNWGLSWAPINTERVALEXTPROC )GetGLProc( API, "wglSwapIntervalEXT" );
#endif // OS_LINUX
}
#endif // USE_OPENGL_3


#if defined( USE_OPENGL_ES_2 )
// read OpenGL ES 2.0
void Emulate_glClearDepth( double Depth )
{
	glClearDepthf( static_cast<float>( Depth ) );
}

void Emulate_glDrawArraysInstanced( GLenum mode, GLint first, GLsizei count, GLsizei primcount )
{
	for ( GLsizei i = 0; i != primcount; i++ )
	{
		// FIXME: sent instanceID = i in shaders
		glDrawArrays( mode, first, count );
	}
}

void Emulate_glDrawElementsInstanced( GLenum mode, GLsizei count, GLenum type, const GLvoid* indices, GLsizei primcount )
{
	for ( GLsizei i = 0; i != primcount; i++ )
	{
		// FIXME: sent instanceID = i in shaders
		glDrawElements( mode, count, type, indices );
	}
}

void Emulate_glPolygonMode( GLenum, GLenum )
{
	// not supported
}

void Emulate_glPatchParameteri( GLenum, GLint )
{
	// not supported
}

void Emulate_glDisablei( GLenum mode, GLuint )
{
	glDisable( mode );
}

void Emulate_glEnablei( GLenum mode, GLuint )
{
	glEnable( mode );
}

void Emulate_glGetTexImage( GLenum, GLint, GLenum, GLenum, GLvoid* )
{
	// not supported
}

void Emulate_glBeginQuery( GLenum, GLuint )
{
	// not supported
}

void Emulate_glBindBufferBase( GLenum, GLuint, GLuint )
{
	// not supported
}

void Emulate_glBindFragDataLocation( GLuint, GLuint, const GLchar* )
{
	// not supported
}

void Emulate_glReadBuffer( GLenum )
{
	// not supported
}

GLuint Emulate_glGetDebugMessageLogARB( GLuint, GLsizei, GLenum*, GLenum*, GLuint*, GLenum*, GLsizei*, GLchar* )
{
	// not supported
	return 0;
}

void Emulate_glEndQuery( GLenum )
{
	// not supported
}

void Emulate_glGenQueries( GLsizei, GLuint* )
{
	// not supported
}

void Emulate_glDeleteQueries( GLsizei, const GLuint* )
{
	// not supported
}

void Emulate_glDrawBuffers( GLsizei, const GLenum* )
{
	// not supported
}

void Emulate_glCompressedTexImage3D( GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLsizei, const GLvoid* )
{
	// not supported
}

void Emulate_glFramebufferTexture3D( GLenum, GLenum, GLenum, GLuint, GLint, GLint )
{
	// not supported
}

void Emulate_glDebugMessageCallbackARB( void (* )( GLenum, GLenum, GLuint, GLenum, GLsizei, const GLchar*, GLvoid* ), const GLvoid* )
{
	// not supported
}

void Emulate_glDebugMessageControlARB( GLenum, GLenum, GLenum, GLsizei, const GLuint*, GLboolean )
{
	// not supported
}

void Emulate_glTexImage3D( GLenum, GLint, GLint, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid* )
{
	// not supported
}

void Emulate_glGetCompressedTexImage( GLenum, GLint, GLvoid* )
{
	// not supported
}

void Emulate_glProgramBinary( GLuint, GLenum, const GLvoid*, GLsizei )
{
	// not supported
}

void Emulate_glProgramParameteri( GLuint, GLenum, GLint )
{
	// not supported
}

void Emulate_glGetTexLevelParameteriv( GLenum, GLint, GLenum, GLint* )
{
	// not supported
}

void Emulate_glGetActiveUniformBlockiv( GLuint, GLuint, GLenum, GLint* )
{
	// not supported
}

void Emulate_glGetProgramBinary( GLuint, GLsizei, GLsizei*, GLenum*, GLvoid* )
{
	// not supported
}

void Emulate_glUniformBlockBinding( GLuint, GLuint, GLuint )
{
	// not supported
}

void Emulate_glGetQueryObjectiv( GLuint, GLenum, GLint* )
{
	// not supported
}

void Emulate_glGetQueryObjectui64v( GLuint, GLenum, GLuint64* )
{
	// not supported
}

#define BIND_EMULATE( VarName, BindName, EmulProc ) VarName = BindName; VarName = (VarName ? VarName : EmulProc);

void LGL::clGLExtRetriever::GetAPI( sLGLAPI* API ) const
{
	LOGI( "Getting OpenGL API for Android" );

	API->glActiveTexture = &glActiveTexture;
	API->glAttachShader = &glAttachShader;
	API->glBeginQuery = &Emulate_glBeginQuery;
	API->glBindAttribLocation = &glBindAttribLocation;
	API->glBindBuffer = &glBindBuffer;
	API->glBindBufferBase = &Emulate_glBindBufferBase;
	API->glBindFragDataLocation = &Emulate_glBindFragDataLocation;
	API->glBindFramebuffer = &glBindFramebuffer;
	API->glBindTexture = &glBindTexture;
	API->glBlendFunc = &glBlendFunc;
	API->glBufferData = &glBufferData;
	API->glBufferSubData = &glBufferSubData;
	API->glCheckFramebufferStatus = &glCheckFramebufferStatus;
	API->glClear = &glClear;
	API->glClearColor = &glClearColor;
	API->glClearDepth = &Emulate_glClearDepth;
	API->glClearStencil = &glClearStencil;
	API->glColorMask = &glColorMask;
	API->glCompileShader = &glCompileShader;
	API->glCompressedTexImage2D = &glCompressedTexImage2D;
	API->glCompressedTexImage3D = &Emulate_glCompressedTexImage3D;
	API->glCreateProgram = &glCreateProgram;
	API->glCreateShader = &glCreateShader;
	API->glCullFace = &glCullFace;
	API->glDebugMessageCallbackARB = &Emulate_glDebugMessageCallbackARB;
	API->glDebugMessageControlARB = &Emulate_glDebugMessageControlARB;
	API->glDeleteBuffers = &glDeleteBuffers;
	API->glDeleteFramebuffers = &glDeleteFramebuffers;
	API->glDeleteProgram = &glDeleteProgram;
	API->glDeleteQueries = &Emulate_glDeleteQueries;
	API->glDeleteShader = &glDeleteShader;
	API->glDeleteTextures = &glDeleteTextures;
	API->glDepthMask = &glDepthMask;
	API->glDisable = &glDisable;
	API->glDisablei = &Emulate_glDisablei;
	API->glDisableVertexAttribArray = &glDisableVertexAttribArray;
	API->glDrawArrays = &glDrawArrays;
	API->glDrawArraysInstanced = &Emulate_glDrawArraysInstanced;
	API->glDrawBuffers = &Emulate_glDrawBuffers;
	API->glDrawElements = &glDrawElements;
	API->glDrawElementsInstanced = &Emulate_glDrawElementsInstanced;
	API->glEnable = &glEnable;
	API->glEnablei = &Emulate_glEnablei;
	API->glEnableVertexAttribArray = &glEnableVertexAttribArray;
	API->glEndQuery = &Emulate_glEndQuery;
	API->glFinish = &glFinish;
	API->glFlush = &glFlush;
	API->glFramebufferTexture2D = &glFramebufferTexture2D;
	API->glFramebufferTexture3D = &Emulate_glFramebufferTexture3D;
	API->glGenBuffers = &glGenBuffers;
	API->glGenerateMipmap = &glGenerateMipmap;
	API->glGenFramebuffers = &glGenFramebuffers;
	API->glGenQueries = &Emulate_glGenQueries;
	API->glGenTextures = &glGenTextures;
	API->glGetActiveAttrib = &glGetActiveAttrib;
	API->glGetActiveUniform = &glGetActiveUniform;
	API->glGetActiveUniformBlockiv = &Emulate_glGetActiveUniformBlockiv;
	API->glGetAttribLocation = &glGetAttribLocation;
	API->glGetCompressedTexImage = &Emulate_glGetCompressedTexImage;
	API->glGetDebugMessageLogARB = &Emulate_glGetDebugMessageLogARB;
	API->glGetError = &glGetError;
	API->glGetIntegerv = &glGetIntegerv;
	BIND_EMULATE( API->glGetProgramBinary, ( PFNGLGETPROGRAMBINARYPROC )GetGLProc( API, "glGetProgramBinaryOES" ), &Emulate_glGetProgramBinary );
	API->glGetProgramInfoLog = &glGetProgramInfoLog;
	API->glGetProgramiv = &glGetProgramiv;
	API->glGetQueryObjectiv = &Emulate_glGetQueryObjectiv;
	API->glGetQueryObjectui64v = &Emulate_glGetQueryObjectui64v;
	API->glGetShaderInfoLog = &glGetShaderInfoLog;
	API->glGetShaderiv = &glGetShaderiv;
	API->glGetString = ( PFNGLGETSTRINGPROC )&glGetString;
	API->glGetTexImage = &Emulate_glGetTexImage;
	API->glGetTexLevelParameteriv = &Emulate_glGetTexLevelParameteriv;
	API->glGetUniformLocation = &glGetUniformLocation;
	API->glIsProgram = &glIsProgram;
	API->glIsShader = &glIsShader;
	API->glLinkProgram = &glLinkProgram;
	API->glPatchParameteri = &Emulate_glPatchParameteri;
	API->glPixelStorei = &glPixelStorei;
	API->glPolygonMode = &Emulate_glPolygonMode;
	BIND_EMULATE( API->glProgramBinary, ( PFNGLPROGRAMBINARYPROC )GetGLProc( API, "glProgramBinaryOES" ), &Emulate_glProgramBinary );
	API->glProgramParameteri = &Emulate_glProgramParameteri;
	API->glReadBuffer = &Emulate_glReadBuffer;
	API->glReadPixels = &glReadPixels;
	API->glShaderSource = &glShaderSource;
	API->glTexSubImage2D = &glTexSubImage2D;
	API->glTexImage2D = &glTexImage2D;
	API->glTexImage3D = &Emulate_glTexImage3D;
	API->glTexParameterf = &glTexParameterf;
	API->glTexParameteri = &glTexParameteri;
	API->glUniform1f = &glUniform1f;
	API->glUniform1fv = &glUniform1fv;
	API->glUniform1i = &glUniform1i;
	API->glUniform1iv = &glUniform1iv;
	API->glUniform3fv = &glUniform3fv;
	API->glUniform4fv = &glUniform4fv;
	API->glUniformBlockBinding = &Emulate_glUniformBlockBinding;
	API->glUniformMatrix3fv = &glUniformMatrix3fv;
	API->glUniformMatrix4fv = &glUniformMatrix4fv;
	API->glUseProgram = &glUseProgram;
	API->glValidateProgram = &glValidateProgram;
	API->glVertexAttribPointer = &glVertexAttribPointer;
	API->glViewport = &glViewport;
}
#endif // USE_OPENGL_ES_2

/*
 * 05/03/2011
     Removed 1D textures
 * 26/01/2011
     Initial support of OpenGL ES 2
 * 14/01/2011
     Removed all global pointers to GL functions
 * 16/09/2010
     WGL guarded with #ifdef OS_WINDOWS
 * 19/08/2010
     Initial GLX initialization code added
 * 16/08/2010
     More utility code moved in
 * 09/08/2010
     OpenGL 4.1 and extensions
 * 23/03/2010
     Renegerated with gl3.h support
 * 22/02/2010
     Regenerated (old extensions removed)
 * 10/02/2010
     Regenerated (GL_ARB_vertex_array_object added)
 * 06/02/2010
     Regenerated
 * 08/10/2008
     OpenGL 3 initial support
 * 10/09/2007
     Regenerated
 * 26/08/2007
     Regenerated
 * 06/01/2007
     Stubs added
 * 13/11/2006
     Regenerated
 * 14/11/2005
     Regenerated
 * 26/06/2005
     Regenerated
 * 28/03/2005
     Regenerated
*/
