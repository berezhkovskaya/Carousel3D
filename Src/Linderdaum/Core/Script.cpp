/**
 * \file CodePatch.cpp
 * \brief Code fragment within LinderScript virtual machine
 * \version 0.5.74
 * \date 31/07/2007
 * \author Sergey Kosarevsky, 2005-2007
 * \author support@linderdaum.com http://www.linderdaum.com
 */

#include <stdio.h>

#include "Script.h"

#include "Environment.h"

#include "Core/RTTI/iStaticClass.h"
#include "Core/RTTI/Method.h"
#include "Core/RTTI/Symbol.h"

#include "Core/Linker.h"
#include "Core/Logger.h"
#include "Core/VFS/FileSystem.h"

#include "Utils/iStack.h"

#include "Math/LMath.h"

// static array of executors (autogenerated stuff)
#include "Generated/VM/ExecThread_MtdArray.h"

#include "Math/LRandom.h"
#include "Math/LQuaternion.h"

#include <cmath>

#include "Engine.h"

#include <algorithm>

//#define CODE_PATCH__HEAVY_DEBUG
#undef CODE_PATCH__HEAVY_DEBUG

/// Dynamically allocate the parameter (old behaviour)
scriptmethod iParameter* clScriptedParam::CreateParameter() const
{
	int TheSize = 0;

	if ( FParamType == "STRING" )
	{
		TheSize = sizeof( clStringParameter );
	}
	else if ( FParamType == "REF" )
	{
		TheSize = sizeof( clPointerParameter<iObject> );
	}
	else if ( FParamType == "PTR" )
	{
		TheSize = sizeof( clPointerParameter<void> );
	}
	else
	{
		//FATAL( FParamSize == 0, "Zero-size parameters are illegal" );
		if ( FParamSize == 0 ) { return NULL; }

		TheSize = sizeof( clScriptedPODParameter );
	}

	// dynamically allocated stuff by now
	return CreateParameter_Buf( new char[TheSize], NULL );
}

iParameter* clScriptedParam::CreateParameter_Buf( void* Where, void* BufForParam ) const
{
	if ( FParamType == "STRING" )
	{
		return new ( Where ) clStringParameter;
	}
	else if ( FParamType == "REF" )
	{
		return new ( Where ) clPointerParameter<iObject>;
	}
	else if ( FParamType == "PTR" )
	{
		return new ( Where ) clPointerParameter<void>;
	}
	else
	{
		//FATAL( FParamSize == 0, "Zero-size parameters are illegal" );
		if ( FParamSize == 0 )
		{
			return NULL;
		}

		if ( BufForParam )
		{
			/// New behaviour will be
			return new ( Where ) clScriptedPODParameter_Buffer( FParamSize, FParamSourceTypeName, BufForParam );
		}
		else
		{
			return new ( Where ) clScriptedPODParameter( FParamSize, FParamSourceTypeName );
		}
	}
}

clScriptedParam::~clScriptedParam()
{
}

clScriptMethod::clScriptMethod() : FCode( NULL ), FResultDescription( NULL )
{
}

void clScriptMethod::AfterConstruction()
{
	FCode = Env->Linker->Instantiate( "clCodePatch" );
}

bool clScriptMethod::BeginLoad()
{
	return true;
}

bool clScriptMethod::EndLoad()
{
	if ( FResultDescription && ( FResultDescription->FParamSize > 0 ) )
	{
		SetReturnValue( FResultDescription->CreateParameter() );
	}
	else
	{
		SetReturnValue( NULL );
	}

	return true;
}

clScriptMethod::~clScriptMethod()
{
	delete( FCode );
	TODO( "delete arrays" )
}

iParameter* clScriptMethod::CreateParameter( int Index, void* InitialValue )
{
	iParameter* Param = FParameters[Index]->CreateParameter();

	if ( InitialValue ) { Param->ReadValue( InitialValue ); }

	return Param;
}

bool clScriptMethod::CreateParameters( iParameter** Params, void** ParamBuffers, void** ValueBuffers, void** InitialValues )
{
	for ( size_t j = 0 ; j < FParameters.size(); j++ )
	{
		Params[j] = FParameters[j]->CreateParameter_Buf( ParamBuffers[j], ValueBuffers[j] );

		if ( InitialValues[j] ) { Params[j]->ReadValue( InitialValues[j] ); }
	}

	return true;
}

bool clScriptMethod::InvokeFast( void* ObjectAddr, iParameter** Params )
{
	// Just like Invoke(), but without clParametersList

	return true;
}

void clScriptMethod::Invoke( void* ObjectAddr, clParametersList& Params )
{
	guard( "%s", GetMethodName().c_str() );

	iObject* NativeObject = static_cast<iObject*>( ObjectAddr );

	bool    IsStatic        = ( NativeObject == NULL );
	LString NativeClassName = IsStatic ? "" : LString( NativeObject->ClassName() );

	// Native object can be NULL if it is a static method

	// check parameters integrity
	FATAL( FParameters.size() != Params.size(),
	       ( NativeClassName + "::" ) + GetMethodName() + "()\n" +
	       "Expected " + LStr::ToStr( ( int )FParameters.size() ) + " parameters, but got " + LStr::ToStr( ( int )Params.size() ) + " parameters" );

	for ( size_t i = 0; i != Params.size(); ++i )
	{
		FATAL( FParameters[i]->FParamSize != Params[i]->GetParamSize(),
		       ( NativeClassName + "::" ) + GetMethodName() + "()\n" +
		       "Parameter " + LStr::ToStr( ( int )i ) + " size missmatch: got " + LStr::ToStr( ( int )Params[i]->GetParamSize() ) + " bytes, but expected " + LStr::ToStr( FParameters[i]->FParamSize ) + " bytes" );
	}

	clExecutionThread ExecutionThread;
	ExecutionThread.Env = Env;

	TODO( "update execution thread !" )
//   ExecutionThread.Execute( this, FCode, ObjectAddr, Params );

	if ( GetReturnValue() )
	{
		GetReturnValue()->PopFromStack( ExecutionThread.GetStack() );
	}

	if ( !IsStatic )
	{
		NativeObject->SetReturnValue( GetReturnValue() );
	}

	FATAL( !ExecutionThread.GetStack()->empty(),
	       "Scripted method \"" + ( NativeClassName + "::" ) + GetMethodName() + "()" + ( IsStatic ? "" : "\"[" + NativeObject->GetActiveState()->GetStateName() + "] " ) + " left " + LStr::ToStr( ExecutionThread.GetStack()->size() ) + " bytes in the VM stack. \nThe method should clean the stack on exit." )

	unguard();
}

void* clScriptField::GetFieldPtr( iObject* obj )
{
	return reinterpret_cast<iObject*>( obj )->GetFieldPtr( GetFieldName() );
}

void clScriptField::Resize( iObject* obj, int NewSize )
{
	FFieldSize = NewSize;
	reinterpret_cast<iObject*>( obj )->ResizeField( GetFieldName(), NewSize );
}

bool clScriptClass::BeginLoad()
{
	return true;
}

bool clScriptClass::EndLoad()
{
	/// register custom states, scripted fields and methods

	for ( size_t i = 0 ; i < FScriptFields.size() ; i++ )
	{
		RegisterField( FScriptFields[i] );
	}

	for ( size_t i = 0 ; i < FScriptStates.size() ; i++ )
	{
		RegisterState( FScriptStates[i] );
	}

	// finally, build linear lists
	BuildVirtualTables();
	return true;
}

LString clScriptClass::ClassName() const
{
	return FClassName;
}

iStaticClass* clScriptClass::FindFirstNativeClass( iStaticClass* TheClass ) const
{
	if ( !TheClass )
	{
		return 0;
	}

	if ( dynamic_cast<const clScriptClass*>( TheClass ) != 0 )
	{
		// it is not native !
		iStaticClass* SuperClass = TheClass->GetSuperClass();

		if ( SuperClass )
		{
			return FindFirstNativeClass( SuperClass );
		}
	}
	else
	{
		// we have found the class
		return TheClass;
	}

	return 0;
}

void clScriptClass::CallInitCode( iObject* Tunneller, const iStaticClass* TheClass ) const
{
	iStaticClass* SuperClass = TheClass->GetSuperClass();

	if ( SuperClass )
	{
		CallInitCode( Tunneller, SuperClass );
	}

	LString InitMethodName = "__" + LString( TheClass->ClassName() ) + "__std__init__code__";

	clParametersList ZeroParams;

	Tunneller->CallMethod( InitMethodName, ZeroParams, false );
}

void clScriptClass::RegisterNonNativeFields( iObject* Object ) const
{
	// now register scripted fields
	for ( std::map<LString, iField*>::const_iterator f = FFields.begin(); f != FFields.end(); ++f )
	{
		Object->RegisterField( ( f->second )->GetFieldName(), ( f->second )->GetFieldSize() );
	}

	// check superclass
	iStaticClass* SuperClass = GetSuperClass();

	if ( SuperClass )
	{
		SuperClass->RegisterNonNativeFields( Object );
	}
}

iObject* clScriptClass::VirtualConstructor( const clParametersList& Params ) const
{
	if ( FTunneller == NULL )
	{
		// automatically search parent classes for the first native one
		if ( FSuperClass != NULL )
		{
			FTunneller = Env->Linker->FindStaticClass( LString( FSuperClass->ClassName() ) + "_Tunneller" );
			//FindFirstNativeClass(this);
		}
	}

	if ( FTunneller == NULL )
	{
		iStaticClass* NativeClass = FindFirstNativeClass( const_cast<clScriptClass*>( this ) );

		if ( NativeClass )
		{
			FTunneller = Env->Linker->FindStaticClass( LString( NativeClass->ClassName() ) + "_Tunneller" );
		}
	}

	// if the tunneller cannot be found - it is an error
	RAISE_MSG_IF ( FTunneller == NULL,
	               clExcept_TunnellerIsNotDefined,
	               FClassName );

	iObject* Obj = FTunneller->VirtualConstructor( Params );

	iObject* Tunneller = ::Linderdaum::Utils::guarded_cast<iObject*>( Obj, "Tunneller should be derived from iObject", Env );

	Tunneller->SetStaticClass( this );

	// now register scripted fields
	RegisterNonNativeFields( Tunneller );

	// and finally, run the "pseudo-constructor" (init code)
	CallInitCode( Tunneller, this );

	return Tunneller;
}

int clScriptClass::GetConstructorParamsCount( size_t ConstructorID ) const
{
	return 0;
}


clCodePatch::clCodePatch()
{
}

bool clCodePatch::AssembleLine( const LString& InstrName, const LString& Args, LString& ErrorCode )
{
	sInstruction Instr;

	if ( LStr::IsLastChar( InstrName, ':' ) )
	{
		// emit label
		if ( FLabelsTable.find( InstrName ) != FLabelsTable.end() )
		{
			ErrorCode = "Duplicate label: " + InstrName;

			return false;
		}

		FLabelsTable[ InstrName ] = static_cast<int>( FInstructions.size() );

		return true;
	}

	Instr.FOpCode = SymOpCode2OpCode( InstrName );

//   FATAL( Instr.FOpCode == OP_INVALID,  );
	if ( Instr.FOpCode == OP_INVALID )
	{
		ErrorCode = "Invalid opcode: " + InstrName;
		return false;
	}

	Instr.FArgsType = ARGS_STACK_STACK;

	if ( InstrName == "LOAD_STRING_CONST" )
	{
		LString Param = Args;
		LStr::TrimBrackets( &Param );

		Instr.FArgsType  = ARGS_STRING;
		Instr.FArgInt[0] = EmitString( Param );
	}
	else
		for ( int i = 0; i != 2; ++i )
		{
			LString Param = LStr::GetToken( Args, i + 1 );

			if ( !Param.empty() )
			{
				if ( LStr::IsCorrectBool( Param ) )
				{
					Instr.FIntArgs[i] = true;
					// store as integer
					Instr.FArgInt[i] = static_cast<int>( LStr::ToBool( Param ) );
				}
				else if ( LStr::IsCorrectInt( Param ) )
				{
					Instr.FIntArgs[i] = true;
					Instr.FArgInt[i] = LStr::ToInt( Param );
				}
				else if ( LStr::IsCorrectDouble( Param ) )
				{
					Instr.FIntArgs[i] = false;
					Instr.FArgFloat[i] = LStr::ToFloat( Param );
				}
				else
				{
					Instr.FArgsType = ARGS_STRING;

//            FATAL( i == 1, "Number expected as the second arg" );
					if ( i == 1 )
					{
						ErrorCode = "Number expected as the second arg";
						return false;
					}

					if ( LStr::IsLastChar( Param, ':' ) )
					{
						Instr.FFlag = FLAG_LABEL;

						Instr.FArgInt[i] = this->GetLabelLink( Param );

						continue;
					}
					else
					{
						// pack string
						Instr.FArgInt[i] = EmitString( Param );

						break;
					}
				}

				if ( i == 0 )
				{
					Instr.FArgsType = ARGS_STACK_PARAM;
				}

				if ( i == 1 )
				{
					Instr.FArgsType = ARGS_PARAM_PARAM;
				}
			}
		}

	FInstructions.push_back( Instr );

	return true;
}

bool clCodePatch::AssembleCode( const std::vector<LString>& ACode, LString& ResultType, LString& ErrorCode )
{
	ErrorCode  = "";

	LString LocalError;

	// extract first line (it is a result type)
	ResultType = ACode[0];

	for ( size_t i = 1 ; i < ACode.size() ; i++ )
	{
		LString s = ACode[i];

		LString Instr = LStr::GetUpper( LStr::GetToken( s, 1 ) );
		LString Args  = s.substr( Instr.length(), s.length() - Instr.length() );

		if ( Instr == ";" ) { continue; }

		// avoid trashing the Log
		Env->Logger->Log( L_NOTICE, "Instr/Args = " + Instr + "/" + Args );

		if ( !AssembleLine( Instr, Args, LocalError ) )
		{
			ErrorCode  = "Error assembling instruction (" + Instr + "/" + Args + ")\n";
			ErrorCode += LocalError;
			return false;
		}
	}

	return true;
}

int clCodePatch::EmitString( const LString& String )
{
	FStringTable.push_back( String );

	return static_cast<int>( FStringTable.size() );
}

LString clCodePatch::GetString( int Index ) const
{
	return FStringTable[Index-1];
}

LString* clCodePatch::GetStringPtr( int Index )
{
	return &( FStringTable[Index-1] );
}

int clCodePatch::GetStringsCount() const
{
	return static_cast<int>( FStringTable.size() );
}

int clCodePatch::GetLabelLink( const LString& String )
{
	FLabelLinks.push_back( String );

	return static_cast<int>( FLabelLinks.size() );
}

LString clCodePatch::InstructionToString( const sInstruction&  Instr ) const
{
	LOpCodes OpCode = Instr.FOpCode;

	// since code dump is only a debugging feature
	// we do not make any FATAL() calls here
	//      FATAL( OpCode > MAX_OPCODES, "Unknown upcode" );
	if ( OpCode > MAX_OPCODES )
	{
		return LString( "UnknownOpcode[" ) + LStr::ToStr( ( int )( OpCode ) ) + LString( "]" );
	}
	else
	{
		LString Args;

		if ( Instr.FFlag == FLAG_LABEL )
		{
			Args = FindLabelByIP( Instr.FArgInt[0] );
		}
		else
			switch ( Instr.FArgsType )
			{
				case ARGS_STACK_STACK:
					break;
				case ARGS_STACK_PARAM:
					Args = Instr.FIntArgs[0] ? LStr::ToStr( Instr.FArgInt[0] ) : LStr::ToStr( Instr.FArgFloat[0] );
					break;
				case ARGS_PARAM_PARAM:
					Args = Instr.FIntArgs[0] ? LStr::ToStr( Instr.FArgInt[0] ) : LStr::ToStr( Instr.FArgFloat[0] );
					Args += " " + Instr.FIntArgs[1] ? LStr::ToStr( Instr.FArgInt[1] ) : LStr::ToStr( Instr.FArgFloat[1] );
					break;
				case ARGS_STRING:
					Args = GetString( Instr.FArgInt[0] );
					break;
			}

		return LString( SymOpCodes[OpCode] ) + LString( " " ) + Args;
	}
}


bool clCodePatch::AssembleInstruction( const LString& Line, LString& ErrorCode )
{
	sInstruction Instr;

	LString InstrName = LStr::GetToken( Line, 1 );
	LString Args = "";

	if ( Line.length() > InstrName.length() )
	{
		Args = Line.substr( InstrName.length(), Line.length() - InstrName.length() );
	}

	if ( LStr::IsLastChar( InstrName, ':' ) )
	{
		// emit label
		if ( FLabelsTable.find( InstrName ) != FLabelsTable.end() )
		{
			ErrorCode = "Duplicate label: " + InstrName;

			return false;
		}

		FLabelsTable[ InstrName ] = static_cast<int>( FInstructions.size() );

		return true;
	}

	Instr.FOpCode = SymOpCode2OpCode( InstrName );

//   FATAL( Instr.FOpCode == OP_INVALID,  );
	if ( Instr.FOpCode == OP_INVALID )
	{
		ErrorCode = "Invalid opcode: " + InstrName;
		return false;
	}

	Instr.FArgsType = ARGS_STACK_STACK;

	if ( InstrName == "LOAD_STRING_CONST" )
	{
		LString Param = Args;
		LStr::TrimBrackets( &Param );

		Instr.FArgsType  = ARGS_STRING;
		Instr.FArgInt[0] = EmitString( Param );
	}
	else
		for ( int i = 0; i != 2; ++i )
		{
			LString Param = LStr::GetToken( Args, i + 1 );

			if ( !Param.empty() )
			{
				if ( LStr::IsCorrectBool( Param ) )
				{
					Instr.FIntArgs[i] = true;
					// store as integer
					Instr.FArgInt[i] = static_cast<int>( LStr::ToBool( Param ) );
				}
				else if ( LStr::IsCorrectInt( Param ) )
				{
					Instr.FIntArgs[i] = true;
					Instr.FArgInt[i] = LStr::ToInt( Param );
				}
				else if ( LStr::IsCorrectDouble( Param ) )
				{
					Instr.FIntArgs[i] = false;
					Instr.FArgFloat[i] = LStr::ToFloat( Param );
				}
				else
				{
					Instr.FArgsType = ARGS_STRING;

//            FATAL( i == 1, "Number expected as the second arg" );
					if ( i == 1 )
					{
						ErrorCode = "Number expected as the second arg";
						return false;
					}

					if ( LStr::IsLastChar( Param, ':' ) )
					{
						Instr.FFlag = FLAG_LABEL;

						Instr.FArgInt[i] = this->GetLabelLink( Param );

						continue;
					}
					else
					{
						// pack string
						Instr.FArgInt[i] = EmitString( Param );

						break;
					}
				}

				if ( i == 0 )
				{
					Instr.FArgsType = ARGS_STACK_PARAM;
				}

				if ( i == 1 )
				{
					Instr.FArgsType = ARGS_PARAM_PARAM;
				}
			}
		}

	FInstructions.push_back( Instr );

	return true;
}

bool clCodePatch::Reassemble()
{
	LString FLastError = "";

	for ( size_t i = 0 ; i < FSource.size() ; i++ )
	{
		if ( !AssembleInstruction( FSource[i], FLastError ) )
		{
			return false;
		}
	}

	// and link
	return Link( FLastError );
}

// disassembler / debug code dump
bool clCodePatch::Disassemble()
{
	clInstructions& Instructions = GetInstructions();

	int LabelOffset = -1;

	FSource.clear();

	for ( size_t i = 0; i != Instructions.size(); ++i )
	{
		LString Label = FindLabelByIP( static_cast<int>( i ) + LabelOffset );

		FSource.push_back( InstructionToString( Instructions[i] ) );
	}

	return true;
}

bool clCodePatch::Link( LString& ErrorCode )
{
#ifdef CODE_PATCH__HEAVY_DEBUG
	Env->Logger->Log( L_NOTICE, "Optimizing..." );

	size_t InstrUnOpt = FInstructions.size();
#endif

	while ( Optimize() );

#ifdef CODE_PATCH__HEAVY_DEBUG
	size_t InstrOpt = FInstructions.size();
#endif

	int DeclaredVars = 0;

	for ( size_t i = 0; i != FInstructions.size(); ++i )
	{
		// 1. track variable declarations
		if ( FInstructions[i].FOpCode == OP_DECLARE )
		{
			DeclaredVars++;
		}

		if ( FInstructions[i].FOpCode == OP_UNDECLARE )
		{
			DeclaredVars--;
		}

		FInstructions[i].FDeclaredVars = DeclaredVars;

		// 2. calculate label addresses
		if ( FInstructions[i].FFlag & FLAG_LABEL )
		{
			LString LabelName = FLabelLinks[ FInstructions[i].FArgInt[0] - 1 ];

			LStr::ToUpper( &LabelName );

			clLabelsTable::const_iterator LabelIP = FLabelsTable.find( LabelName );

//         FATAL( LabelIP == FLabelsTable.end(), "Label not found: "+LabelName );
			if ( LabelIP == FLabelsTable.end() )
			{
				ErrorCode = "Label not found: " + LabelName;
				return false;
			}

			FInstructions[i].FArgInt[0] = LabelIP->second - 1;
		}

		// 3. get actual address for the global vars
		//    replace symbolic name by linear index
		if ( FInstructions[i].FOpCode == OP_LOAD_GLOBAL_VAR_ADDRESS )
		{
			LString VarName = GetString ( FInstructions[i].FArgInt[0] );
			int VarIdx = Env->Linker->GetGlobalVarIndex( VarName );

			if ( VarIdx == -1 )
			{
//          FATAL_MSG("Cannot find global variable while linking : "+VarName);
//            ErrorCode = "Cannot find global variable while linking : "+VarName;
//            return false;
			}

			// if VarIdx is -1 it is ok - we will link it later
			FInstructions[i].FArgInt[1] = VarIdx;
		}

		// 4. convert static method names to indices
		if ( FInstructions[i].FOpCode == OP_CALL_STATIC_METHOD )
		{
			LString MtdName = GetString ( FInstructions[i].FArgInt[0] );

			int MtdIdx = Env->Linker->GetStaticMethodIndex( MtdName );
			/*
			         if (MtdIdx == -1)
			         {
			            FATAL_MSG("Cannot find static method while linking : "+MtdName);
			         }
			*/
			FInstructions[i].FArgInt[1] = MtdIdx;
		}
	}

	FLabelLinks.resize( 0 );

#ifdef CODE_PATCH__HEAVY_DEBUG
	//
	// DEBUG: dump all instructions into logfile
	//

	Env->Logger->Log( L_NOTICE, "Dumping optimized listing:" );

	mlNode* Node = NULL;
	Env->Linker->SaveObject( this, &Node );

	Env->FileSystem->SaveXLMLToLog( Node );

	delete Node;

	Env->Logger->Log( L_NOTICE, "Instructions before: " + LStr::ToStr( InstrUnOpt ) );
	Env->Logger->Log( L_NOTICE, "Instructions after : " + LStr::ToStr( InstrOpt ) );
#endif

	return true;
}

LString clCodePatch::FindLabelByIP( int IP ) const
{
	guard();

	int LabelIndex = IP + 1;

	for ( clLabelsTable::const_iterator j = FLabelsTable.begin();
	      j != FLabelsTable.end();
	      ++j )
	{
		if ( LabelIndex == ( *j ).second )
		{
			return ( *j ).first;
		}
	}

	return "";

	unguard();
}

void clCodePatch::CollapseInstructions( int FromIP, int Skip )
{
	// collapse instructions into 1
	for ( int i = FromIP + 1; i < static_cast<int>( FInstructions.size() ) - Skip; ++i )
	{
		FInstructions[ i ] = FInstructions[i+Skip];
	}

	// update labels
	for ( clLabelsTable::iterator j = FLabelsTable.begin();
	      j != FLabelsTable.end();
	      ++j )
	{
		if ( ( *j ).second > FromIP )
		{
			( *j ).second -= Skip;
		}
	}

	// remove last instructions
	for ( int i = 0; i != Skip; ++i )
	{
		FInstructions.pop_back();
	}
}

bool clCodePatch::Optimize()
{
	bool WasOptimized = false;

	int InstructionPointer = 0;

	sInstruction Instr0, Instr1, Instr2;
	sInstruction Result;

	while ( InstructionPointer < static_cast<int>( FInstructions.size() ) - 3 )
	{
		Instr0 = FInstructions[ InstructionPointer+0 ];
		Instr1 = FInstructions[ InstructionPointer+1 ];
		Instr2 = FInstructions[ InstructionPointer+2 ];

		if ( PeepholeOptimizeTriplet( Instr0, Instr1, Instr2, &Result ) )
		{
			WasOptimized = true;

			FInstructions[ InstructionPointer ] = Result;

			CollapseInstructions( InstructionPointer, 2 );

#ifdef CODE_PATCH__HEAVY_DEBUG
			LOpCodes OpCode0 = Instr0.FOpCode;
			LOpCodes OpCode1 = Instr1.FOpCode;
			LOpCodes OpCode2 = Instr2.FOpCode;
			Env->Logger->Log( L_DEBUG, "Opcodes optimization:" );
			Env->Logger->Log( L_DEBUG, LString( "   " ) + SymOpCodes[OpCode0] + LString( " " ) + LStr::ToStr( Instr0.FArgInt[0] ) );
			Env->Logger->Log( L_DEBUG, LString( "   " ) + SymOpCodes[OpCode1] + LString( " " ) + LStr::ToStr( Instr1.FArgInt[0] ) );
			Env->Logger->Log( L_DEBUG, LString( "   " ) + SymOpCodes[OpCode2] + LString( " " ) + LStr::ToStr( Instr2.FArgInt[0] ) );
			Env->Logger->Log( L_DEBUG, "Converted into:" );
			Env->Logger->Log( L_DEBUG, LString( "   " ) + SymOpCodes[Result.FOpCode] + LString( " " ) + LStr::ToStr( Result.FArgInt[0] ) );
#endif
		}
		else if ( PeepholeOptimizePair( Instr0, Instr1, &Result ) )
		{
			WasOptimized = true;

			FInstructions[ InstructionPointer ] = Result;

			CollapseInstructions( InstructionPointer, 1 );

#ifdef CODE_PATCH__HEAVY_DEBUG
			LOpCodes OpCode0 = Instr0.FOpCode;
			LOpCodes OpCode1 = Instr1.FOpCode;

			Env->Logger->Log( L_DEBUG, "Opcodes optimization:" );
			Env->Logger->Log( L_DEBUG, LString( "   " ) + SymOpCodes[OpCode0] + LString( " " ) + LStr::ToStr( Instr0.FArgInt[0] ) );
			Env->Logger->Log( L_DEBUG, LString( "   " ) + SymOpCodes[OpCode1] + LString( " " ) + LStr::ToStr( Instr1.FArgInt[0] ) );
			Env->Logger->Log( L_DEBUG, "Converted into:" );
			Env->Logger->Log( L_DEBUG, LString( "   " ) + SymOpCodes[Result.FOpCode] + LString( " " ) + LStr::ToStr( Result.FArgInt[0] ) );
#endif
		}
		else if ( IsDeadInstruction( Instr0 ) )
		{
			WasOptimized = true;

			CollapseInstructions( InstructionPointer - 1, 1 );

#ifdef CODE_PATCH__HEAVY_DEBUG
			Env->Logger->Log( L_DEBUG, "Dead instruction eliminated:" );
			Env->Logger->Log( L_DEBUG, LString( "   " ) + SymOpCodes[Instr0.FOpCode] + LString( " " ) + LStr::ToStr( Instr0.FArgInt[0] ) );
#endif
		}

		InstructionPointer++;
	}

	return WasOptimized;
}

bool clCodePatch::IsDeadInstruction( const sInstruction& Instr )
{
	if ( Instr.FOpCode == OP_POP_BYTES &&
	     Instr.FArgInt[0] == 0 )
	{
		return true;
	}

	if ( Instr.FOpCode == OP_ADD_OFFSET &&
	     Instr.FArgInt[0] == 0 )
	{
		return true;
	}

	return false;
}

bool clCodePatch::PeepholeOptimizePair( const sInstruction& Instr1,
                                        const sInstruction& Instr2,
                                        sInstruction* OutInstruction )
{
	if ( Instr1.FOpCode == OP_LOAD_INT &&
	     Instr2.FOpCode == OP_POP_BYTES &&
	     Instr2.FArgInt[0] == 4 )
	{
		( *OutInstruction ) = Instr1;
		OutInstruction->FOpCode = OP_SLOAD_INT;

		return true;
	}
	else if ( Instr1.FOpCode == OP_LOAD_FLOAT &&
	          Instr2.FOpCode == OP_POP_BYTES &&
	          Instr2.FArgInt[0] == 4 )
	{
		( *OutInstruction ) = Instr1;
		OutInstruction->FOpCode = OP_SLOAD_FLOAT;

		return true;
	}
	else if ( Instr1.FOpCode == OP_PUSH_INT &&
	          Instr2.FOpCode == OP_SLOAD_INT )
	{
		( *OutInstruction ) = Instr1;
		OutInstruction->FOpCode = OP_SLOAD_INT_IMM;

		return true;
	}
	else if ( Instr1.FOpCode == OP_PUSH_FLOAT &&
	          Instr2.FOpCode == OP_SLOAD_FLOAT )
	{
		( *OutInstruction ) = Instr1;
		OutInstruction->FOpCode = OP_SLOAD_FLOAT_IMM;

		return true;
	} /*else

   if ( Instr1.FOpCode == OP_LOAD_LOCAL_VAR_ADDRESS &&
        Instr2.FOpCode == OP_LOAD_VAL_FROM_CUR_ADDR )
   {
      (*OutInstruction) = Instr1;
      OutInstruction->FArgInt[0] = Instr1.FArgInt[0];
      OutInstruction->FArgInt[1] = Instr2.FArgInt[0];
      OutInstruction->FOpCode = OP_LOAD_LOCAL_VAR;

      return true;
   }
*/
	return false;
}

bool clCodePatch::PeepholeOptimizeTriplet( const sInstruction& Instr1,
                                           const sInstruction& Instr2,
                                           const sInstruction& Instr3,
                                           sInstruction* OutInstruction )
{
	// Currently can optimize only offsets, i.e.:
	//    PUSH_INT 0
	//    PUSH_INT 4
	//    ADD_INT_INT
	// is converted into:
	//    PUSH_INT 4

	/*
	   MAJOR TODO:
	         1) arithmetics
	         2) loading of immediate value, i.e.:
	               PUSH_FLOAT 0.0
	               LOAD_FLOAT
	            into:
	               LOAD_FLOAT 0.0

	*/

	/*
	   PUSH_INT 0
	   CALL_METHOD  -> CALL_STATIC_METHOD
	*/

	/*
	   Convert LOAD_EFFECTIVE_ADDRESS <static symbol> into PUSH_ADDR <const>
	*/

	if ( Instr1.FOpCode == OP_PUSH_INT &&
	     Instr2.FOpCode == OP_PUSH_INT &&
	     Instr3.FOpCode == OP_ADD_INT_INT )
	{
		( *OutInstruction ) = Instr1;
		OutInstruction->FArgInt[0] = Instr1.FArgInt[0] + Instr2.FArgInt[0];

		return true;
	}

	return false;
}


//////////////// Virtual machine core

/**
 * \file ExecThread.cpp
 * \brief LinderScript virtual machine execution thread
 * \version 0.5.74
 * \date 30/07/2007
 * \author Sergey Kosarevsky, 2005-2007
 * \author Viktor Latypov, 2007
 * \author support@linderdaum.com http://www.linderdaum.com
 */


static int     OpCodesUsageFreq[MAX_OPCODES+1];
static double  OpCodesUsageTime[MAX_OPCODES+1];
static std::vector<int> OpcodesStatsToSort;

bool SortStatsByFreq( int Idx1, int Idx2 )
{
	return OpCodesUsageFreq[ Idx1 ] > OpCodesUsageFreq[ Idx2 ];
}

bool SortStatsByTime( int Idx1, int Idx2 )
{
	return OpCodesUsageTime[ Idx1 ] > OpCodesUsageTime[ Idx2 ];
}

void clExecutionThread::ClearExecutionStats()
{
	for ( int i = 0; i != MAX_OPCODES + 1; i++ )
	{
		OpCodesUsageFreq[ i ] = 0;
		OpCodesUsageTime[ i ] = 0;
	}
}

void clExecutionThread::LogExecutionStats( sEnvironment* Env )
{
	OpcodesStatsToSort.clear();

	for ( int i = 0; i != MAX_OPCODES + 1; i++ )
	{
		OpcodesStatsToSort.push_back( i );
	}

	std::sort( OpcodesStatsToSort.begin(), OpcodesStatsToSort.end(), SortStatsByFreq );

	for ( int i = 0; i != MAX_OPCODES + 1; i++ )
	{
		int Idx = OpcodesStatsToSort[i];

		if ( OpCodesUsageFreq[Idx] > 10 )
		{
			LString OpCodeName = SymOpCodes[Idx];

			LStr::PadRight( &OpCodeName, 25, ' ' );

			Env->Logger->Log( L_NOTICE, LString( "Opcode: " ) + OpCodeName + " usage freq. " + LStr::ToStr( OpCodesUsageFreq[Idx] ) );
		}
	}

	std::sort( OpcodesStatsToSort.begin(), OpcodesStatsToSort.end(), SortStatsByTime );

	double TotalTime = 0.0;

	for ( int i = 0; i != MAX_OPCODES + 1; i++ )
	{
		TotalTime += OpCodesUsageTime[ i ];
	}

	for ( int i = 0; i != MAX_OPCODES + 1; i++ )
	{
		int Idx = OpcodesStatsToSort[i];

		if ( OpCodesUsageTime[Idx] > 0.01 )
		{
			LString OpCodeName = SymOpCodes[Idx];

			LStr::PadRight( &OpCodeName, 25, ' ' );

			LString Percent = LStr::ToStr( ( OpCodesUsageTime[Idx] / TotalTime ) * 100.0, 3 );

			Env->Logger->Log( L_NOTICE, LString( "Opcode: " ) + OpCodeName + " usage time  " + LStr::ToStr( OpCodesUsageTime[Idx], 3 ) + " (" + Percent + "%)" );
		}
	}


}

class clFieldSymbolDeclaration : public iSymbolDeclaration
{
public:
	clFieldSymbolDeclaration() : FField( NULL ), FObject( NULL ) {}
	virtual ~clFieldSymbolDeclaration() {}

	virtual VMPTR GetSymbolAddress()
	{
		return FField->GetFieldPtr( FObject );
	}

	virtual void Resize( int NewSize )
	{
		FField->Resize( FObject, NewSize );
	}
public:
	iObject*    FObject;
	iField*     FField;
};

class clParamSymbolDeclaration : public iSymbolDeclaration
{
public:
	clParamSymbolDeclaration( const LString& ParamName, iParameter* Param ) : FParamName( ParamName ), FParameter( Param ) {}
	virtual ~clParamSymbolDeclaration() {}
	virtual VMPTR GetSymbolAddress()
	{
		return FParameter->GetNativeBlock();
	}
	virtual void Resize( int NewSize )
	{
		//FATAL_MSG( "Cannot resize parameter container : " + FParamName );
	}
public:
	iParameter*    FParameter;
	LString        FParamName;
};

class clVarSymbolDeclaration : public iSymbolDeclaration
{
public:
	clVarSymbolDeclaration( const LString& VarName, int Size )
	{
		FBuffer = NULL;
		Resize( Size );

		FVarName = VarName;
	}

	virtual ~clVarSymbolDeclaration()
	{
		delete [] FBuffer;
	}

	virtual void Resize( int NewSize )
	{
		if ( FBuffer != NULL )
		{
			delete [] FBuffer;
		}

		if ( NewSize > 0 )
		{
			FBuffer = new char[NewSize];
		}

		FSize = NewSize;
	}

	virtual VMPTR GetSymbolAddress()
	{
		return reinterpret_cast<VMPTR>( FBuffer );
	}
public:
	LString    FVarName;
	char*      FBuffer;
	int        FSize;
};

////////////// Wicked macros


// standart procedure header
#define VM_CODE__EXECUTOR_HEADER(OpCode) void clExecutionThread::Opcode_##OpCode () {

// stack pop
#define VM_GET_VAL_FROM_STACK(destType,varName) \
      destType varName = FStack.Pop<destType>();

#define VM_PUSH_TO_STACK(type,expr) \
      FStack.Push<type>(expr)


////////////// End of wicked macros


clExecutionThread::clExecutionThread(): Env( NULL ),
	FCurrentNativeObject( NULL ),
	FCurrentParameters( NULL ),
	FParamSymbols(),
	FCurrentCodePatch( NULL )
{
	FFieldSymbol = new clFieldSymbolDeclaration();
}

clExecutionThread::~clExecutionThread()
{
	delete FFieldSymbol;
}

void clExecutionThread::Execute( clScriptMethod* Method, clCodePatch* CodePatch, void* Self, clParametersList& Params )
{
	FCurrentNativeObject = Self;
	FCurrentParameters   = &Params;
	FCurrentCodePatch    = CodePatch;
	FCurrentMethod       = Method;

	clInstructions& Instructions = CodePatch->GetInstructions();

	FInstructionPointer = 0;
	FMaxInstructions = static_cast<int>( Instructions.size() );

	// register symbols for parameters
	for ( size_t i = 0 ; i != Params.size() ; i++ )
	{
		FParamSymbols.push_back( new clParamSymbolDeclaration( Method->GetParamName( static_cast<int>( i ) ), Params[i] ) );
	}

	while ( FInstructionPointer < FMaxInstructions )
	{
		FCurrentInstructionPtr = &Instructions[ FInstructionPointer ];
		FCurrentInstruction = Instructions[ FInstructionPointer ];

		LOpCodes OpCode = FCurrentInstruction.FOpCode;
		/*
		      printf("Opcode: %s   ", SymOpCodes[OpCode] );
		      printf("ArgInt[0]: %i   ", FCurrentInstruction.FArgInt[0] );
		      if ( FCurrentInstruction.FFlag & FLAG_LABEL )
		      {
		         printf("Label = %s   ", CodePatch->GetString( FCurrentInstruction.FArgInt[1] ).c_str() );
		      }
		      printf("Flag =  %i   \n", int(FCurrentInstruction.FFlag) );
		*/

		RAISE_MSG_IF( OpCode > MAX_OPCODES, clExcept_InvalidOpCode, LStr::ToStr( OpCode ) );

		// increment usage statistics
		OpCodesUsageFreq[OpCode]++;

		double StartTime = Env->GetSeconds();

		( this->*executors[OpCode] )();

		// increment timing statistics
		OpCodesUsageTime[OpCode] += Env->GetSeconds() - StartTime;

		FInstructionPointer++;
	}

	// deallocate FParamSymbols on exit
	Utils::Deallocate( FParamSymbols.begin(), FParamSymbols.end() );
}

LString clExecutionThread::ExtractString()
{
	if ( FCurrentInstruction.FArgInt[0] > 0 )
	{
		return FCurrentCodePatch->GetString( FCurrentInstruction.FArgInt[0] );
	}
	else
	{
		int StringID = FStack.Pop<int>();

		return FCurrentCodePatch->GetString( StringID );
	}
}

LString* clExecutionThread::ExtractStringPtr()
{
	if ( FCurrentInstruction.FArgInt[0] > 0 )
	{
		return FCurrentCodePatch->GetStringPtr( FCurrentInstruction.FArgInt[0] );
	}
	else
	{
		int StringID = FStack.Pop<int>();

		return FCurrentCodePatch->GetStringPtr( StringID );
	}
}

void clExecutionThread::RecursiveEnter()
{
	for ( size_t i = 0; i != FCurrentParameters->size(); ++i )
	{
		( *FCurrentParameters )[i]->PushToStack( &FRecursionStack );
		( *FCurrentParameters )[i]->PopFromStack( &FStack );
	}

	FRecursionStack.Push<Lint>( FInstructionPointer );
}

void clExecutionThread::RecursiveLeave()
{
	for ( size_t i = 0; i != FCurrentParameters->size(); ++i )
	{
		( *FCurrentParameters )[i]->PopFromStack( &FRecursionStack );
	}
}

/*
    Opcodes executors
*/

void clExecutionThread::Opcode_INVALID()
{
	FATAL_MSG( "Invalid opcode" );
}

void clExecutionThread::Opcode_NOP()
{
}

void clExecutionThread::Opcode_HLT()
{
	Opcode_RETURN();
}

void clExecutionThread::Opcode_PUSH_REF()
{
	VM_GET_VAL_FROM_STACK( iObject**, _objRefPtr );

	FStack.Push<iObject*>( *_objRefPtr );
}

void clExecutionThread::Opcode_LOAD_STR()
{
	/* TODO: мRж_т быть <учш_ как-тR так?

	   LStringBuffer StrBuf = FStack.Pop<LStringBuffer>();

	   VM_GET_VAL_FROM_STACK( char*, charAddr )

	   FStack.Push<LStringBuffer>( StrBuf );

	   memcpy( charAddr, &StrBuf, 256 );

	   ...и<и даж_ сд_<ать м_тRд LoadBytesIntoPtr(int NumBytes) в iStack ?
	   т._. R- смRж_т этR сд_<ать -_пRср_дств_--R б_з <иш-их кRпирRва-иc
	*/

	/*
	   LString str = FStack.Pop<LString>();
	   VM_GET_VAL_FROM_STACK(char*, charAddr)

	   FStack.Push<LString>(str);

	   // 255 or more ?
	   for (size_t i = 0 ; i < str.length() ; i++) {
	      charAddr[i] = str.at(i);
	   }
	   for (size_t i = str.length() ; i < BufferSize ; i++) {
	      charAddr[i] = 0;
	   }
	*/

	TODO( "avoid magic constants (BufferSize) and do not push/pop" )

	VM_GET_VAL_FROM_STACK( char*, charAddr )
	LString str = FStack.Pop<LString>();
	FStack.Push<LString>( str );

	// 255 or more ?
	for ( size_t i = 0 ; i < str.length() ; i++ )
	{
		charAddr[i] = str.at( i );
	}

	for ( size_t i = str.length() ; i < LStr::BufferSize ; i++ )
	{
		charAddr[i] = 0;
	}
}

void clExecutionThread::Opcode_LOAD_STRING_CONST()
{
	guard();

	FStack.Push<LString>( ExtractString() );

	unguard();
}

void clExecutionThread::Opcode_LOAD_BYTES()
{
	int NumBytes = FCurrentInstruction.FArgInt[0];

	if ( NumBytes < 0 )
	{
		// use stack to extract type
		VM_GET_VAL_FROM_STACK( int, numBytes );

		NumBytes = numBytes;
	}

	/*
	   char *TmpBuf = new char[NumBytes];
	   FStack.PopBytes(NumBytes, TmpBuf);

	   char *RealAddr = FStack.Pop<char *>();

	   memcpy(RealAddr, TmpBuf, NumBytes);

	   FStack.PushBytes(NumBytes, TmpBuf);

	   delete [] TmpBuf;
	*/

	// NEW_CODE for reverse order :
	char* RealAddr = FStack.Pop<char*>();

	// do not push/pop anything
	memcpy( RealAddr, FStack.GetPtr( FStack.size() - NumBytes ), NumBytes );
}

void clExecutionThread::Opcode_REPLICATE_STACK_TOP()
{
	// pop <N> bytes and push them twice
	int _sz = FCurrentInstruction.FArgInt[0];

	if ( _sz < 0 )
	{
		VM_GET_VAL_FROM_STACK( int, _num );
		_sz = _num;
	}

	FStack.PushRepBytes<Lubyte>( _sz );
}

void clExecutionThread::Opcode_PUSH_BYTES()
{
	// push <N> bytes from current address
	int _n = FCurrentInstruction.FArgInt[0];

	if ( _n < 0 )
	{
		VM_GET_VAL_FROM_STACK( int, _num );
		_n = _num;
	}

	VM_GET_VAL_FROM_STACK( char*, charAddr )

	FStack.PushBytes( _n, charAddr );
}

void clExecutionThread::Opcode_POP_BYTES()
{
	int _sz = FCurrentInstruction.FArgInt[0];

	if ( _sz < 0 )
	{
		VM_GET_VAL_FROM_STACK( int, num )
		_sz = num;
	}

	FStack.PopEmptyBytes( _sz );
}

void clExecutionThread::Opcode_DISP_BYTE()
{
	VM_GET_VAL_FROM_STACK( Lubyte, UB );
	printf( "%i", UB );
}

void clExecutionThread::Opcode_DISP_INT()
{
	VM_GET_VAL_FROM_STACK( int, I );
	printf( "%i", I );
}

void clExecutionThread::Opcode_DISP_DOUBLE()
{
	VM_GET_VAL_FROM_STACK( double, D );
	printf( "%f", D );
}

void clExecutionThread::Opcode_DISP_FLOAT()
{
	VM_GET_VAL_FROM_STACK( float, F );
	printf( "%f", F );
}

void clExecutionThread::Opcode_DISP_STRING()
{
	guard();

	LString String;

	if ( FCurrentInstruction.FArgInt[0] > 0 )
	{
		String = FCurrentCodePatch->GetString( FCurrentInstruction.FArgInt[0] );
	}
	else
	{
		String = FStack.Pop<LString>();
	}

	printf( "%s", String.c_str() );

	unguard();
}

void clExecutionThread::Opcode_FEED_LINE()
{
	printf( "\n" );
}

void clExecutionThread::Opcode_MOD_INT_INT()
{
	Lint Arg2 = FStack.Pop<Lint>();
	Lint Arg1 = FStack.Pop<Lint>();

	FATAL( Arg2 < ::Linderdaum::Math::EPSILON, "Opcode_MOD_INT_INT(): Division by zero: Arg2 == 0" );

	FStack.Push( Arg1 % Arg2 );
}

void clExecutionThread::Opcode_LOAD_SELF()
{
	FStack.Push( FCurrentNativeObject );
}

void clExecutionThread::CallMethod( iObject* NativeObject,
                                    iMethod* Method,
                                    int Inherited )
{
	guard( "%s,%i", Method->GetMethodName().c_str(), Inherited );

	LString CurMtdName( "" );

	if ( FCurrentMethod != NULL )
	{
		CurMtdName = FCurrentMethod->GetMethodName();
	}

	if ( Inherited == 0 &&
	     FCurrentNativeObject == NativeObject &&
	     CurMtdName == Method->GetMethodName() )
	{
		RecursiveEnter();

		FInstructionPointer = -1;
	}
	else
	{
		clParametersList Params( Method->GetParamsCount() );

		// extract parameters from VM stack in reversed order
		for ( int i = Method->GetParamsCount() - 1; i >= 0; --i )
		{
			iParameter* Param = Method->CreateParameter( i, NULL );

			Param->PopFromStack( &FStack );

			Params[i] = Param;
		}

		Method->Invoke( NativeObject, Params );

		// erase parameters
		for ( int i = 0; i != Method->GetParamsCount(); ++i )
		{
			delete( Params[i] );
		}

		// push return value
		if ( Method->GetReturnValue() != NULL )
		{
			Method->GetReturnValue()->PushToStack( &FStack );
		}
	}

	unguard();
}

void clExecutionThread::Opcode_INHERITED_CALL()
{
	LString MethodName = ExtractString();

	iObject* NativeObject = dynamic_cast<iObject*>( FStack.Pop<iObject*>() );

	FATAL( NativeObject == NULL, "Native object is Null in InheritedCall" );

	NativeObject->SetInheritedCall();

	iStaticClass* StaticClass = NativeObject->GetStaticClass();

	FATAL( StaticClass == NULL, "Native object has no static class for method call: \"" + LString( NativeObject->ClassName() ) + "\"" );

	iMethod* Method = StaticClass->FindMethod( MethodName, NativeObject->GetInheritedCall() );

	FATAL( Method == NULL, "Native object \"" + LString( NativeObject->ClassName() ) + "\" has no method: \"" + MethodName + "\"" );

	CallMethod( NativeObject, Method, NativeObject->GetInheritedCall() );

	NativeObject->ResetInheritedCall();
}

void clExecutionThread::Opcode_CALL_METHOD()
{
	guard();

	LString MethodName = ExtractString();

	iObject* NativeObject = dynamic_cast<iObject*>( FStack.Pop<iObject*>() );

	iMethod* Method = NULL;

	FATAL( NativeObject == NULL, "Native object is Null in CallMethod" );

	iStaticClass* StaticClass = NativeObject->GetStaticClass();

	FATAL( StaticClass == NULL, "Native object has no static class for method call: \"" + LString( NativeObject->ClassName() ) + "\"" );

	Method = StaticClass->FindMethod( MethodName, 0 );

	// check if we've got a method binder
	FATAL( Method == NULL, "Native object \"" + LString( NativeObject->ClassName() ) + "\" has no method: \"" + MethodName + "\"" );

	CallMethod( NativeObject, Method, 0 );

	unguard();
}

void clExecutionThread::Opcode_CALL_STATIC_METHOD()
{
	int MethodIndex = FCurrentInstruction.FArgInt[1];

	if ( MethodIndex == -1 )
	{
		LString MethodName = FCurrentCodePatch->GetString ( FCurrentInstruction.FArgInt[0] );

		MethodIndex = Env->Linker->GetStaticMethodIndex( MethodName );

		// save index
		FCurrentInstructionPtr->FArgInt[1] = MethodIndex;
	}

	iMethod* StaticMethod = Env->Linker->GetStaticMethod( MethodIndex );

	CallMethod( 0, StaticMethod, 0 );
}

void clExecutionThread::Opcode_INSTANTIATE()
{
	guard();

	LString ClassName = ExtractString();

	iStaticClass* Class = Env->Linker->FindStaticClass( ClassName );

	// TODO: if class have many constructors - extract constructor number from stack and pass as argument
	clParametersList Params( Class->GetConstructorParamsCount( 0 ) );

	// extract parameters from VM stack in reversed order
	for ( int i = Class->GetConstructorParamsCount( 0 ) - 1; i >= 0; --i )
	{
		// TODO: implement
		iParameter* Param = NULL; // = Class->CreateParameter( i, NULL );

		Param->PopFromStack( &FStack );

		Params[i] = Param;
	}

	iObject* Object = Class->VirtualConstructor( Params );

	// erase parameters
	for ( int i = 0; i != Class->GetConstructorParamsCount( 0 ); ++i )
	{
		delete( Params[i] );
	}

	FStack.Push( Object );

	unguard();
}

void clExecutionThread::Opcode_RETURN()
{
	if ( !FRecursionStack.empty() )
	{
		FInstructionPointer = FRecursionStack.Pop<Lint>();

		RecursiveLeave();
	}
	else
	{
		FInstructionPointer = FMaxInstructions;
	}
}

void clExecutionThread::Opcode_LATENT_RETURN()
{
	FIXME( "Implement Opcode_LATENT_RETURN()" )
}

// undeclare variables within local namespace
void clExecutionThread::UndeclareVars()
{
	// 1. get local number of vars
	int SrcVarNum  = FCurrentInstruction.FDeclaredVars;
	// 2. get dest var num
	int DestVarNum = FCurrentCodePatch->GetInstructions()[FInstructionPointer].FDeclaredVars;

	// warning :
	/*

	   goto (or break, or continue) nasty_label; (declared vars here = X+0)

	   int a = 10;
	   int b = 20;

	   nasty_label: ...   (declared_vars here = X+2)

	   this is a bug, so we report this as fatal

	   (DestVarNum > SrcVarNum)

	*/

	FATAL( DestVarNum > SrcVarNum , "Invalid JMP instruction : some variables might not be declared, IP = " + LStr::ToStr( FInstructionPointer ) );

	// 3. undeclare
	for ( int i = 0; i < ( SrcVarNum - DestVarNum ); i++ )
	{
		Opcode_UNDECLARE();
	}
}

void clExecutionThread::Opcode_JMP()
{
	FInstructionPointer = FCurrentInstruction.FArgInt[0];

	UndeclareVars();
}

void clExecutionThread::Opcode_JMP_IF()
{
	if ( FStack.Pop<bool>() )
	{
		FInstructionPointer = FCurrentInstruction.FArgInt[0];

		UndeclareVars();
	}
}

void clExecutionThread::Opcode_JMP_IF_NOT()
{
	if ( FStack.Pop<bool>() == 0 )
	{
		FInstructionPointer = FCurrentInstruction.FArgInt[0];

		UndeclareVars();
	}
}

void clExecutionThread::Opcode_DECLARE()
{
	int _Size = FStack.Pop<int>();
//   LString _Name = FStack.Pop<LString>();
	LString _Name = FCurrentCodePatch->GetString( FCurrentInstruction.FArgInt[0] );

	TODO( "specify address for NEW manually for speedup" )

	clVarSymbolDeclaration* Var = new clVarSymbolDeclaration( _Name, _Size );

	// ______ "___ _'__<_+":''_ std::vector _ _: iStack ??????

	/*
	   std::vector испR<ьзу_тся, т.к. д<я -__R п_р__руж_- Rп_ратRр []
	   ч__R-тR в 'т_к_ такR_R -_ -аб<юда_тся
	*/
	FLocalVars.push_back( Var );

	// _ пRтRм пRяв<яются жа<Rбы -а скRрRсть...
}

void clExecutionThread::Opcode_UNDECLARE()
{
	FATAL( FLocalVars.empty(), "No declared local vars found" );

	clVarSymbolDeclaration* Var = FLocalVars[FLocalVars.size()-1];
	FLocalVars.pop_back();

	delete Var;
}

void clExecutionThread::Opcode_EQUAL_STRING_STRING()
{
	guard();

	LString String1;
	LString String2;

	if ( FCurrentInstruction.FArgInt[0] > 0 )
	{
		String1 = FCurrentCodePatch->GetString( FCurrentInstruction.FArgInt[0] );
	}
	else
	{
		String1 = FStack.Pop<LString>();
	}

	if ( FCurrentInstruction.FArgInt[1] > 0 )
	{
		String2 = FCurrentCodePatch->GetString( FCurrentInstruction.FArgInt[1] );
	}
	else
	{
		String2 = FStack.Pop<LString>();
	}

	FStack.Push( bool( String1 == String2 ) );

	unguard();
}

void clExecutionThread::Opcode_ADD_STRING_STRING()
{
	guard();

	LString String1;
	LString String2;

	if ( FCurrentInstruction.FArgInt[0] > 0 )
	{
		String1 = FCurrentCodePatch->GetString( FCurrentInstruction.FArgInt[0] );
	}
	else
	{
		String1 = FStack.Pop<LString>();
	}

	if ( FCurrentInstruction.FArgInt[1] > 0 )
	{
		String2 = FCurrentCodePatch->GetString( FCurrentInstruction.FArgInt[1] );
	}
	else
	{
		String2 = FStack.Pop<LString>();
	}

	// reverse order for concatenation
	FStack.Push<LString>( String2 + String1 );

	unguard();
}

iSymbolDeclaration* clExecutionThread::FindSymbol( const LString& SymbolName )
{
	/*
	   // 1. search local vars
	   for (size_t i = 0 ; i < FLocalVars.size() ; i++)
	   {
	      if (FLocalVars[i]->FVarName == SymbolName)
	      {
	         return FLocalVars[i];
	      }
	   }

	   // 2. search parameters
	   for (size_t i = 0 ; i < FParamSymbols.size() ; i++)
	   {
	      if ( SymbolName == FParamSymbols[i]->FParamName )
	      {
	         return FParamSymbols[i];
	      }
	   }
	*/
	// 3. search fields
	iObject* NativeObject = reinterpret_cast<iObject*>( FCurrentNativeObject );

	if ( NativeObject != NULL )
	{
		// search local fields
		iField* Field = NativeObject->GetStaticClass()->FindField( SymbolName );

		if ( Field != NULL )
		{
			// assign the flyweight field handler
			FFieldSymbol->FField  = Field;
			FFieldSymbol->FObject = NativeObject;
			return FFieldSymbol;
		}
	}

	// not found
	return 0;
}

void clExecutionThread::Opcode_RESIZE()
{
	LString SymName = ExtractString();

	iSymbolDeclaration* SymPtr = FindSymbol( SymName );

	if ( SymPtr == NULL )
	{
		// Try local vars

		for ( size_t i = 0 ; i < FLocalVars.size() ; i++ )
		{
			if ( FLocalVars[i]->FVarName == SymName )
			{
				SymPtr = FLocalVars[i];
				break;
			}
		}
	}

	if ( SymPtr != NULL )
	{
		// extract new size from stack
		VM_GET_VAL_FROM_STACK( int, NewSize )

		SymPtr->Resize( NewSize );
	}
}

void clExecutionThread::Opcode_LOAD_GLOBAL_VAR_ADDRESS()
{
	int VarIdx = FCurrentInstruction.FArgInt[1];

	if ( VarIdx == -1 )
	{
		// try to find the symbol
		LString VarName = FCurrentCodePatch->GetString( FCurrentInstruction.FArgInt[0] );
		VarIdx = Env->Linker->GetGlobalVarIndex( VarName );

		// update instruction in the codepatch
		FCurrentCodePatch->GetInstructions()[FInstructionPointer].FArgInt[1] = VarIdx;

		if ( VarIdx == -1 )
		{
			// if ther is still no instruction report fatal error !
			FATAL_MSG( "Global symbol " + VarName + " not found" );
		}
	}

	void* GlobalVarAddr = Env->Linker->GetGlobalVarAddress( VarIdx );

	FStack.Push<void*>( GlobalVarAddr );
}

void clExecutionThread::Opcode_LOAD_LOCAL_VAR()
{
	// combined LOAD_LOCAL_VAR_ADDRESS + LOAD_VAL_FROM_CUR_ADDR

	void* _ptr = FLocalVars[ FCurrentInstruction.FArgInt[0] ]->GetSymbolAddress();

	int size = FCurrentInstruction.FArgInt[1];

	if ( size < 0 )
	{
		// extract from stack
		VM_GET_VAL_FROM_STACK( int, _num );
		size = _num;
	}

	FStack.PushBytes( size, reinterpret_cast<char*>( _ptr ) );
}

void clExecutionThread::Opcode_LOAD_LOCAL_VAR_ADDRESS()
{
	int idx = FCurrentInstruction.FArgInt[0];
	clVarSymbolDeclaration* Var = FLocalVars[idx];
	FStack.Push<void*>( Var->GetSymbolAddress() );
}

void clExecutionThread::Opcode_LOAD_PARAM_ADDRESS()
{
	FStack.Push<void*>( FParamSymbols[FCurrentInstruction.FArgInt[0]]->GetSymbolAddress() );
}

void clExecutionThread::Opcode_LOAD_EFFECTIVE_ADDRESS()
{
	// find symbol
	LString SymbolName         = ExtractString();
	iSymbolDeclaration* Symbol = FindSymbol( SymbolName );

	if ( Symbol != NULL )
	{
		// load address
		FStack.Push<void*>( Symbol->GetSymbolAddress() );

		return;
	}

	FATAL_MSG( "Unable to find symbol : " + SymbolName );
}

void clExecutionThread::Opcode_LOAD_CLASS_FIELD_ADDRESS()
{
	// extract class and field name
	LString RefFieldName = FCurrentCodePatch->GetString( FCurrentInstruction.FArgInt[0] );

	// load class reference using address on top of stack
	//   REM : wonderful arithmetics ...
	iObject* _obj = *( FStack.Pop<iObject**>() );

	// find "metafield"
//   iStaticClass* mc = Env->Linker->FindStaticClass( LString(_obj->ClassName()) );
	iStaticClass* mc = _obj->GetStaticClass();
	iField* field    = mc->FindField( RefFieldName );

	// push the field address
	FStack.Push<void*>( field->GetFieldPtr( _obj ) );
}

// WARNING : is this 64-bit safe ?
void clExecutionThread::Opcode_ADD_OFFSET()
{
	int offset = FCurrentInstruction.FArgInt[0];

	if ( offset == -1 )
	{
		// fetch offset from the stack
		offset = FStack.Pop<int>();
	}

	// fetch base address
	int base = FStack.Pop<int>();

	// put back
	FStack.Push<int>( base + offset );
}

void clExecutionThread::Opcode_LOAD_VAL_FROM_CUR_ADDR()
{
	int size   = FCurrentInstruction.FArgInt[0];

	if ( size < 0 )
	{
		// extract from stack
		VM_GET_VAL_FROM_STACK( int, _num );
		size = _num;
	}

	// address is after the size...
	void* _ptr = FStack.Pop<void*>();

	FStack.PushBytes( size, reinterpret_cast<char*>( _ptr ) );
}

void clExecutionThread::Opcode_MAKE_REF_ASSIGNMENT()
{
// REVERSE ORDER :

	// load ref
	iObject** _objRefPtr = FStack.Pop<iObject**>();

	// assign
	*_objRefPtr = *( reinterpret_cast<iObject**>( FStack.GetPtr( FStack.size() - sizeof( iObject* ) ) ) );

	/*
	   // pop object address
	   iObject* ref = FStack.Pop<iObject*>();

	   // load ref
	   iObject** _objRefPtr = FStack.Pop<iObject**>();

	   // assign
	   *_objRefPtr = ref;

	   // push obj addr
	   FStack.Push<void*>(ref);
	*/
}

void clExecutionThread::Opcode_LOAD_CLASS_REFERENCE()
{
	// load class reference using address on top of stack
//   int _addr = FStack.Pop<int>();
//   Env->Logger->Log("_addr in classref = "+LString(_addr));
	iObject** _objRefPtr = FStack.Pop<iObject**>()/*_addr*/;
	// push actual object address
//   Env->Logger->Log("obj_addr in classref = "+LString(reinterpret_cast<int>(*_objRefPtr)));
	FStack.Push<iObject*>( *_objRefPtr );
}

void clExecutionThread::Opcode_AND_BOOL_BOOL()
{
	VM_GET_VAL_FROM_STACK( bool, b1 )
	VM_GET_VAL_FROM_STACK( bool, b2 )
	VM_PUSH_TO_STACK( bool, b1 & b2 );
}

void clExecutionThread::Opcode_OR_BOOL_BOOL()
{
	VM_GET_VAL_FROM_STACK( bool, b1 )
	VM_GET_VAL_FROM_STACK( bool, b2 )
	VM_PUSH_TO_STACK( bool, b1 | b2 );
}

void clExecutionThread::Opcode_XOR_BOOL_BOOL()
{
	VM_GET_VAL_FROM_STACK( bool, b1 )
	VM_GET_VAL_FROM_STACK( bool, b2 )
	VM_PUSH_TO_STACK( bool, b1 ^ b2 );
}

void clExecutionThread::Opcode_CONVERT_FLT_TO_STR()
{
	float f = FStack.Pop<float>();
	FStack.Push<LString>( LStr::ToStr( f ) );
}

void clExecutionThread::Opcode_CONVERT_DBL_TO_STR()
{
	double f = FStack.Pop<double>();
	FStack.Push<LString>( LStr::ToStr( f ) );
}

void clExecutionThread::Opcode_CONVERT_INT_TO_STR()
{
	int f = FStack.Pop<int>();
	FStack.Push<LString>( LStr::ToStr( f ) );
}

void clExecutionThread::Opcode_SIN_FLT()
{
	VM_PUSH_TO_STACK( float, std::sin( FStack.Pop<float>() ) );
}

void clExecutionThread::Opcode_COS_FLT()
{
	VM_PUSH_TO_STACK( float, std::cos( FStack.Pop<float>() ) );
}

void clExecutionThread::Opcode_LOG_FLT()
{
	VM_PUSH_TO_STACK( float, std::log( FStack.Pop<float>() ) );
}

void clExecutionThread::Opcode_SQRT_FLT()
{
	VM_PUSH_TO_STACK( float, std::sqrt( FStack.Pop<float>() ) );
}

void clExecutionThread::Opcode_D2R_FLT()
{
	VM_PUSH_TO_STACK( float, ::Linderdaum::Math::DegToRad( FStack.Pop<float>() ) );
}

void clExecutionThread::Opcode_R2D_FLT()
{
	VM_PUSH_TO_STACK( float, ::Linderdaum::Math::RadToDeg( FStack.Pop<float>() ) );
}

void clExecutionThread::Opcode_RAND_FLT()
{
	VM_GET_VAL_FROM_STACK( float, arg2 );
	VM_GET_VAL_FROM_STACK( float, arg1 );

	VM_PUSH_TO_STACK( float, ::Linderdaum::Math::RandomInRange( arg1, arg2 ) );
}

void clExecutionThread::Opcode_RAND_INT()
{
	VM_GET_VAL_FROM_STACK( int, arg2 );
	VM_GET_VAL_FROM_STACK( int, arg1 );

	VM_PUSH_TO_STACK( int, ::Linderdaum::Math::RandomInRange( arg1, arg2 ) );
}

//

//VM_CODE__DEFINE_SCALAR_COMPARSION(!=,COMPARE_NOT_VEC3_VEC3,vec3,vec3)
//VM_CODE__DEFINE_SCALAR_COMPARSION(==,COMPARE_VEC3_VEC3,vec3,vec3)

void clExecutionThread::Opcode_COMPARE_NOT_VEC3_VEC3()
{
	VM_GET_VAL_FROM_STACK( LVector3, v1 )
	VM_GET_VAL_FROM_STACK( LVector3, v2 )
	VM_PUSH_TO_STACK( bool, v1 != v2 );
}

void clExecutionThread::Opcode_COMPARE_VEC3_VEC3()
{
	VM_GET_VAL_FROM_STACK( LVector3, v1 )
	VM_GET_VAL_FROM_STACK( LVector3, v2 )
	VM_PUSH_TO_STACK( bool, v1 == v2 );
}

void clExecutionThread::Opcode_DOT_VEC3_VEC3()
{
	VM_GET_VAL_FROM_STACK( LVector3, v1 )
	VM_GET_VAL_FROM_STACK( LVector3, v2 )
	VM_PUSH_TO_STACK( float, v1.Dot( v2 ) );
}


void clExecutionThread::Opcode_CROSS_VEC3_VEC3()
{
	VM_GET_VAL_FROM_STACK( LVector3, v1 )
	VM_GET_VAL_FROM_STACK( LVector3, v2 )
	VM_PUSH_TO_STACK( LVector3, v1.Cross( v2 ) );
}

void clExecutionThread::Opcode_NEG_VEC3()
{
	TODO( "in-place negation without push/pop" )

	VM_GET_VAL_FROM_STACK( LVector3, v )
	VM_PUSH_TO_STACK( LVector3, -v );
}

void clExecutionThread::Opcode_NORM_VEC3()
{
	TODO( "in-place normalization without push/pop" )
	VM_GET_VAL_FROM_STACK( LVector3, v )
	VM_PUSH_TO_STACK( LVector3, v.GetNormalized() );
}

void clExecutionThread::Opcode_MUL_FLT_VEC3()
{
	TODO( "avoid second push/pop" )
	VM_GET_VAL_FROM_STACK( float, v1 )
	VM_GET_VAL_FROM_STACK( LVector3, v2 )
	VM_PUSH_TO_STACK( LVector3, v1 * v2 );
}

void clExecutionThread::Opcode_MUL_VEC3_FLT()
{
	TODO( "avoid excessive push/pop, do everything in-place" )
	// only three MULs and one pop()
	VM_GET_VAL_FROM_STACK( LVector3, v1 )
	VM_GET_VAL_FROM_STACK( float, v2 )
	VM_PUSH_TO_STACK( LVector3, v2 * v1 );
}

void clExecutionThread::Opcode_MUL_DBL_VEC3()
{
	// avoid second push/pop
	VM_GET_VAL_FROM_STACK( double, v1 )
	VM_GET_VAL_FROM_STACK( LVector3, v2 )
	VM_PUSH_TO_STACK( LVector3, static_cast<float>( v1 )*v2 );
}

void clExecutionThread::Opcode_MUL_VEC3_DBL()
{
	VM_GET_VAL_FROM_STACK( LVector3, v1 )
	VM_GET_VAL_FROM_STACK( double, v2 )
	VM_PUSH_TO_STACK( LVector3, static_cast<float>( v2 )*v1 );
}

void clExecutionThread::Opcode_DIV_VEC3_DBL()
{
	VM_GET_VAL_FROM_STACK( double, v1 )
	VM_GET_VAL_FROM_STACK( LVector3, v2 )
	VM_PUSH_TO_STACK( LVector3, static_cast<float>( v1 )*v2 );
}

void clExecutionThread::Opcode_DIV_VEC3_FLT()
{
	VM_GET_VAL_FROM_STACK( float, v1 )
	VM_GET_VAL_FROM_STACK( LVector3, v2 )
	VM_PUSH_TO_STACK( LVector3, v1 * v2 );
}

void clExecutionThread::Opcode_MUL_QUAT_VEC3()
{
	TODO( "implement" )
}

void clExecutionThread::Opcode_INVERT_QUAT()
{
	TODO( "implement" );
//   VM_GET_VAL_FROM_STACK(LQuaternion,q)
//   VM_PUSH_TO_STACK(LQuaternion,q.GetInverse());
}

void clExecutionThread::Opcode_MUL_QUAT_QUAT()
{
	VM_GET_VAL_FROM_STACK( LQuaternion, q1 )
	VM_GET_VAL_FROM_STACK( LQuaternion, q2 )
	VM_PUSH_TO_STACK( LQuaternion, q1 * q2 );
}

void clExecutionThread::Opcode_CONVERT_QUAT_TO_MTX4()
{
	TODO( "implement" );
}

void clExecutionThread::Opcode_MUL_MTX4_VEC3()
{
	VM_GET_VAL_FROM_STACK( LMatrix4, m1 )
	VM_GET_VAL_FROM_STACK( LVector3, v )
	VM_PUSH_TO_STACK( LVector3, m1 * v );
}

void clExecutionThread::Opcode_DET_MTX4()
{
//   VM_GET_VAL_FROM_STACK(LMatrix4,m)
//   VM_PUSH_TO_STACK(float,m.Det())
}

void clExecutionThread::Opcode_INVERT_MTX4()
{
	VM_GET_VAL_FROM_STACK( LMatrix4, m )
	VM_PUSH_TO_STACK( LMatrix4, m.GetInversed() );
}

void clExecutionThread::Opcode_SOURCE_POS()
{
	FATAL_MSG( "Opcode SOURCE_POS is not yet implemented" );
}

void clExecutionThread::Opcode_STACK_INFO()
{
	//
	printf( "Bytes in stack : %i\n", FStack.size() );
	fflush( stdout );
}

void clExecutionThread::Opcode_INSPECT_TOP_INT()
{
	Lint topInt = FStack.GetTop<Lint>();

	printf( "StackTop integer = %d\n", topInt );
}

void clExecutionThread::Opcode_INSPECT_TOP_FLT()
{
	float topFloat = FStack.GetTop<float>();

	printf( "StackTop float = %f\n", topFloat );
}

void clExecutionThread::Opcode_INSPECT_TOP_PTR()
{
	void* topPtr = FStack.GetTop<void*>();

#ifdef OS_64BIT
	// 64-bit code
	Luint64 _thePtr = reinterpret_cast<Luint64>( topPtr );
	unsigned int _lo = ( _thePtr & 0xFFFFFFFF );
	unsigned int _hi = ( _thePtr >> 32 );
	printf( "StackTop pointer = %d:%d\n", _hi, _lo );
#else
	printf( "StackTop pointer = %d\n", reinterpret_cast<int>( topPtr ) );
#endif
}

void clExecutionThread::Opcode_INSPECT_TOP_OBJ()
{
	iObject* topObject = *( FStack.GetTop<iObject**>() );

	iStaticClass* theClass = topObject->GetStaticClass();

#ifdef OS_64BIT
	// 64-bit code
	Luint64 _thePtr = reinterpret_cast<Luint64>( topObject );
	unsigned int _lo = ( _thePtr & 0xFFFFFFFF );
	unsigned int _hi = ( _thePtr >> 32 );
	printf( "StackTop Object\nPtr = %d:%d\nClassName = %s\nGUID = %s\n", _hi, _lo, LString( theClass->ClassName() ).c_str(), topObject->GetObjectID().c_str() );
#else
	printf( "StackTop Object\nPtr = %d\nClassName = %s\nGUID = %s\n", reinterpret_cast<int>( topObject ), LString( theClass->ClassName() ).c_str(), topObject->GetObjectID().c_str() );
#endif
}

void clExecutionThread::Opcode_INSPECT_TOP_STR()
{
	// no need for optimization : it is only a debug
	LString str = FStack.Pop<LString>();

	printf( "StackTop string = %s\n", str.c_str() );

	FStack.Push<LString>( str );
}

//////////////////////////
// Scalar value loading
//////////////////////////

#define VM_CODE__DEFINE_VALUE_PUSHER(OpCode,type,instructionField)   \
      VM_CODE__EXECUTOR_HEADER(OpCode)       \
      VM_PUSH_TO_STACK(type,instructionField);        \
   }

// load variable's value, leaving this value on stack

// we may not to pop/push the value
// and just copy the top of the stack to extracted address
#define VM_CODE__DEFINE_SCALAR_VALUE_LOADER(OpCode,type)                   \
      VM_CODE__EXECUTOR_HEADER(OpCode)                                     \
         VM_GET_VAL_FROM_STACK(type*,addr)                                 \
         *addr = *(reinterpret_cast<type*>(FStack.GetPtr(FStack.size()-sizeof(type))));   \
      }

// load variable's value, removing this value from stack
#define VM_CODE__DEFINE_SCALAR_VALUE_LOADER_NOSTACK(OpCode,type)  \
      VM_CODE__EXECUTOR_HEADER(OpCode)                            \
         VM_GET_VAL_FROM_STACK(type*,addr)                        \
         VM_GET_VAL_FROM_STACK(type,val)                          \
         *addr = val;                                             \
      }

// load variable's value from instruction argument, removing this value from stack
#define VM_CODE__DEFINE_SCALAR_VALUE_LOADER_NOSTACK_IMM(OpCode,type)          \
      VM_CODE__EXECUTOR_HEADER(OpCode)                \
         type val = *reinterpret_cast<type*>(&FCurrentInstruction.FArgInt[0]); \
         VM_GET_VAL_FROM_STACK(void *,voidAddr)          \
         type *_ptr = reinterpret_cast<type *>(voidAddr);   \
         *_ptr = val;                     \
      }

VM_CODE__DEFINE_VALUE_PUSHER( PUSH_INT, int, FCurrentInstruction.FArgInt[0] )
VM_CODE__DEFINE_VALUE_PUSHER( PUSH_DOUBLE, double, FCurrentInstruction.FArgFloat[0] )
VM_CODE__DEFINE_VALUE_PUSHER( PUSH_FLOAT, float, static_cast<float>( FCurrentInstruction.FArgFloat[0] ) )
VM_CODE__DEFINE_VALUE_PUSHER( PUSH_BOOL, bool,/*static_cast<bool>(FCurrentInstruction.FArgByte[0])*/FCurrentInstruction.FArgInt[0] != 0 )
VM_CODE__DEFINE_VALUE_PUSHER( PUSH_BYTE, Lubyte, static_cast<Lubyte>( FCurrentInstruction.FArgInt[0] ) )

VM_CODE__DEFINE_SCALAR_VALUE_LOADER( LOAD_BOOL, bool )
VM_CODE__DEFINE_SCALAR_VALUE_LOADER( LOAD_INT, int )
VM_CODE__DEFINE_SCALAR_VALUE_LOADER( LOAD_BYTE, Lubyte )
VM_CODE__DEFINE_SCALAR_VALUE_LOADER( LOAD_FLOAT, float )
VM_CODE__DEFINE_SCALAR_VALUE_LOADER( LOAD_DOUBLE, double )

VM_CODE__DEFINE_SCALAR_VALUE_LOADER_NOSTACK( SLOAD_INT, int )
VM_CODE__DEFINE_SCALAR_VALUE_LOADER_NOSTACK( SLOAD_FLOAT, float )

VM_CODE__DEFINE_SCALAR_VALUE_LOADER_NOSTACK_IMM( SLOAD_INT_IMM, int )
VM_CODE__DEFINE_SCALAR_VALUE_LOADER_NOSTACK_IMM( SLOAD_FLOAT_IMM, float )



//
// Conversion operations

#define VM_CODE__DEFINE_SCALAR_CONVERSION(srcType,destType,srcName,destName)  \
      VM_CODE__EXECUTOR_HEADER(CVT_##srcName##_TO_##destName)                 \
         VM_GET_VAL_FROM_STACK(srcType,srcVal)                                \
         VM_PUSH_TO_STACK(destType,static_cast<destType>(srcVal));            \
      }

VM_CODE__DEFINE_SCALAR_CONVERSION( int, bool, INT, BOOL )
VM_CODE__DEFINE_SCALAR_CONVERSION( int, float, INT, FLT )
VM_CODE__DEFINE_SCALAR_CONVERSION( int, double, INT, DBL )
VM_CODE__DEFINE_SCALAR_CONVERSION( int, Lubyte, INT, BYTE )

VM_CODE__DEFINE_SCALAR_CONVERSION( bool, int, BOOL, INT )
VM_CODE__DEFINE_SCALAR_CONVERSION( bool, float, BOOL, FLT )
VM_CODE__DEFINE_SCALAR_CONVERSION( bool, double, BOOL, DBL )
VM_CODE__DEFINE_SCALAR_CONVERSION( bool, Lubyte, BOOL, BYTE )

VM_CODE__DEFINE_SCALAR_CONVERSION( float, Lubyte, FLT, BYTE )
VM_CODE__DEFINE_SCALAR_CONVERSION( float, bool, FLT, BOOL )
VM_CODE__DEFINE_SCALAR_CONVERSION( float, int, FLT, INT )
VM_CODE__DEFINE_SCALAR_CONVERSION( float, double, FLT, DBL )

VM_CODE__DEFINE_SCALAR_CONVERSION( double, int, DBL, INT )
VM_CODE__DEFINE_SCALAR_CONVERSION( double, bool, DBL, BOOL )
VM_CODE__DEFINE_SCALAR_CONVERSION( double, float, DBL, FLT )
VM_CODE__DEFINE_SCALAR_CONVERSION( double, Lubyte, DBL, BYTE )

VM_CODE__DEFINE_SCALAR_CONVERSION( Lubyte, int, BYTE, INT )
VM_CODE__DEFINE_SCALAR_CONVERSION( Lubyte, bool, BYTE, BOOL )
VM_CODE__DEFINE_SCALAR_CONVERSION( Lubyte, float, BYTE, FLT )
VM_CODE__DEFINE_SCALAR_CONVERSION( Lubyte, double, BYTE, DBL )


///////////////
// Comparsion
///////////////

// NEW_ARG_ORDER :

#define VM_CODE__DEFINE_SCALAR_COMPARSION(OpChar,OpCode,type1,type2) \
      VM_CODE__EXECUTOR_HEADER(OpCode)       \
         VM_GET_VAL_FROM_STACK(type1,v1)     \
         VM_GET_VAL_FROM_STACK(type2,v2)     \
         bool res = v1 OpChar v2;      \
         VM_PUSH_TO_STACK(bool,res);         \
      }

// a block of similar conversion operators (all type1/type2/type3 combinations)
#define VM_CODE__DEFINE_SCALAR_COMPARSIONS_BLOCK(OpChar,OpCodeBase,type1,type2,type3,type1name,type2name,type3name)  \
   VM_CODE__DEFINE_SCALAR_COMPARSION(OpChar,OpCodeBase##_##type1name##_##type1name,type1,type1) \
   VM_CODE__DEFINE_SCALAR_COMPARSION(OpChar,OpCodeBase##_##type2name##_##type2name,type2,type2) \
   VM_CODE__DEFINE_SCALAR_COMPARSION(OpChar,OpCodeBase##_##type3name##_##type3name,type3,type3) \
   VM_CODE__DEFINE_SCALAR_COMPARSION(OpChar,OpCodeBase##_##type1name##_##type2name,type1,type2) \
   VM_CODE__DEFINE_SCALAR_COMPARSION(OpChar,OpCodeBase##_##type2name##_##type1name,type2,type1) \
   VM_CODE__DEFINE_SCALAR_COMPARSION(OpChar,OpCodeBase##_##type3name##_##type2name,type3,type2) \
   VM_CODE__DEFINE_SCALAR_COMPARSION(OpChar,OpCodeBase##_##type2name##_##type3name,type2,type3) \
   VM_CODE__DEFINE_SCALAR_COMPARSION(OpChar,OpCodeBase##_##type3name##_##type1name,type3,type1) \
   VM_CODE__DEFINE_SCALAR_COMPARSION(OpChar,OpCodeBase##_##type1name##_##type3name,type1,type3)

// a block of blocks of scalar comparsions (for each comparsion operator)
#define VM_CODE__DEFINE_ALL_SCALAR_COMPARSIONS(type1,type2,type3,type1name,type2name,type3name) \
   VM_CODE__DEFINE_SCALAR_COMPARSIONS_BLOCK(==,COMPARE,type1,type2,type3,type1name,type2name,type3name) \
   VM_CODE__DEFINE_SCALAR_COMPARSIONS_BLOCK(!=,COMPARE_NOT,type1,type2,type3,type1name,type2name,type3name) \
   VM_CODE__DEFINE_SCALAR_COMPARSIONS_BLOCK(>=,GE,type1,type2,type3,type1name,type2name,type3name) \
   VM_CODE__DEFINE_SCALAR_COMPARSIONS_BLOCK(<=,LE,type1,type2,type3,type1name,type2name,type3name) \
   VM_CODE__DEFINE_SCALAR_COMPARSIONS_BLOCK(>,GREATER,type1,type2,type3,type1name,type2name,type3name) \
   VM_CODE__DEFINE_SCALAR_COMPARSIONS_BLOCK(<,LESSER,type1,type2,type3,type1name,type2name,type3name)

VM_CODE__DEFINE_ALL_SCALAR_COMPARSIONS( int, float, double, INT, FLT, DBL )

/// \cond

// used in binary arithm operations (and assignments)
template <int Flag, typename T> struct VM_ZeroChecker;

template <typename T> struct VM_ZeroChecker<0, T>
{
	// empty checker
	static void CheckValue( T val, const LString& Msg ) {};
};

template <typename T> struct VM_ZeroChecker<1, T>
{
	// div-by-zero checker
	static void CheckValue( T val, const LString& Msg )
	{
		if ( val == 0 ) { exit( 255 ); }

		//FATAL( val == 0, Msg );
	};
};

/// \endcond

//////////////////////////////
// Arithmetical assignments
//////////////////////////////


#define VM_CODE__DEFINE_ARITHM_ASSIGNMENT(OpCode,OpChar,destType,srcType,ZeroCheckFlag)   \
      VM_CODE__EXECUTOR_HEADER(OpCode)                         \
         VM_GET_VAL_FROM_STACK(void *,addr)                    \
         VM_GET_VAL_FROM_STACK(srcType,addon)                  \
         destType *_ptr = reinterpret_cast<destType *>(addr);  \
         destType rightValue = static_cast<destType>(addon);   \
         if (ZeroCheckFlag)                                     \
         {                                                     \
            VM_ZeroChecker<ZeroCheckFlag,destType>::CheckValue(rightValue,LString("Division by zero in assignment : ")+LString(#destType)+LString("/")+LString(#srcType)); \
         }                                                     \
         *_ptr OpChar rightValue;                              \
         VM_PUSH_TO_STACK(destType,(*_ptr));                   \
      }

// vec3 by float , e.g.

#define VM_CODE__DEFINE_CROSS_ASSIGNMENT(OpCode,OpChar,destType,srcType,downCast,ZeroCheckFlag) \
      VM_CODE__EXECUTOR_HEADER(OpCode)                         \
         VM_GET_VAL_FROM_STACK(destType*,addr)                 \
         VM_GET_VAL_FROM_STACK(srcType,rightValue)             \
         if (ZeroCheckFlag)                                     \
         {                                                     \
            VM_ZeroChecker<ZeroCheckFlag,srcType>::CheckValue(rightValue,LString("Division by zero in assignment : ")+LString(#destType)+LString("/")+LString(#srcType)); \
         }                                                     \
         (*addr) OpChar static_cast<downCast>(rightValue);     \
         VM_PUSH_TO_STACK(destType,(*addr));                   \
      }

#define VM_CODE__DEFINE_ARITHM_ASSIGNMENT_BY_NAME(OpCodeBase,Infix,OpChar,type1,type2,type1name,type2name,ZeroCheckFlag) \
      VM_CODE__DEFINE_ARITHM_ASSIGNMENT(OpCodeBase##_##type1name##_##Infix##_##type2name,OpChar,type2,type1,ZeroCheckFlag) \
 
#define VM_CODE__DEFINE_CROSS_ASSIGNMENT_BY_NAME_DOWNCAST(OpCodeBase,Infix,OpChar,type1,downCast,type2,type1name,type2name,ZeroCheckFlag) \
      VM_CODE__DEFINE_CROSS_ASSIGNMENT(OpCodeBase##_##type1name##_##Infix##_##type2name,OpChar,type2,type1,downCast,ZeroCheckFlag) \
 
#define VM_CODE__DEFINE_ALL_ARITHM_ASSIGNMENTS(type1,type2,type1name,type2name)           \
      VM_CODE__DEFINE_ARITHM_ASSIGNMENT_BY_NAME(ADD,TO,+=,type1,type2,type1name,type2name,0) \
      VM_CODE__DEFINE_ARITHM_ASSIGNMENT_BY_NAME(SUB,FROM,-=,type1,type2,type1name,type2name,0)  \
      VM_CODE__DEFINE_ARITHM_ASSIGNMENT_BY_NAME(MUL,BY,*=,type1,type2,type1name,type2name,0) \
      VM_CODE__DEFINE_ARITHM_ASSIGNMENT_BY_NAME(DIV,BY,/=,type1,type2,type1name,type2name,1)

// Assignments
VM_CODE__DEFINE_ALL_ARITHM_ASSIGNMENTS( int, int, INT, INT )
VM_CODE__DEFINE_ALL_ARITHM_ASSIGNMENTS( int, double, INT, DBL )
VM_CODE__DEFINE_ALL_ARITHM_ASSIGNMENTS( double, int, DBL, INT )
VM_CODE__DEFINE_ALL_ARITHM_ASSIGNMENTS( double, double, DBL, DBL )
VM_CODE__DEFINE_ALL_ARITHM_ASSIGNMENTS( int, float, INT, FLT )
VM_CODE__DEFINE_ALL_ARITHM_ASSIGNMENTS( double, float, DBL, FLT )
VM_CODE__DEFINE_ALL_ARITHM_ASSIGNMENTS( float, int, FLT, INT )
VM_CODE__DEFINE_ALL_ARITHM_ASSIGNMENTS( float, double, FLT, DBL )
VM_CODE__DEFINE_ALL_ARITHM_ASSIGNMENTS( float, float, FLT, FLT )


///////////////////
// Arithmetics
///////////////////

// argument order is reversed, since it is a stack

#define VM_CODE__DEFINE_BINARY_OPERATION(OpChar,OpCode,type1,type2,resType,ZeroCheckFlag)             \
      VM_CODE__EXECUTOR_HEADER(OpCode)                      \
         VM_GET_VAL_FROM_STACK(type1,v1)                    \
         VM_GET_VAL_FROM_STACK(type2,v2)                    \
         if (ZeroCheckFlag)                                  \
         {                                                  \
            VM_ZeroChecker<ZeroCheckFlag,type2>::CheckValue(v2,LString("Division by zero : ")+LString(#type1)+LString("/")+LString(#type2)); \
         }                                                     \
         resType localResult = static_cast<resType>(v1) OpChar static_cast<resType>(v2);  \
         VM_PUSH_TO_STACK(resType,localResult);                \
      }

#define VM_CODE__DEFINE_BINARY_OPERATION_BY_NAMES(OpChar,OpCodeBase,type1,type2,resType,type1name,type2name,ZeroCheckFlag) \
   VM_CODE__DEFINE_BINARY_OPERATION(OpChar,OpCodeBase##_##type1name##_##type2name,type1,type2,resType,ZeroCheckFlag)

// define all (+,-,*,/) operations for a pair of types
#define VM_CODE__DEFINE_ALL_BINARY_OPERATIONS_FOR_PAIR(type1,type2,resType,type1name,type2name)    \
   VM_CODE__DEFINE_BINARY_OPERATION_BY_NAMES(+,ADD,type1,type2,resType,type1name,type2name,0)   \
   VM_CODE__DEFINE_BINARY_OPERATION_BY_NAMES(-,SUB,type1,type2,resType,type1name,type2name,0)   \
   VM_CODE__DEFINE_BINARY_OPERATION_BY_NAMES(*,MUL,type1,type2,resType,type1name,type2name,0)   \
   VM_CODE__DEFINE_BINARY_OPERATION_BY_NAMES(/,DIV,type1,type2,resType,type1name,type2name,1)

// binary scalar arithmetics
VM_CODE__DEFINE_ALL_BINARY_OPERATIONS_FOR_PAIR( int, int, int, INT, INT )
VM_CODE__DEFINE_ALL_BINARY_OPERATIONS_FOR_PAIR( int, float, float, INT, FLT )
VM_CODE__DEFINE_ALL_BINARY_OPERATIONS_FOR_PAIR( int, double, double, INT, DBL )

VM_CODE__DEFINE_ALL_BINARY_OPERATIONS_FOR_PAIR( float, int, float, FLT, INT )
VM_CODE__DEFINE_ALL_BINARY_OPERATIONS_FOR_PAIR( float, float, float, FLT, FLT )
VM_CODE__DEFINE_ALL_BINARY_OPERATIONS_FOR_PAIR( float, double, double, FLT, DBL )

VM_CODE__DEFINE_ALL_BINARY_OPERATIONS_FOR_PAIR( double, int, double, DBL, INT )
VM_CODE__DEFINE_ALL_BINARY_OPERATIONS_FOR_PAIR( double, float, double, DBL, FLT )
VM_CODE__DEFINE_ALL_BINARY_OPERATIONS_FOR_PAIR( double, double, double, DBL, DBL )

// unary arithmetics
#define VM_CODE__DEFINE_UNARY_OPERATION(OpChar,OpCode,type,resType)     \
      VM_CODE__EXECUTOR_HEADER(OpCode)          \
         VM_GET_VAL_FROM_STACK(type,vv)            \
         resType resVal = OpChar static_cast<resType>(vv); \
         VM_PUSH_TO_STACK(resType,resVal);   \
      }

VM_CODE__DEFINE_UNARY_OPERATION( +, PLUS_INT, int, int )
VM_CODE__DEFINE_UNARY_OPERATION( +, PLUS_DBL, double, double )
VM_CODE__DEFINE_UNARY_OPERATION( +, PLUS_FLT, float, float )

VM_CODE__DEFINE_UNARY_OPERATION( -, NEG_INT, int, int )
VM_CODE__DEFINE_UNARY_OPERATION( -, NEG_FLT, float, float )
VM_CODE__DEFINE_UNARY_OPERATION( -, NEG_DBL, double, double )

VM_CODE__DEFINE_UNARY_OPERATION( !, NOT_BOOL, bool, bool )
VM_CODE__DEFINE_UNARY_OPERATION( !, NOT_INT, int, int )
VM_CODE__DEFINE_UNARY_OPERATION( !, NOT_FLT, float, float )
VM_CODE__DEFINE_UNARY_OPERATION( !, NOT_DBL, double, double )

///////////////////////////
// Increments/Decrements //
///////////////////////////

TODO( "optimize this. we don't need to do pop/push on increments" )

#define VM_CODE__DEFINE_INCREMENT(OpCode,type)                 \
      VM_CODE__EXECUTOR_HEADER(OpCode)          \
      VM_GET_VAL_FROM_STACK(void *,voidAddr)          \
      type *_ptr     = reinterpret_cast<type *>(voidAddr);  \
      ++(*_ptr);                 \
      VM_PUSH_TO_STACK(type,(*_ptr));           \
      }

//    this line is only valid if (sizeof(type) == sizeof(void*))
//    (**(reinterpret_cast<type *>(FStack.GetPtr(sizeof(type)))))++; \


#define VM_CODE__DEFINE_DECREMENT(OpCode,type)           \
      VM_CODE__EXECUTOR_HEADER(OpCode)       \
      VM_GET_VAL_FROM_STACK(void *,voidAddr)       \
      type *_ptr     = reinterpret_cast<type *>(voidAddr);  \
      --(*_ptr);              \
      VM_PUSH_TO_STACK(type,(*_ptr));        \
      }

//    this line is only valid if (sizeof(type) == sizeof(void*))
//    (**(reinterpret_cast<type *>(FStack.GetPtr(sizeof(type)))))--; \

VM_CODE__DEFINE_INCREMENT( INC_INT, int )
VM_CODE__DEFINE_INCREMENT( INC_FLOAT, float )
VM_CODE__DEFINE_INCREMENT( INC_DOUBLE, double )

VM_CODE__DEFINE_DECREMENT( DEC_INT, int )
VM_CODE__DEFINE_DECREMENT( DEC_FLOAT, float )
VM_CODE__DEFINE_DECREMENT( DEC_DOUBLE, double )

///////// Vector/Mtx/Quat support

VM_CODE__DEFINE_ARITHM_ASSIGNMENT_BY_NAME( ADD, TO, += , LVector3, LVector3, VEC3, VEC3, 0 )
VM_CODE__DEFINE_ARITHM_ASSIGNMENT_BY_NAME( SUB, FROM, -= , LVector3, LVector3, VEC3, VEC3, 0 )

VM_CODE__DEFINE_CROSS_ASSIGNMENT_BY_NAME_DOWNCAST( MUL, BY, *= , float, float, LVector3, VEC3, FLT, 0 )
VM_CODE__DEFINE_CROSS_ASSIGNMENT_BY_NAME_DOWNCAST( MUL, BY, *= , double, float, LVector3, VEC3, DBL, 0 )
VM_CODE__DEFINE_CROSS_ASSIGNMENT_BY_NAME_DOWNCAST( DIV, BY, /= , float, float, LVector3, VEC3, FLT, 1 )
VM_CODE__DEFINE_CROSS_ASSIGNMENT_BY_NAME_DOWNCAST( DIV, BY, /= , double, float, LVector3, VEC3, DBL, 1 )

VM_CODE__DEFINE_BINARY_OPERATION( +, ADD_VEC3_VEC3, LVector3, LVector3, LVector3, 0 )
VM_CODE__DEFINE_BINARY_OPERATION( -, SUB_VEC3_VEC3, LVector3, LVector3, LVector3, 0 )
//VM_CODE__DEFINE_BINARY_OPERATION(*,DOT_VEC3_VEC3,LVector3,LVector3,float,0)

VM_CODE__DEFINE_ARITHM_ASSIGNMENT_BY_NAME( MUL, BY, *= , LQuaternion, LQuaternion, QUAT, QUAT, 0 )
VM_CODE__DEFINE_BINARY_OPERATION_BY_NAMES(*, MUL, LMatrix4, LMatrix4, LMatrix4, MTX4, MTX4, 0 )
