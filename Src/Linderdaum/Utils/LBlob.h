/**
 * \file LBlob.h
 * \brief Large binary object. Array marshaller for managed environments and network transfers
 * \version 0.6.00
 * \date 25/09/2011
 * \author Viktor Latypov, 2011
 * \author viktor@linderdaum.com http://www.linderdaum.com
 */

#pragma once

#ifndef __TheBlob__h__included__
#define __TheBlob__h__included__

#include <malloc.h>
#include <string.h>

#include "Core/iObject.h"

/**
typedef unsigned int uint32;

/// Bob Jenkins' on_at_a_time hash function (http://burtleburtle.net/bob/hash/doobs.html)
uint32 JenkinsHash(const char *key, size_t len, uint32 mask)
{
   uint32 hash, i;

   const char* val_ptr = key;
   for (uint32 hash = 0, i = 0 ; i < len ; ++i)
   {
      hash += *val_ptr;
      hash += (hash << 10);
      hash ^= (hash >> 6);
      val_ptr++;
   }

   hash += (hash << 3);
   hash ^= (hash >> 11);
   hash += (hash << 15);

   return (hash & mask);
}
*/

//------------------------------------------------------------------------------

/**
   \brief A chunk of raw memory with hashing capabilities

   I. Uses:

   a) Used for native-to-managed (script, jni, .net, lua) array marshalling

   E.g., if a user wants a direct access to some array, he/she might use the Set/GetByte() methods

   b) Bitmaps/Heightmaps can be converted to this blob. Memory/File streams can also be converted to blob

   c) Selected items from the blob (a.k.a. array elements) can be bound to some console variables.

   d) This class can, in theory, replace the Packet class in network lib

   II. Creation and memory management

   Blobs are created using Linker or ResourceManager.

   Memory for the blob is allocated internaly on demand (SetSize/alloc methods) or
   the blob can refer to the preallocated memory chunk (FOwnsData flag).

   III. Strong typing

   Items of the blob (accessed with Get<Type>Item(int idx) methods) can have many types (scalars, strings and vec/mtx)

   IV. Serialization

   Blob can act as a storage analogous to the mlNode: autogenerated save/load procedures
   can use the Read/Write methods and support endian-independent structure layout
*/
class netexportable scriptfinal clBlob: public iObject
{
public:
	clBlob(): FData( NULL ), FOwnsData( false ), FSize( 0 ), FAllocatedSize( 0 ), FByteEndianness( ENDIANNESS ) {}
	virtual ~clBlob() { Delete(); }

	virtual void AfterConstruction() {}

	/// Set the blob data pointer to some external memory block
	void SetExternalData( void* Ptr, size_t Sz )
	{
		Delete();

		FData = Ptr;
		FAllocatedSize = Sz;
		FSize = Sz;
		FOwnsData = false;
	}

	/// Constant access to the blob's data
	inline void* GetDataConst() const { return FData; }

	/// Direct access to blob's data
	inline void* GetData() { return FData; }

	/// Alias (setter method) for the reallocator
	scriptmethod void SetSize( size_t NewSize ) { Reallocate( NewSize ); }

	/// Get current blob size
	scriptmethod size_t GetSize() const { return FSize; }

	/// Check if this blob manages its own contents
	scriptmethod bool OwnsData() const { return FOwnsData; }

	/// Change ownership of the memory block
	scriptmethod void SetOwnership( bool Ownership ) { FOwnsData = Ownership; }

	/// Make a local copy of the other blob. Can change memory ownership of this blob on reallocation
	scriptmethod bool CopyBlob( const clBlob* Other ) { return CopyMemoryBlock( Other->GetDataConst(), Other->GetSize() ); }

	/// Check if this blob refers to some data
	scriptmethod bool HasData() const  { return ( FData != NULL ); }

	/**
	   \brief Binary comparison with other blob (strcmp() analogue)
	   Error codes: 0 if equal, -1/+1 if other is longer/shorter than this
	   0xFF - one of the blobs contains null data
	*/
	scriptmethod int CompareContents( const clBlob* Other ) const
	{
		if ( !FData || !Other->HasData() ) { return 0xFF; }

		if ( this->FSize == Other->GetSize() ) { return memcmp( FData, Other->GetDataConst(), this->FSize ); }

		return ( this->FSize > Other->GetSize() ) ? 1 : -1;
	}

	/// Copy blob contents from external source
	bool CopyMemoryBlock( const void* FromData, size_t FromSize )
	{
		if ( ( !FromData ) || ( FromSize <= 0 ) ) { return false; }

		// only re-allocate if not enough space
		Reallocate( FromSize );

		this->FSize = FromSize;

		memcpy( this->FData, FromData, FromSize );

		return true;
	}

	/// Template Set method to avoid inclusion of custom type headers (vec3/mtx etc)
	template<class T>
	void SetPOD( size_t Offset, T TheValue ) { SetBytes( Offset, sizeof( T ), ( Lubyte* )&TheValue ); }

	/// Template Get method to avoid inclusion of custom type headers (vec3/mtx etc)
	template<class T>
	T GetPOD( size_t Offset ) { T Tmp; GetBytes( Offset, sizeof( T ), ( Lubyte* )&Tmp ); return Tmp; }

	/// Item access
	scriptmethod void SetByte( size_t Offset, Lubyte TheByte ) { ( ( Lubyte* )FData )[Offset] = TheByte; }

	/// Quick access to the specififed byte. No range checking
	scriptmethod Lubyte GetByte( size_t Offset ) const { return ( ( Lubyte* )FData )[Offset]; }

//	script_method void SetUInt16(size_t Offset, uint16 Word);
//	script_method void SetUInt32(size_t Offset, uint32 DWord);
//	script_method uint16 GetUInt16(size_t Offset) const;
//	script_method uint32 GetUInt32(size_t Offset) const;

	void SetBytes( size_t Offset, size_t Num, const Lubyte* Src ) { memcpy( ( Lubyte* )FData + Offset, Src, Num ); }
	void GetBytes( size_t Offset, size_t Num, Lubyte* Out ) const { memcpy( Out, ( Lubyte* )FData + Offset, Num ); }

	/// Copy Count bytes from another blob
	scriptmethod void CopyFrom( const clBlob* Other, size_t SrcOffset, size_t DestOffset, size_t Count )
	{
		SetBytes( DestOffset, Count, ( ( Lubyte* )Other->GetDataConst() ) + SrcOffset );
	}

	/// Resize and do not spoil the contents
	scriptmethod bool SafeResize( size_t NewSize )
	{
		if ( !FOwnsData ) { return false; }

		if ( !FData ) { Allocate( NewSize ); return true; }

		FData = ::realloc( FData, NewSize );

		if ( !FData ) { return false; }

		FSize = FAllocatedSize = NewSize;

		return true;
	}

private:
	/// Pointer to the blob data
	void*  FData;

	/// Effective size of the blob
	size_t FSize;

	/// Actually allocated size (used for faster resize and copy operations)
	size_t FAllocatedSize;

	/// True if this Blob manages and deallocates the memory block
	bool   FOwnsData;

#pragma region Memory management

	/// Allocate new block and change ownership type
	inline void Allocate( size_t NewSize )
	{
		FData = ::malloc( NewSize );
		FSize = FAllocatedSize = NewSize;
		FOwnsData = true;
	}

	/// Try to delete the memory block. Not exposed as a public method, because direct access here can cause troubles.
	inline void Delete()
	{
		if ( !FOwnsData || FData == NULL ) { return; }

		::free( FData );
		FData = NULL;
		FSize = FAllocatedSize = 0;
		FOwnsData = false;
	}

	/// Reallocate the data block if it is required
	void Reallocate( size_t NewSize )
	{
		if ( !FData ) { Allocate( NewSize ); }

		if ( FData != NULL )
		{
			if ( NewSize > FAllocatedSize )
			{
				// try to delete
				Delete();

				// change ownership
				Allocate( NewSize );
			}
			else if ( NewSize <= FAllocatedSize )
			{
				// do nothing, just change the size
				FSize = NewSize;
			}
		}
	}

#pragma endregion

public:
	/// Endianness is not yet supported
	LEndianness FByteEndianness; // Big or Little

	/*
	   /// Get pascal-style string beginning at the given offset (int_size and then the utf8-encoded string)
	   script_method string GetString(size_t Offset);

	   /// Store pascal-style string at the given location
	   script_method void SetString(size_t Offset, const string& Str);

	   /// Filling procedures

	   /// Restart blob reading
	   script_method void RestartRead() { FCurrentPos = 0; }

	   /// Restart blob writing
	   script_method void RestartWrite() { FSize = 0; FCurrentPos = 0; }

	   /// Current read/write position
	   size_t FCurrentPos;

	   script_method uint8 ReadByte() { return GetByte(FCurrentPos++); }
	   script_method void WriteByte(uint8 TheByte) { SetByte(FCurrentPos, TheByte); FCurrentPos++; }

	   void ReadBytes();
	   void WriteBytes();

	   ReadString
	   WriteString
	*/
};

#endif
