/**
 * \file TextRenderer.cpp
 * \brief FreeType-based text renderer implementation
 * \version 0.5.99
 * \date 13/04/2011
 * \author Viktor Latypov, 2011
 * \author viktor@linderdaum.com http://www.linderdaum.com
 */

#include "TextRenderer.h"

#ifndef _WIN32
#include <dlfcn.h>
#else
#include <windows.h>
#endif

//#include <cstdio>

#include "Bitmap.h"
#include "Environment.h"
#include "Core/Linker.h"
#include "Core/VFS/FileSystem.h"
#include "Renderer/iRenderContext.h"
#include "Renderer/iVertexArray.h"
#include "Geometry/VertexAttribs.h"
#include "Utils/Viewport.h"

#pragma region Initialization

/**
   One more dynamic linking wrapper for FreeType library

   Why on Earth such an excellent project does NOT provide autogenerated function prototypes for dynamic linking possibility ?
*/

typedef FT_Error ( *FT_Init_FreeType_func )( FT_Library* alibrary );
typedef FT_Error ( *FT_Done_FreeType_func )( FT_Library  library );

typedef FT_Error ( *FT_Activate_Size_func )( FT_Size  size );

typedef FT_Error ( *FT_New_Face_func )( FT_Library library, const char* filepathname, FT_Long face_index, FT_Face* aface );
typedef FT_Error ( *FT_New_Memory_Face_func )( FT_Library library, const FT_Byte* file_base, FT_Long file_size, FT_Long face_index, FT_Face* aface );

typedef void     ( *FT_Glyph_Get_CBox_func )( FT_Glyph glyph, FT_UInt bbox_mode, FT_BBox* acbox );
typedef FT_Error ( *FT_Get_Kerning_func )( FT_Face face, FT_UInt left_glyph, FT_UInt right_glyph, FT_UInt kern_mode, FT_Vector* akerning );

typedef FT_Error ( *FTC_Manager_New_func )( FT_Library library, FT_UInt max_faces, FT_UInt max_sizes, FT_ULong max_bytes, FTC_Face_Requester requester, FT_Pointer req_data, FTC_Manager* amanager );
typedef void     ( *FTC_Manager_Done_func )( FTC_Manager manager );

typedef FT_Error ( *FTC_ImageCache_New_func )( FTC_Manager manager, FTC_ImageCache* acache );
typedef FT_Error ( *FTC_ImageCache_Lookup_func )( FTC_ImageCache cache, FTC_ImageType type, FT_UInt gindex, FT_Glyph* aglyph, FTC_Node* anode );

typedef FT_Error ( *FTC_CMapCache_New_func )( FTC_Manager manager, FTC_CMapCache* acache );
typedef FT_UInt  ( *FTC_CMapCache_Lookup_func )( FTC_CMapCache cache, FTC_FaceID face_id, FT_Int cmap_index, FT_UInt32 char_code );

typedef void     ( *FTC_Node_Unref_func )( FTC_Node node, FTC_Manager manager );

typedef FT_Error ( *FTC_Manager_LookupFace_func )( FTC_Manager manager, FTC_FaceID face_id, FT_Face* aface );
typedef FT_Error ( *FTC_Manager_LookupSize_func )( FTC_Manager manager, FTC_Scaler scaler,  FT_Size* asize );

FT_Init_FreeType_func FT_Init_FreeTypePTR;

FT_Activate_Size_func FT_Activate_SizePTR;
FT_Done_FreeType_func FT_Done_FreeTypePTR;

FT_New_Face_func FT_New_FacePTR;
FT_New_Memory_Face_func FT_New_Memory_FacePTR;

FT_Glyph_Get_CBox_func FT_Glyph_Get_CBoxPTR;
FT_Get_Kerning_func FT_Get_KerningPTR;

FTC_Manager_New_func FTC_Manager_NewPTR;
FTC_Manager_Done_func FTC_Manager_DonePTR;

FTC_ImageCache_New_func FTC_ImageCache_NewPTR;
FTC_ImageCache_Lookup_func FTC_ImageCache_LookupPTR;

FTC_CMapCache_New_func FTC_CMapCache_NewPTR;
FTC_CMapCache_Lookup_func FTC_CMapCache_LookupPTR;

FTC_Node_Unref_func FTC_Node_UnrefPTR;

FTC_Manager_LookupFace_func FTC_Manager_LookupFacePTR;
FTC_Manager_LookupSize_func FTC_Manager_LookupSizePTR;

// HMODULE for Windows
void* hFTDll = NULL;

/// Number of initializations for multiple instances of TextRenderer
int FTLoadCount = 0;

#if defined(ANDROID)
extern "C"
{
	FT_Error FT_Init_FreeType( FT_Library* alibrary );
	FT_Error FT_Done_FreeType( FT_Library  library );
	FT_Error FT_Activate_Size( FT_Size  size );
	FT_Error FT_New_Face( FT_Library library, const char* filepathname, FT_Long face_index, FT_Face* aface );
	FT_Error FT_New_Memory_Face( FT_Library library, const FT_Byte* file_base, FT_Long file_size, FT_Long face_index, FT_Face* aface );
	void     FT_Glyph_Get_CBox( FT_Glyph glyph, FT_UInt bbox_mode, FT_BBox* acbox );
	FT_Error FT_Get_Kerning( FT_Face face, FT_UInt left_glyph, FT_UInt right_glyph, FT_UInt kern_mode, FT_Vector* akerning );
	FT_Error FTC_Manager_New( FT_Library library, FT_UInt max_faces, FT_UInt max_sizes, FT_ULong max_bytes, FTC_Face_Requester requester, FT_Pointer req_data, FTC_Manager* amanager );
	void     FTC_Manager_Done( FTC_Manager manager );
	FT_Error FTC_ImageCache_New( FTC_Manager manager, FTC_ImageCache* acache );
	FT_Error FTC_ImageCache_Lookup( FTC_ImageCache cache, FTC_ImageType type, FT_UInt gindex, FT_Glyph* aglyph, FTC_Node* anode );
	FT_Error FTC_CMapCache_New( FTC_Manager manager, FTC_CMapCache* acache );
	FT_UInt  FTC_CMapCache_Lookup( FTC_CMapCache cache, FTC_FaceID face_id, FT_Int cmap_index, FT_UInt32 char_code );
	void     FTC_Node_Unref( FTC_Node node, FTC_Manager manager );
	FT_Error FTC_Manager_LookupFace( FTC_Manager manager, FTC_FaceID face_id, FT_Face* aface );
	FT_Error FTC_Manager_LookupSize( FTC_Manager manager, FTC_Scaler scaler,  FT_Size* asize );
}
#endif // ANDROID

#ifdef OS_64BIT
const LString AdditionalDLLPath = "../../Libs.Win64/";
#else
const LString AdditionalDLLPath = "../../Libs.Win32/";
#endif

LString DetectLibrary( const LString& LibName )
{
	if ( clFileSystem::FileExistsPhys( LibName ) ) { return LibName; }

	if ( clFileSystem::FileExistsPhys( AdditionalDLLPath + LibName ) ) { return AdditionalDLLPath + LibName; }

	if ( clFileSystem::FileExistsPhys( "..\\..\\" + AdditionalDLLPath + LibName ) ) { return LString( "..\\..\\" ) + AdditionalDLLPath + LibName; }

	return "";
}

bool LoadFT()
{
	if ( hFTDll != NULL ) { return true; }

#if defined(_WIN32) || defined(_WIN64)

#define LOAD_FT_FUNC(Func_) \
   Func_##PTR = (Func_##_func) GetProcAddress( (HMODULE)hFTDll, #Func_ ); \
   if(! Func_##PTR) { /*printf("Cannot load %s function !\n", #Func_ );*/ return false; }

	/*
	*/
	LString LibName;

#ifdef _WIN64
	LibName = "libfreetype-6-64.dll";
#else
	LibName = "libfreetype-6-32.dll";
#endif

	LString DllName = DetectLibrary( LibName );

	if ( DllName.empty() )
	{
		return false;
	}

	*( ( HMODULE* )&hFTDll ) = LoadLibrary( DllName.c_str() );

	if ( hFTDll == INVALID_HANDLE_VALUE )
	{
//		printf("Cannot load FreeType dll !\n");
		return false;
	}

#else

#if defined(ANDROID)

#define LOAD_FT_FUNC(Func_) Func_##PTR = &Func_;

#else

#define LOAD_FT_FUNC(Func_) Func_##PTR = (Func_##_func) dlsym( hFTDll, #Func_ ); \
    if(!Func_##PTR) {\
        /* fprintf(stderr, "Error loading FreeType function [%s]\n", #Func_ ); fflush(stderr);*/ \
    return false;\
  }

#endif

#if defined(__APPLE__)
	// .dylib on MacOS
//		hFTDll = dlopen("libfreetype.6.3.16.dylib", RTLD_LAZY);
	// or the direct Framework name
	hFTDll = dlopen( "/Libraries/Frameworks/FreeType", RTLD_LAZY );
#else
#if defined(ANDROID)

	// static link, do nothing
#else
	// .so on Linux and other unixes
	hFTDll = dlopen( "libfreetype.so" /*.so.6*/, RTLD_LAZY );
#endif
#endif
#endif

	LOAD_FT_FUNC( FT_Init_FreeType )

	LOAD_FT_FUNC( FT_Activate_Size )
	LOAD_FT_FUNC( FT_Done_FreeType )

	LOAD_FT_FUNC( FT_New_Face )
	LOAD_FT_FUNC( FT_New_Memory_Face )

	LOAD_FT_FUNC( FT_Glyph_Get_CBox )
	LOAD_FT_FUNC( FT_Get_Kerning )

	LOAD_FT_FUNC( FTC_Manager_New )
	LOAD_FT_FUNC( FTC_Manager_Done )

	LOAD_FT_FUNC( FTC_ImageCache_New )
	LOAD_FT_FUNC( FTC_ImageCache_Lookup )

	LOAD_FT_FUNC( FTC_CMapCache_New )
	LOAD_FT_FUNC( FTC_CMapCache_Lookup )

	LOAD_FT_FUNC( FTC_Node_Unref )

	LOAD_FT_FUNC( FTC_Manager_LookupFace )
	LOAD_FT_FUNC( FTC_Manager_LookupSize )

#undef LOAD_FT_FUNC

	FTLoadCount++;

//	printf("Loaded FT\n");

	return true;
}

void UnloadFT()
{
	if ( hFTDll == NULL ) { return; }

	FTLoadCount--;

	if ( FTLoadCount > 0 ) { return; }

#if defined(_WIN32) || defined(_WIN64)
	CloseHandle( hFTDll );
#else

#if !defined(ANDROID)
	// dynamic link almost everywhere
	dlclose( hFTDll );
#endif

#endif
	hFTDll = NULL;
}

clTextRenderer::clTextRenderer()
 : FInitialized( false ),
	FString(),
	FLibrary( NULL ),
	FManager( NULL ),
	FImageCache( NULL ),
	FCMapCache( NULL )
{
	InitFreeType();

	FCurrentFont = NULL;
	FCurrentFontHeight = 8;

	FMaskMode = false;
}

void clTextRenderer::InitFreeType()
{
	FInitialized = LoadFT();

	if ( FInitialized )
	{
		FInitialized = false;

		if ( FT_Init_FreeTypePTR( &FLibrary ) != 0 ) { return; }

		if ( FTC_Manager_NewPTR( FLibrary, 0, 0, 0, FreeType_Face_Requester, this, &FManager ) != 0 ) { return; }

		if ( FTC_ImageCache_NewPTR( FManager, &FImageCache ) != 0 ) { return; }

		if ( FTC_CMapCache_NewPTR( FManager, &FCMapCache ) != 0 ) { return; }

		FInitialized = true;
	}
}

void clTextRenderer::StopFreeType()
{
	FreeString();

	// deallocate font handles and release font buffers
	for ( std::map<LString, void*>::iterator p = FAllocatedFonts.begin(); p != FAllocatedFonts.end() ; p++ )
	{
		// ? FT_FreeFace (FFontFaceHandles[p->first]);

		delete[] ( char* )( p->second );
	}

	for ( size_t i = 0 ; i != FFontFaces.size() ; i++ )
	{
		FFontFaces[i]->DisposeObject();
	}

	FFontFaces.clear();

	if ( FManager ) { FTC_Manager_DonePTR( FManager ); }

	if ( FLibrary ) { FT_Done_FreeTypePTR( FLibrary ); }
}

clTextRenderer::~clTextRenderer()
{
	StopFreeType();
}

#pragma endregion
// end of init code


#ifdef DO_NOT_USE_ENGINE
bool ReadFileData( const char* fname, char** DataPtr, int& DataLen )
{
	FILE* f = fopen( fname, "rb" );

	if ( f == NULL ) { return false; }

	fseek( f, 0, SEEK_END );
	DataLen = ftell( f );
	fseek( f, 0, SEEK_SET );

	if ( DataLen <= 0 ) { return false; }

	*DataPtr = new char[DataLen];

	if ( *DataPtr == NULL ) { return false; }

	if ( fread( *DataPtr, 1, DataLen, f ) < 0 ) { return false; }

	fclose( f );

	return true;
}
#endif

FT_Error clTextRenderer::LoadFontFile( const LString& FileName )
{
	if ( !FInitialized ) { return -1; }

//	printf("Loading %s\n", FileName.c_str());

	if ( FAllocatedFonts.count( FileName ) > 0 ) { return 0; }

	char* Data = NULL;

#ifdef DO_NOT_USE_ENGINE
	int DataSize;
	ReadFileData( FileName.c_str(), &Data, DataSize );
#else
	Luint64 DataSize;
	Env->FileSystem->LoadFileData( FileName, ( void** )&Data, &DataSize );
#endif

	FT_Face TheFace;

	// 0 is the face index
	FT_Error Result = FT_New_Memory_FacePTR( FLibrary, ( FT_Byte* )Data, ( FT_Long )DataSize, 0, &TheFace );

	if ( Result == 0 )
	{
		FFontFaceHandles[FileName] = TheFace;
		FAllocatedFonts[FileName] = ( void* )Data;

		clFontFace* F = Env->Linker->Instantiate( "clFontFace" );
		F->FFileName = FileName;
		F->FFamily.clear();
		F->FStyle = 0x0;
		FFontFaces.push_back( F );
	}

	return Result;
}

FT_Error clTextRenderer::FreeType_Face_Requester( FTC_FaceID FaceID, FT_Library Library, FT_Pointer RequestData, FT_Face* TheFace )
{
	clFontFace* Face = ( clFontFace* ) FaceID;

	if ( !Face ) { return 1; }

	clTextRenderer* This = ( clTextRenderer* )RequestData;

	FT_Error LoadResult = This->LoadFontFile( Face->FFileName );

	*TheFace = ( LoadResult == 0 ) ? This->FFontFaceHandles[Face->FFileName] : NULL;

	return LoadResult;
}

void clTextRenderer::FreeString()
{
	for ( size_t i = 0 ; i < FString.size() ; i++ )
	{
		if ( FString[i].FCacheNode != NULL )
		{
			FTC_Node_UnrefPTR( FString[i].FCacheNode, FManager );
			FString[i].FCacheNode = NULL;
		}
	}

	FString.clear();
}

FT_UInt clTextRenderer::GetCharIndex( clFontFace* Font, FT_UInt Char )
{
	/// Default charmap causes severe problems on Mac OS. There is another default encoding
	return FTC_CMapCache_LookupPTR( FCMapCache, Font, -1 /* use default cmap */, Char );
}

FT_Glyph clTextRenderer::GetGlyph( clFontFace* Font, int Height, FT_UInt Char, FT_UInt LoadFlags, FTC_Node* CNode )
{
	FT_UInt Index = GetCharIndex( Font, Char );
//	if(Index == 0) return NULL;

	FTC_ImageTypeRec ImageType;

	ImageType.face_id = Font;
	ImageType.height = Height;
	ImageType.width = 0;
	ImageType.flags = LoadFlags;

	FT_Glyph Glyph;

	if ( FTC_ImageCache_LookupPTR( FImageCache, &ImageType, Index, &Glyph, CNode ) != 0 ) { return NULL; }

	return Glyph;
}

void clTextRenderer::SetAdvance( sFTChar& Char )
{
	Char.FAdvance = Char.FWidth = 0;

	if ( !Char.FGlyph ) { return; }

	Char.FAdvance = Char.FGlyph->advance.x >> 10;

	FT_BBox bbox;
	FT_Glyph_Get_CBoxPTR( Char.FGlyph, FT_GLYPH_BBOX_GRIDFIT, &bbox );
	Char.FWidth = bbox.xMax;

	// use advance as the width for empty glyphs (like space)
	if ( Char.FWidth == 0 && Char.FAdvance != 0 ) { Char.FWidth = Char.FAdvance; }
}

void clTextRenderer::Kern( sFTChar& Left, const sFTChar& Right )
{
	if ( Left.FIndex == -1 || Right.FIndex == -1 ) { return; }

	FT_Vector Delta;
	FT_Get_KerningPTR( Left.FFace, Left.FIndex, Right.FIndex, FT_KERNING_DEFAULT, &Delta );

	Left.FAdvance += Delta.x;
}

FT_Face clTextRenderer::GetSizedFace( clFontFace* Font, int Height )
{
	FTC_ScalerRec Scaler;

	Scaler.face_id = Font;
	Scaler.height = Height;
	Scaler.width = 0;
	Scaler.pixel = 1;

	FT_Size SizedFont;

	if ( FTC_Manager_LookupSizePTR( FManager, &Scaler, &SizedFont ) != 0 ) { return NULL; }

	if ( FT_Activate_SizePTR( SizedFont ) != 0 ) { return NULL; }

	return SizedFont->face;
}

clFontFace* clTextRenderer::GetFontHandle( const LString& FileName )
{
	if ( LoadFontFile( FileName ) != 0 ) { return NULL; }

	for ( size_t i = 0 ; i != FFontFaces.size() ; i++ )
	{
		if ( FFontFaces[i]->FFileName == FileName ) { return FFontFaces[i]; }
	}

//	printf("Not found %s\n", FileName.c_str());

	return NULL;
}

bool clTextRenderer::LoadTextStringWithFont( const LString& TextString, clFontFace* Font, int FontHeight, LTextEncoding Encoding )
{
	if ( Font == NULL ) { return false; }

	// 1. Get the font face

	FT_Face Face = GetSizedFace( Font, FontHeight );

	if ( Face == NULL ) { return false; }

	// We do not use line breaks, so the metrics are not yet used
	// FT_Size_Metrics Metrics = Face->size->metrics;

	bool UseKerning = FT_HAS_KERNING( Face );

	// 2. Decode utf8 string
	if ( Encoding == Encoding_UTF8 )
	{
		DecodeUTF8( TextString.c_str() );
	}
	else if ( Encoding == Encoding_UCS2 )
	{
		// directly use the string
		const unsigned short* UCS2Ptr = ( const unsigned short* )TextString.c_str();

		FreeString();
		FString.resize( ( TextString.length() + 1 ) / 2 );

		for ( size_t  i = 0 ; i < FString.size() ; i++ )
		{
			// Endianness matters here
			FString[i].FChar = ( UCS2Ptr[i] >> 8 ) + ( ( UCS2Ptr[i] & 0xFF ) << 8 );
		}
	}
	else
	{
		return false;
	}

	// 3. Calculate character sizes

	for ( size_t i = 0, count = FString.size(); i != count; i++ )
	{
		sFTChar& Char = FString[i];
		Char.FFace = Face;

		Char.FIndex = ( Char.FChar != '\r' && Char.FChar != '\n' ) ? GetCharIndex( Font, Char.FChar ) : -1;
		Char.FGlyph = ( Char.FIndex != -1 ) ? GetGlyph( Font, FontHeight, Char.FChar, FT_LOAD_RENDER, &Char.FCacheNode ) : NULL;

		SetAdvance( Char );

		if ( i > 0 && UseKerning ) { Kern( FString[i-1], Char ); }
	}

	return true;
}

int clTextRenderer::CalculateLineWidth() const
{
	int Size = 0;

	// Sum individual character sizes
	for ( size_t i = 0 ; i < FString.size(); i++ )
	{
		Size += FString[i].FAdvance;
	}

	return Size >> 6;
}

int clTextRenderer::CalculateLineHeight() const
{
	int Size = 0;

	for ( size_t  i = 0 ; i < FString.size(); i++ )
	{
		if ( FString[i].FGlyph == NULL ) { continue; }

		FT_BitmapGlyph BmpGlyph = ( FT_BitmapGlyph ) FString[i].FGlyph;
		int Y = BmpGlyph->top;
		int H = BmpGlyph->bitmap.rows;

		if ( -Y + H > Size ) { Size = -Y + H; }
	}

	return Size;
}

void clTextRenderer::CalculateLineParameters( int* Width, int* MinY, int* MaxY, int* BaseLine ) const
{
	int StrMinY = -1000;
	int StrMaxY = -1000;

	if ( FString.empty() )
	{
		StrMinY = 0;
		StrMaxY = 0;
	}

	int SizeX = 0;

	for ( size_t i = 0 ; i != FString.size(); i++ )
	{
		if ( FString[i].FGlyph == NULL ) { continue; }

		FT_BitmapGlyph BmpGlyph = ( FT_BitmapGlyph )FString[i].FGlyph;

		SizeX += FString[i].FAdvance;

		int Y = BmpGlyph->top;
		int H = BmpGlyph->bitmap.rows;

		if ( Y     > StrMinY ) { StrMinY = Y; }
		if ( H - Y > StrMaxY ) { StrMaxY = H - Y; }
	}

	if ( Width    ) *Width = ( SizeX >> 6 );
	if ( BaseLine ) *BaseLine = StrMaxY;
	if ( MinY     ) *MinY = StrMinY;
	if ( MaxY     ) *MaxY = StrMaxY;
}

void clTextRenderer::CalculateLineParametersFloat( int* Width, int* MinY, int* MaxY, int* BaseLine, float* TextWidth, float* TextHeight ) const
{
	int StrMinY, StrMaxY, StrWidth;

	CalculateLineParameters( &StrWidth, &StrMinY, &StrMaxY, BaseLine );

	if ( TextWidth  ) *TextWidth  = fabs( static_cast<float>( StrWidth        ) ) / Env->Viewport->GetWidth();
	if ( TextHeight ) *TextHeight = fabs( static_cast<float>( StrMaxY+StrMinY ) ) / Env->Viewport->GetHeight();
	if ( Width      ) *Width = StrWidth;
	if ( MinY       ) *MinY  = StrMinY;
	if ( MaxY       ) *MaxY  = StrMaxY;
}

inline uint64_t MakeGlyphKey( size_t Face, size_t Size, size_t Index )
{
	union uPacker
	{
		struct sParams
		{
			unsigned int m_Face:22;
			unsigned int m_Size:10;
			unsigned int m_Index;
		} S;
		uint64_t m_Key;
	} Packer;

	Packer.S.m_Face = Face;
	Packer.S.m_Size = Size;
	Packer.S.m_Index = (unsigned int)Index;

	return Packer.m_Key;
};

void clTextRenderer::UpdateGlyphsCache( FT_Bitmap* Bitmap, const sFTChar& Char, int Size, sCacheEntry* Entry )
{
	LASSERT( Bitmap->pixel_mode == FT_PIXEL_MODE_GRAY );
	LASSERT( Entry );

	int W = Bitmap->width;
	int H = Bitmap->rows;

	if ( W == 0 || H == 0 ) return;

	uint64_t Key = MakeGlyphKey( (size_t)Char.FFace, Size, Char.FIndex );

	if ( Env->Renderer->GetGlyphsCache()->HasGlyph( Key, Entry ) ) return;

	clBitmap* OutMask = clBitmap::CreateBitmap( Env, W, H, 1, FMaskMode ? L_BITMAP_GRAYSCALE8 : L_BITMAP_BGRA8, L_TEXTURE_2D );
	OutMask->Clear( LC_Black );

	DrawGlyphOnBitmap( OutMask, Bitmap, 0, 0, LC_White );

	*Entry = Env->Renderer->GetGlyphsCache()->InsertGlyph( OutMask, Key );

	delete( OutMask );
}

void clTextRenderer::RenderLineOnBitmap( const LString& TextString, clFontFace* Font, int FontHeight, int StartX, int Y, const vec4& Color, LTextEncoding Encoding, bool LeftToRight, clBitmap* Out )
{
	LoadTextStringWithFont( TextString, Font, FontHeight, Encoding );

	int x = StartX << 6;

	for ( size_t j = 0 ; j != FString.size(); j++ )
	{
		if ( FString[j].FGlyph != 0 )
		{
			FT_BitmapGlyph BmpGlyph = ( FT_BitmapGlyph ) FString[j].FGlyph;

			int in_x = ( x >> 6 ) + ( ( LeftToRight ? 1 : -1 ) * BmpGlyph->left );

			if ( !LeftToRight )
			{
				in_x += BmpGlyph->bitmap.width;
				in_x = StartX + ( StartX - in_x );
			}

			DrawGlyphOnBitmap( Out, &BmpGlyph->bitmap, in_x, Y - BmpGlyph->top, Color );

			sCacheEntry CacheEntry;

			UpdateGlyphsCache( &BmpGlyph->bitmap, FString[j], FontHeight, &CacheEntry );
		}

		x += FString[j].FAdvance;
	}
}

sVAContainer::~sVAContainer()
{
	// TODO
}

void sVAContainer::Done()
{
	delete( FVertexArray   );
	delete( FVertexAttribs );
}

void sVAContainer::Init( sEnvironment* Env )
{
	// enough to render 4096 glyphs as triangles
	const int MaxGlyphs = 4096;

	FVertexAttribs = clVertexAttribs::Create( 6 * MaxGlyphs, L_TEXCOORDS_BIT | L_COLORS_BIT );	
	FVertexArray   = Env->Renderer->AllocateEmptyVA();
	FVertexArray->SetVertexAttribs( FVertexAttribs );
	FVertexAttribs->SetActiveVertexCount( 0 );
}

void sVAContainer::Reset()
{
	if ( FVertexAttribs )
	{
		// enough to render 4096 glyphs as triangles
		const int MaxGlyphs = 4096;

		FVertexAttribs->Restart( L_PT_TRIANGLE, 6 * MaxGlyphs, L_TEXCOORDS_BIT | L_COLORS_BIT );
	}
}

size_t clTextRenderer::RenderLineInVertexAttribs( const LVector2& Origin, const LString& TextString, clFontFace* Font, int FontHeight, int StartX, int Y, const vec4& Color, LTextEncoding Encoding, bool LeftToRight, std::vector<sVAContainer>& Out )
{
	LoadTextStringWithFont( TextString, Font, FontHeight, Encoding );

	int x = StartX << 6;

	float ViewportW = static_cast<float>( Env->Viewport->GetWidth()  );
	float ViewportH = static_cast<float>( Env->Viewport->GetHeight() );

	for ( size_t j = 0 ; j != FString.size(); j++ )
	{
		if ( FString[j].FGlyph != 0 )
		{
			FT_BitmapGlyph BmpGlyph = ( FT_BitmapGlyph ) FString[j].FGlyph;

			int in_x = ( x >> 6 ) + ( LeftToRight ? BmpGlyph->left : -BmpGlyph->left );

			if ( !LeftToRight )
			{
				in_x += BmpGlyph->bitmap.width;
				in_x = StartX + ( StartX - in_x );
			}

			sCacheEntry CacheEntry;

			UpdateGlyphsCache( &BmpGlyph->bitmap, FString[j], FontHeight, &CacheEntry );

			size_t PageIndex = CacheEntry.FCachePage;

			if ( Out.size() < Env->Renderer->GetGlyphsCache()->GetTotalPages() ) Out.resize( Env->Renderer->GetGlyphsCache()->GetTotalPages() );

			float X1 = static_cast<float>( in_x );
			float Y1 = static_cast<float>( Y - BmpGlyph->top );
			float X2 = X1 + BmpGlyph->bitmap.width;
			float Y2 = Y1 + BmpGlyph->bitmap.rows;

			X1 = X1 / ViewportW + Origin.x;
			X2 = X2 / ViewportW + Origin.x;
			Y1 = Y1 / ViewportH + Origin.y;
			Y2 = Y2 / ViewportH + Origin.y;

			float U1 = CacheEntry.FRect.X1();
			float V1 = CacheEntry.FRect.Y1();
			float U2 = CacheEntry.FRect.X2();
			float V2 = CacheEntry.FRect.Y2();

			if ( Out[PageIndex].empty() ) Out[PageIndex].Init( Env );

			bool R = CacheEntry.FRotated;
			clVertexAttribs* VA = Out[PageIndex].FVertexAttribs;

			VA->SetColorV( Color );

			VA->SetTexCoordV2( R ? LVector2(U1, V1) : LVector2(U1, V1) );
			VA->EmitVertex( X1, Y1, 0.0f, -1, -1 );

			VA->SetTexCoordV2( R ? LVector2(U2, V1) : LVector2(U1, V2) );
			VA->EmitVertex( X1, Y2, 0.0f, -1, -1 );

			VA->SetTexCoordV2( R ? LVector2(U1, V2) : LVector2(U2, V1) );
			VA->EmitVertex( X2, Y1, 0.0f, -1, -1 );

			VA->SetTexCoordV2( R ? LVector2(U2, V1) : LVector2(U1, V2) );
			VA->EmitVertex( X1, Y2, 0.0f, -1, -1 );

			VA->SetTexCoordV2( R ? LVector2(U1, V2) : LVector2(U2, V1) );
			VA->EmitVertex( X2, Y1, 0.0f, -1, -1 );

			VA->SetTexCoordV2( R ? LVector2(U2, V2) : LVector2(U2, V2) );
			VA->EmitVertex( X2, Y2, 0.0f, -1, -1 );
		}

		x += FString[j].FAdvance;
	}

	return FString.size() * 6;
}

void clTextRenderer::RenderLine( const LString& TextString, int X, int Y, const vec4& Color, LTextEncoding Encoding, bool LeftToRight, clBitmap* Out )
{
	if ( FCurrentFont == NULL ) { return; }

	RenderLineOnBitmap( TextString, FCurrentFont, FCurrentFontHeight, X, Y, Color, Encoding, LeftToRight, Out );
}

/// Create appropriate bitmap and render text line using selected font
clBitmap* clTextRenderer::RenderText( const LString& TextString, const vec4& Color, LTextEncoding Encoding, bool LeftToRight )
{
	LoadTextString( TextString, Encoding );
	int W, Y;
	int MinY, MaxY;
	CalculateLineParameters( &W, &MinY, &MaxY, &Y );
//	int H = MaxY - MinY;
	int H2 = MaxY + MinY;

	clBitmap* Result = clBitmap::CreateBitmap( Env, W, H2, 1, FMaskMode ? L_BITMAP_GRAYSCALE8 : L_BITMAP_BGRA8, L_TEXTURE_2D );
//	Result->Clear( LC_Black );

	RenderLine( TextString, LeftToRight ? 0 : W - 1, MinY, Color, Encoding, LeftToRight, Result );

	return Result;
}

/// Create appropriate bitmap and render text line using specified font
clBitmap* clTextRenderer::RenderTextWithFont( const LString& TextString, clFontFace* Font, int FontHeight, const vec4& Color, LTextEncoding Encoding, bool LeftToRight )
{
	LoadTextStringWithFont( TextString, Font, FontHeight, Encoding );

	int W, Y;
	int MinY, MaxY;
	CalculateLineParameters( &W, &MinY, &MaxY, &Y );
	int H2 = MaxY + MinY;

	clBitmap* Result = clBitmap::CreateBitmap( Env, W, H2, 1, FMaskMode ? L_BITMAP_GRAYSCALE8 : L_BITMAP_BGRA8, L_TEXTURE_2D );
//	Result->Clear( LC_Black );

	RenderLineOnBitmap( TextString, Font, FontHeight, LeftToRight ? 0 : W - 1, MinY, Color, Encoding, LeftToRight, Result );
//	Result->DrawLine2D(0, MinY, W-1, MinY, Color);

	return Result;
}

/// Multiply each component of the int-encoded color by Mult
inline vec4 MultColor( const vec4& Color, int Mult )
{
	vec4 Res = Color;
	Res.W = ( ( float )Mult ) / 255.0f;

	return Res;
}

// dump FT_Bitmap to our image
void clTextRenderer::DrawGlyphOnBitmap( clBitmap* Out, FT_Bitmap* Bitmap, int X0, int Y0, const vec4& Color ) const
{
	int Width = Out->GetWidth() - X0;

	if ( Width > Bitmap->width ) { Width = Bitmap->width; }

	for ( int Y = Y0 ; Y < Y0 + Bitmap->rows ; ++Y )
	{
		unsigned char* Src = Bitmap->buffer + ( Y - Y0 ) * Bitmap->pitch;

		if ( FMaskMode )
		{
			for ( int X = X0 + 0 ; X < X0 + Width ; X++ )
			{
				int Int = *Src++;

				vec4 OutMaskCol = vec4( ( ( float )Int ) / ( 255.0f ) );

				Out->SetPixel( X, Y, 0, OutMaskCol ); 
			}
		}
		else
		{
			for ( int X = X0 + 0 ; X < X0 + Width ; X++ )
			{
				int Int = *Src++;
				vec4 Col = MultColor( Color, Int );

			 	// This is wrong. Color should be blended with the background using Int value.
				if ( Int > 0 ) { Out->SetPixel( X, Y, 0, Col ); }
			}
		}
	}
}

clGlyphsCache::clGlyphsCache()
 : FCache( NULL ),
	FGlyphsMap()
{
}

void clGlyphsCache::AfterConstruction()
{
	FCache = clPtr<clImageCache>( Construct<clImageCache>( Env ) );
	FCache->InitCache( 512, 512, L_BITMAP_GRAYSCALE8 );
	FCache->SetSeparation( LVector2i( 1, 1 ) );
}

clGlyphsCache::~clGlyphsCache()
{
}

sCacheEntry clGlyphsCache::InsertGlyph( clBitmap* Bitmap, uint64_t GlyphKey )
{
	std::map< uint64_t, sCacheEntry >::const_iterator i = FGlyphsMap.find( GlyphKey );

	if ( i == FGlyphsMap.end() )
	{	
		sCacheEntry Entry = FCache->InsertBitmap( Bitmap );
		FGlyphsMap[ GlyphKey ] = Entry;
		return Entry;
	}

	return i->second;
}

bool clGlyphsCache::HasGlyph( uint64_t GlyphKey, sCacheEntry* Entry )
{
	std::map< uint64_t, sCacheEntry >::const_iterator i = FGlyphsMap.find( GlyphKey );

	if ( i == FGlyphsMap.end() ) return false;

	if ( Entry ) *Entry = i->second;

	return true;
}

size_t clGlyphsCache::GetTotalPages() const
{
	return FCache->GetTotalPages();
}

clBitmap* clGlyphsCache::GetPageBitmap(size_t Idx) const
{
	return FCache->GetPageBitmap( Idx );
}

iTexture* clGlyphsCache::GetPageTexture(size_t Idx) const
{
	return FCache->GetPageTexture( Idx );
}
